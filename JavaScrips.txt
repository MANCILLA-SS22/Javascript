 - HTML <script> Tag: The <script> tag is used to embed a client-side script (JavaScript). The <script> element either contains scripting statements, or it points to an external script file through the src attribute. Common uses for 
  JavaScript are image manipulation, form validation, and dynamic changes of content.

    ~ <script src="./main.js"></script>         
    ~ <script async src="./main.js"></script        Specifies that the script is downloaded in parallel to parsing the page, and executed as soon as it is available (before parsing completes) (only for external scripts)
    ~ <script defersrc="./main.js"></script>        Specifies that the script is downloaded in parallel to parsing the page, and executed after the page has finished parsing (only for external scripts)

Existen tres casos para poner el archivo script, los cuales son: 
  1) Cuando no tenemos ningun atributo en el script, lo que se hace primro es que el navegador interpretare el archivo HTML para que se descargue el script y despues de eso, seguir con la interpretacion del JS (va al final del HTML)
  2) El segundo caso reduce el tiempo de pausa de interpretacion del html, por lo que ganaermos en cargar mas cosas antes de llegar a la pausa (va al final del head)
  3) El ultimo, sirve para no bloquear la interpretacion del HTML en toda la descarga de la web. Esta se realiza igual que el segundo caso, pero con la diferencia de que la ejecucion se hace despues de la carga (va al final del head)


- Como crear variables en javascript

   > var definimos una variable con local scope, también nos permite utilizar un comportamiento llamado hoisting, sin generar ningún error. El ámbito, significa esencialmente dónde están disponibles estas variables para su uso. Las
     declaraciones var tienen un ámbito global o un ámbito de función/local. El ámbito es global cuando una variable var se declara fuera de una función. Esto significa que cualquier variable que se declare con var fuera de una función está 
     disponible para su uso en toda la pantalla. var tiene un ámbito local cuando se declara dentro de una función. Esto significa que está disponible y solo se puede acceder a ella dentro de esa función. 
     Las variables con var se pueden volver a declarar y modificar. 

   > let definimos variable con block scope, las variables declaradas de esta manera nos genera un error de referencia cuando intentamos utilizar hoisting. Un bloque es un trozo de código delimitado por {}. Un bloque vive entre llaves. Todo 
     lo que está dentro de llaves es un bloque. Así que una variable declarada en un bloque con let  solo está disponible para su uso dentro de ese bloque.

   > const definimos variables de sólo lectura (no confundir con inmutables), esto quiere decir que, cuando asignamos una variable, el nombre de esta va estar asignada a un puntero en memoria, el cual no puede ser sobreescrito o reasignado.
     Las variables declaradas con const mantienen valores constantes. Las declaraciones const similitudes con las declaraciones let. Al igual que las declaraciones let, solamente se puede acceder a las declaraciones const dentro del bloque 
     en el que fueron declaradas. const no puede modificarse ni volver a declararse Esto significa que el valor de una variable declarada con const s el mismo dentro de su ámbito. No se puede actualizar ni volver a declarar. 
     
     Las declaraciones con let y const tienen controles adicionales para las variables. Principalmente impiden que se puedan crear dos variables con el mismo nombre. Una variable let puede recibir múltiples asignaciones en el transcurso de 
     la aplicación, es decir que puede cambiar de valor varias veces. Una constante const recibe una única asignación al momento de su declaración, impidiendo que su valor se modifique luego.
     
     let te permite declarar variables limitando su alcance (scope) al bloque, declaración, o expresión donde se está usando. A diferencia de la palabra clave var la cual define una variable global o local en una función sin importar el 
     ámbito del bloque. La otra diferencia entre var y let es que este último se inicializa a un valor sólo cuando un analizador lo evalúa. Al igual que const, let no crea propiedades del objeto se declara globalmente (en el alcance más 
     alto)

- Tipos de mensajes en pantalla

    > prompt(): La sentencia prompt() mostrará un cuadro de diálogo para que el usuario ingrese un dato. Se puede proporcionar un mensaje que se colocará sobre el campo de texto. El valor que devuelve es una cadena que representa lo que el 
      usuario ingresó. En la pantalla del navegador, el usuario verá una ventana sobre la web que le solicitará un dato. Al valor que el usuario ingresa se lo conoce por el término de entrada.
                                                                          
    > console.log(): La sentencia console.log() muestra el mensaje que pasemos como parámetro a la llamada en la consola JavaScript del Navegador web
    
    > alert(): mostrará una ventana sobre la página web que estemos accediendo mostrando el mensaje que se pase como parámetro a la llamada. Al valor que mostramos al usuario como un resultado se lo conoce por el término de salida.
    
    > Existen dos formas de concatenar algo: 
      1. +;
      2. ` ${nombreDeVariable} `;

- Operadores logicos

==             Es igual                                       a == b
===            Es estrictamente igual                         a === b
!=             Es distinto                                    a != b
!==            Es estrictamente distinto                      a != b
<, <=, >, >=   Menor, menor o igual, mayor, mayor o igual     a <= b
&&             Operador and (y)                               a && b
||             Operador or (o)                                a || b
!              Operador not (no)                              !a

   > Diferencia entre "==" y "===": El operador de estricta igualdad ( === ) revisa si dos operandos son iguales y produce un resultado Booleano. A diferencia del operador de igualdad regular (==), el operador de estricta igualdad siempre
     considera que los operandos de distinto tipo de valor son diferentes y nunca similares.
     (==): Se utiliza para comparar variables o valores. Los dobles iguales no comprueban el tipo de dato variable/valor mientras se hace la comparación. Usa este operador cuando no estés seguro sobre el tipo de datos de la 
     variable/valor. ‘1’ == 1 Esto devolverá true porque los valores dobles iguales no verifican el tipo de datos. 0 == falseDevolverá true porque convierte el 0 en falso y luego lo compara. 7 == “7” // true	
     (===): También se utiliza para comparar variables/valores. Triple igual comprueba el tipo de datos de una variable durante la comparación. Usa este operador cuando estés seguro del tipo de datos de la variable/valor y desees una 
            comparación estricta. ‘1’ === 1Esto devolverá false porque los triples iguales también comparan el tipo de datos. Simplemente el 1 es de tipo string y no es un número. 0 === false Devolverá false porque son diferentes tipos de 
            datos. 7 === “7” // false
               
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Funciones

  > Declaracion de una funcion: una función, declarada como una instrucción separada, en el flujo de código principal.
       
       function sum(a, b) {
       return a + b;
       };
    
    Una Declaración de Función puede ser llamada antes de ser definida. Por ejemplo, una Declaración de Función global es visible en todo el script, sin importar dónde se esté. Esto se debe a los algoritmos internos. Cuando JavaScript se 
    prepara para ejecutar el script, primero busca Declaraciones de Funciones globales en él y crea las funciones. Podemos pensar en esto como una “etapa de inicialización”. Y después de que se procesen todas las Declaraciones de Funciones, 
    el código se ejecuta. Entonces tiene acceso a éstas funciones.
    Si la función se declara como una declaración separada en el flujo del código principal, eso se llama “Declaración de función”.
    Las Declaraciones de Funciones se procesan antes de ejecutar el bloque de código. Son visibles en todas partes del bloque.
      
  > Expresion de una funcion: una función, creada dentro de una expresión o dentro de otra construcción sintáctica. Aquí, la función es creada en el lado derecho de la “expresión de asignación” =:
    Tambien son conocidas como "funciones anónimas" que es una función que se define sin nombre y se utiliza para ser pasada como parámetro o asignada a una variable. En el caso de asignarla a una variable, pueden llamar usando el 
    identificador de la variable declarada.

      let sum = function(a, b) {
      return a + b;
      };
    
    Una Expresión de Función es creada cuando la ejecución la alcance y es utilizable desde ahí en adelante. Una vez que el flujo de ejecución pase al lado derecho de la asignación let sum = function… – aquí vamos, la función es creada y 
    puede ser usada (asignada, llamada, etc.) de ahora en adelante. Las Declaraciones de Función son diferente.
    Si la función se crea como parte de una expresión, se llama “Expresión de función”.
    Las Expresiones de Función se crean cuando el flujo de ejecución las alcanza.
      
  > Funciones flecha Son como funciones anónimas de sintaxis simplificada. No usan la palabra function pero usa => (flecha) entre los parámetros y el bloque. Las funciones flecha permiten definir de manera compacta una función convencional. 
    Si la función tiene solamente una sentencia que devuelve un valor, el uso de funciones flecha nos permite eliminar las llaves y la palabra return. Incluso utilizando parámetros también podemos ver mucho más reducido el código.
    No tiene sus propios enlaces a this o super y no se debe usar como métodos. No tiene argumentos o palabras clave new.target. No apta para los métodos call, apply y bind, que generalmente se basan en establecer un ámbito o alcance No se 
    puede utilizar como constructor. No se puede utilizar yield dentro de su cuerpo.
    
      + const calcAge3 = birthYear => 2037 - birthYear;               //Esta funcion flecha se escribe de esta manera cuando solamente requiere de una linea de codigo. Aqui no se necesita de un retur.
      + const yearUntilRetirement1 = (birthYear, firstName) => {}     //Esta funcion se utiliza con llaves cuando se requiere de mas de 1 linea. Se requiere de un return si es que queremos regresar un valor.
      + const yearUntilRetirement1 = function(birthYear, firstName){} //Esta funcion es la misma que la de arriba pero de la forma tradicional. Se requiere de un return si es que queremos regresar un valor.    
      + toString = () => {return this.nombre +" ($"+ this.precio.toFixed(2) +")"}; //Asi se define una funcion flecha dentro de una clase
      + toString(){return this.nombre +" ($"+ this.precio.toFixed(2) +")"} //Asi se define una funcion tradicional dentro de una clase
      
      
  > Anonymus function: 
  
  > Funciones (function): Lo primero que tenemos que saber es que en Javascript, las funciones son objetos de primera clase. Como tales, podemos trabajar con ellos de la misma forma que trabajamos con otros objetos, como asignarlos a 
    variables y pasarlos como argumentos a otras funciones. Esto es importante, porque esta última técnica nos permite ampliar la funcionalidad de nuestras aplicaciones. JavaScript ejecuta el código secuencialmente en orden descendente. Sin 
    embargo, hay algunos casos en los que el código se ejecuta (o debe ejecutarse) después de que ocurra otra cosa y también de forma no secuencial. Esto se llama programación asíncrona.
         
        
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- POO en JAVASCRIPT

  > Objetos: os objetos son estructuras que podemos definir para agrupar valores bajo un mismo criterio. Podemos decir que un objeto es una colección de datos relacionados como una entidad. Se componen de un listado de pares clave-valor, es 
    decir, contienen propiedades y valores agrupados. La utilidad de los objetos deviene de su composición por varios valores y operaciones comunes (funciones) para todos los elementos de este tipo y sus propiedades". 
    + Anatomía de un objeto: Un objeto literal se define directamente entre llaves {} Los valores que almacenan se listan separados por coma, bajo la forma propiedad: valor
    + Obteniendo valores del objeto: Para obtener el valor de una propiedad en un objeto utilizamos la notación punto (.): El nombre de la variable del objeto, seguido de punto y el nombre de la propiedad.
      ~ Otra forma de obtener el valor de una propiedad en un objeto utilizamos la notación corchetes ([]): El nombre de la variable del objeto, seguido de corchetes y dentro de ellos un string del nombre de la propiedad.
    + Asignar valores a las propiedades: Es posible usar las dos formas( corchetes y paréntesis) para acceder a las propiedades y asignar nuevos valores a los datos almacenados en las propiedades del objeto
    
        
  > Formas de llamar a un objeto y diferencia entre Dot Notation y Bracket Notation Property Accessor:
        console.log(producto.nombre);
        console.log(producto['nombre']);     
        
    Cuando usamos corchetes podemos acceder a propiedades que tienen un espacio o carácter no permitido en la notación de punto (por ejemplo, miMascota.numero de amigos no es válido, pero miMascota["numero de amigos"] sí lo es). Si queremos 
    minificar nuestro código, la notación del punto no es válida, debemos usar la notación de corchetes. La notación con corchetes, a diferencia de la notación con punto, puede usarse con variables. Si usas una variable con notación con 
    corchetes, la variable debe hacer referencia a una string.
    Dot Notation only allows static keys while Bracket Notation accepts dynamic keys. Static key here means that the key is typed directly, while Dynamic key here means that the key is evaluated from an expression.
    
(1) const obj = {                                  (2) const obj = {                                    (3) const obj = {
    name: "deeecode",                                  name: "deeecode",                                    name: "deeecode",
    age: 80,                                           age: 80,                                             age: 80,
    language: "javascript",                            language: "javascript",                              language: "javascript",
    }                                                  }                                                    }
    
    const myKey = "language";                          const myKey = "language";                            const myKey = "language";
    const target = obj.myKey;                          const target = obj[myKey];                           const target = obj["myKey"];
    console.log(target);                               console.log(target);                                 console.log(target);
    //undefined                                        // javascript                                        // undefined
    
(4) const obj = {                                  (5) const obj = {                                        
    name: "deeecode",                                  name: "deeecode",                                    
    age: 80,                                           age: 80,                                             
    language: "javascript",                            language: "javascript",                              
    }                                                  }                   
                                     
    const target = obj.name;                           const target = obj["name"];                            
    console.log(target);                               console.log(target);                             
    //deecode                                          // javascript                                       
    
    
    
    1. Here, I assigned the value "language" to a myKey variable. What I would expect here is that when I use the dot notation, like obj.myKey, "myKey", should be replaced with "language". So it would read as obj.language and that would 
       return "javascript". But that's not what happens. Instead, the result is undefined. The reason for this is that Dot Notation only accepts static keys. So when you do obj.myKey, JavaScript looks for the property with the key myKey in 
       obj. But that property does not exist, so we get undefined. The Bracket Notation, on the other hand, allows dynamic keys. Because this notation accepts expressions, you can use any expression that evaluates to a value.
    2. The expression we passed to the square brackets is myKey which is a variable. This expression evaluates to "language" which is the value of the variable. Using this value, the square brackets can get the value of the property, which 
       is "javascript".
    3. This is because the string expression "myKey" evaluates to the value "myKey" which serves as the key for accessing the property. Since there's no myKey key on obj, the returned value is undefined.

  > Como crear un metodo en un objeto: En este caso se hace de la misma manera que cuando creamos una funcion global, con la diferencia de que en lugar de usar (=) usamos (:) solo cuando esta dentro del objeto
  
       calcAge: function (birthYeah){   //Metodo
           return variable;
       }
        
  > Llamar a la funcion de una clase: Para hacer esto, sabemos primero que la funcion se encuentra dentro de una clase, por lo que ahora, fuera de ella cuando queramos llamarla, tendremos que poner le nommbre de una variable, le colocamos un 
    punto y despues escribimos el nombre de la funcion. La sintaxis es la siguiente       -->       NombreDeVariable.nombreDeFuncion()

  > clases: Las clases de JavaScript, introducidas en ES6, proveen una sintaxis mucho más clara y simple para crear objetos personalizados. Son una equivalencia al empleo de función constructora y permite definir distintos tipos de métodos.
  
  > Clases y Métodos: En la declaración de clase, la función constructora es reemplazada por el método constructor. Los métodos en las clases no referencian a propiedades, se declaran dentro del bloque sin la palabra function. Los metodos se 
    declaran fuera del metodo constructor pero dentro de la clase. Estos metodos no llevan el "=" ni tampoco los "=>", a diferencia de la funcion constructora de objetos.

  > new: El operador new permite a los desarrolladores crear una instancia de un tipo de objeto definido por el usuario o de uno de los tipos de objeto integrados que tiene un función constructora.
    La palabra clave new hace lo siguiente:

      1) It creates a new object. The type of this object is simply object.
      2) It sets this new object's internal, inaccessible, [[prototype]] (i.e. __proto__) property to be the constructor function's external, accessible, prototype object (every function object automatically has a prototype property).
      3) It makes the this variable point to the newly created object.
      4) It executes the constructor function, using the newly created object whenever this is mentioned.
      5) It returns the newly created object, unless the constructor function returns a non-null object reference. In this case, that object reference is returned instead.    
      6) Para definir un tipo de objeto, crea una función para el tipo de objeto que especifique su nombre y propiedades. Un objeto puede tener una propiedad que en sí misma es otro objeto.
    
   Note: constructor function refers to the function after the new keyword, as in
        
        new ConstructorFunction(arg1, arg2)

   Once this is done, if an undefined property of the new object is requested, the script will check the object's [[prototype]] object for the property instead. This is how you can get something similar to traditional class inheritance in JS
   The most difficult part about this is point number 2. Every object (including functions) has this internal property called [[prototype]]. It can only be set at object creation time, either with new, with Object.create, or based on the 
   literal (functions default to Function.prototype, numbers to Number.prototype, etc.). It can only be read with Object.getPrototypeOf(someObject). There is no other way to get or set this value.
   Functions, in addition to the hidden [[prototype]] property, also have a property called prototype, and it is this that you can access, and modify, to provide inherited properties and methods for the objects you make. Here is an example:
   
   ObjMaker = function() { this.a = 'first'; };
   // `ObjMaker` is just a function, there's nothing special about it that makes it a constructor.
   
   ObjMaker.prototype.b = 'second';
   // like all functions, ObjMaker has an accessible `prototype` property that we can alter. I just added a property called 'b' to it. Like all objects, ObjMaker also has an inaccessible `[[prototype]]` property that we can't do anything
   
   with obj1 = new ObjMaker(); 
   //3 things just happened. A new, empty object was created called `obj1`.  At first `obj1` was just `{}`. The `[[prototype]]` property of `obj1` was then set to the currentobject value of the `ObjMaker.prototype` (if `ObjMaker.prototype` 
   is laterassigned a new object value, `obj1`'s `[[prototype]]` will not change, but youcan alter the properties of `ObjMaker.prototype` to add to both the`prototype` and `[[prototype]]`). The `ObjMaker` function was executed, with`obj1` in 
   place of `this`... so `obj1.a` was set to 'first'.
   
   obj1.a;
   // returns 'first'
   
   obj1.b; 
   //`obj1` doesn't have a property called 'b', so JavaScript checks  its `[[prototype]]`. Its `[[prototype]]` is the same as `ObjMaker.prototype` `ObjMaker.prototype` has a property called 'b' with value 'second' returns 'second'

  > this: Se refiere al elemento actual en el que se está escribiendo el código. Cuando se emplea un función constructora para crear un objeto (con la palabra clave new), this está enlazado al nuevo objeto instanciado. This es muy útil para 
    asegurar que se emplean las propiedades del objeto actual. El puntero this es una variable predefinida para todas las funciones u operadores miembro de una clase. Este puntero contiene la dirección del objeto concreto de la clase al 
    que se está aplicando la función o el operador miembro. Se puede decir que *this es un alias del objeto correspondiente. Conviene tener en cuenta que cuando una función miembro se aplica a un objeto de su clase (su argumento implícito), 
    accede directamente a las variables miembro (sin utilizar el operador punto o flecha), pero no tiene forma de referirse al objeto como tal, pues no le ha sido pasado explícitamente como argumento. Ojo, que hace referencia al objeto 
    instanciado y no a la clase.

     this en JavaScript es una palabra clave muy utilizada dentro de funciones y clases, pues tiene un valor flexible. This hace referencia al objeto en cuestión. Es decir, si estamos creando cualquier función, la palabra clave this se 
     usará para representar o llamar al objeto que dicha función está modificando. ES5 introdujo el método bind() para establecer el valor de la función this independientemente de como es llamada.
     this es una referencia que se crea cuando una función es invocada, no declarada. El valor de esa referencia depende al 100% del lugar en la que esa invocación se realice, llamado call-site. Ese lugar de llamada es la invocación en sí a 
     la función. Es decir, el momento justo en que es llamada (no declarada, no referenciada) esa función. El valor de this puede cambiar dependiendo del contexto en el que se invoca una función o método. Hay cuatro contextos principales en 
     los que se puede utilizar this en JavaScript:
       + En una función global: En una función que se ejecuta en el contexto global, this hace referencia al objeto window, que es el objeto global en JavaScript.
       + En una función dentro de un objeto: Cuando se invoca una función dentro de un objeto, this hace referencia al objeto que contiene la función.
       + El método call() o apply(): Son métodos que permiten invocar una función con un objeto diferente de this. Esto significa que se puede cambiar el contexto de this mediante la llamada a una de estas do funciones.
       + Con el operador new: Cuando se invoca una función con el operador new, this hace referencia al objeto que se está creando.
        
     In JavaScript, the this keyword refers to an object. Which object depends on how this is being invoked (used or called). The this keyword refers to different objects depending on how it is used:
        ~ In an object method, this refers to the object.
        ~ Alone, this refers to the global object.
        ~ In a function, this refers to the global object.
        ~ In a function, in strict mode, this is undefined.
        ~ In an event, this refers to the element that received the event.
        ~ Methods like call(), apply(), and bind() can refer this to any object.  
      
     En resumen, this se utiliza para hacer referencia al objeto en el contexto actual, y su valor puede cambiar dependiendo del contexto en el que se invoca una función o método. 
         https://www.freecodecamp.org/espanol/news/la-guia-completa-sobre-this-en-javascript/   https://www.programiz.com/javascript/this

  > call ();  Permite que una función/método que pertenece a un objeto, ser asignada y llamada para un objeto diferente. Provee un nuevo valor de this a la función/método. Podemos escribir un método ona vez y heredarlo a otro objeto, 
    sin tener que reescribir el método en el nuevo objeto. No recive una lista de argumentos despues del this. 
    You can write a method that can be used on different objects. It takes arguments separately. It can be used to invoke (call) a method with an owner object as an argument (parameter). With call(), an object can use a method belonging to 
    another object. 
          
  > apply (); Con apply, puede escribirse un método una vez y heredarlo a otro objeto, sin necesidad de reescribir el método para adecuarlo al nuevo objeto. apply es muy similar a call(), excepto por el tipo de argumentos que soporta. 
    Puede utilizarse un arreglo de parámetros en lugar de un conjunto de pares nombre-valor. 
    You can write a method that can be used on different objects. It takes arguments as an array.

  > bind (); El método bind() crea una nueva función, que cuando es llamada, asigna a su operador this el valor entregado, con una secuencia de argumentos dados precediendo a cualquiera entregados cuando la función es llamada. El 
    valor de this es ignorado cuando la función es llamada con el operador new. 
    Cuándo es necesario usar bind(this)?
      ~ Cuando pasas métodos como callbacks: Si necesitas pasar un método como callback a otra función o componente (por ejemplo, en React o eventos DOM), es crucial que conserve el contexto.
      ~ Cuando usas métodos fuera de su contexto original: Si desglosas un método para usarlo de forma independiente, sin que esté explícitamente llamado desde la instancia.
    
    Allows us to manually set "this" for any function call. With the bind() method, an object can borrow a method from another object. Bind doesn't immediately call the function. Instead, it returns a new function where the "this" is bound. 
    So it's set to whatever value we pass into bind. Sometimes the bind() method has to be used to prevent losing this.

  > super: The super keyword is used to call the constructor of its parent class to access the parent's properties and methods, to access properties on an object literal or class's [[Prototype]], or invoke a superclass's constructor.
    When we extend a parent class, we call "super" in order to call the parent constructor.
    The super() method refers to the parent class. By calling the super() method in the constructor method, we call the parent's constructor method and gets access to the parent's properties and methods.

  > extends: The extends keyword is used to create a child class of another class (parent). The child class inherits all the methods from another class. Inheritance is useful for code reusability: reuse properties and methods of an existing 
    class when you create a new class. 
    Extends is used to denote the parent class that the child class will inherit its methods from, and super is used to reference the parent classes constructor method. In other words, it is used to create a subclass (the new class is a 
    child) that inherits all the properties and methods from another class (or parent) or to extend a type by including properties from another type, and It can override some of these and implement new ones, but the parent stuff is included.
     ~ Inheritance: Extends is used for class inheritance. It allows a class to inherit properties and methods from another class.
     ~ Multiple Inheritance: A class can extend only one class
     ~ Implementation of Methods: No direct implementation of methods.
     ~ Code Reusability: Promotes code reusability
     ~ Abstract Classes: Can extend abstract classes

  > readonly: It is used to prevent compile-time reassignment, however, it makes no guarantee that your code is “safe” and cannot be reassigned elsewhere.
    se utiliza para declarar propiedades de solo lectura en una clase o en un tipo de objeto. Esto significa que una vez que se inicializa una propiedad con la palabra clave "readonly", su valor no puede ser modificado posteriormente fuera 
    del constructor de la clase.
      
  > Constructor: El constructor de un objeto es una función que usamos para crear un nuevo objeto cada vez que sea necesario. Con función constructora podemos inicializar las propiedades del objeto al momento de ser instanciado con new.
    El constructor es una funcion que ejecutara las funciones y/o variables que esten dentro de el tan pronto como se cree una nueva instancia del objeto.
    
    Constructor is a "special" prop returns a reference to the Object constructor function that created the instance object.
    A constructor is a special function (prop) that creates and initializes an object instance of a class. It returns a reference to the Object constructor function that created the instance object. In JavaScript, a constructor gets called 
    when an object is created using the new keyword. The purpose of a constructor is to create a new object and set values for any existing object properties.
      
        function Persona(nombre, edad, calle) {
           this.nombre = nombre;
           this.edad = edad;
           this.calle = calle;
        }
        const persona1 = new Persona("Homero", 39, "Av. Siempreviva 742 ");
        const persona2 = new Persona("Marge", 36, "Av. Siempreviva 742 ");
        
     Estos metodos constructores NO son asincronos.

  > static: La palabra static en Javascript se utiliza para definir propiedades y métodos que pertenecen a toda la clase en lugar de pertenecer a instancias individuales de esa clase. Estas propiedades y métodos son accesibles directamente
    desde la clase misma, sin necesidad de crear objetos. Es importante destacar que las propiedades estáticas no están disponibles en las instancias de la clase. Los métodos y propiedades estáticos pueden resultar muy útiles en muchas 
    situaciones. Algunos de los beneficios y casos de uso comunes son:
      ~ Acceso global: las propiedades estáticas permiten acceder a valores comunes desde cualquier parte del código, sin la necesidad de crear instancias de la clase.
      ~ Utilidades compartidas: los métodos estáticos se utilizan a menudo para implementar utilidades compartidas que no dependen del estado de una instancia en particular.
      ~ Rendimiento mejorado: al utilizar métodos estáticos en lugar de métodos de instancia, puedes reducir el uso de memoria y mejorar el rendimiento de tu aplicación.
    Sin embargo, es importante tener en cuenta que el uso excesivo de propiedades y métodos estáticos puede derivar en un código menos flexible y acoplado.
  
  > interface: 

    The static keyword defines a static method or field for a class, or a static initialization block. Static properties cannot be directly accessed on instances of the class. Instead, they're accessed on the class itself. 
    Static methods are often utility functions, such as functions to create or clone objects, whereas static properties are useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.
    Usually, static methods are used to implement functions that belong to the class as a whole, but not to any particular object of it. (You cannot call a static method on an object, only on an object class).
  
  > Metodo: Los métodos de los objetos también son técnicamente funciones, sólo que se limitan a poder ser ejecutados solo desde el mismo objeto. Se requiere un objeto y puede no retornar un valor.
        function Persona(nombre, edad, calle) {
           this.nombre = nombre; this.edad = edad; this.calle = calle;
        } 
        
  > Encaptulation: It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates. In Encapsulation, the variables or data of a class are hidden from any 
    other class and can be accessed only through any member function of their class in which they are declared. As in encapsulation, the data in a class is hidden from other classes, so it is also known as data-hiding.    
    
    This principle states that all important information is contained inside an object and only select information is exposed. The implementation and state of each object are privately held inside a defined class. Other objects do not have 
    access to this class or the authority to make changes. They are only able to call a list of public functions or methods. This characteristic of data hiding provides greater program security and avoids unintended data corruption.
    
     ~ Public: These members of the class and available to everyone that can access the (owner) class instance.
     
     ~ Private: These members are only accessible within the class that instantiated the object.
     
     ~ Protected: This keyword allows a little more access than private members but a lot less than the public. A protected member is accessible within the class (similar to private) and any object that inherits from it. A protected value is 
       shared across all layers of the prototype chain. It is not accessible by anybody else.
   
  > Array de objetos: Los array pueden usarse para almacenar objetos personalizados. Podemos asignar objetos literales o previamente instanciados en la declaración del array o agregar nuevos objetos usando el método push y el constructor.
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Global Methods and Properties
    > decodeURI()	        Decodes a URI
    > decodeURIComponent()    Decodes a URI component
    > encodeURI()	        Encodes a URI
    > encodeURIComponent()	   Encodes a URI component
    > eval()	              Evaluates a string and executes it as if it was script code
    > Infinity	              A numeric value that represents positive/negative infinity
    > isFinite()	              Determines whether a value is a finite, legal number
    > isNaN()	              Determines whether a value is an illegal number
    > NaN	                  "Not-a-Number" value
    > Number()	             Converts an object or string' value to a number
    > parseFloat()	        Parses a string and returns a floating point number
    > parseInt()	             Parses a string and returns an integer
    > String()	             Converts an object's value to a string
    > undefined	             Indicates that a variable has not been assigned a value

- JavaScript Object Reference    
    > constructor	   Returns the function that created an object's prototype
    > keys()	        Returns an Array Iterator object with the keys of an object
    > prototype	        Let you to add properties and methods to JavaScript objects
    > toString()         Converts an object to a string and returns the result
    > valueOf()	         Returns the primitive value of an object
    > values()           Object.values() returns an array whose elements are values of enumerable string-keyed properties found directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop enumerates 
                         properties in the prototype chain as well. The order of the array returned by Object.values() is the same as that provided by a for...in loop.
                         
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    

- Métodos del objeto CONSOLE

    > assert()	            Writes an error message to the console if a assertion is false
    > clear()	            Clears the console
    > count()	            Logs the number of times that this particular call to count() has been called
    > error()	            Outputs an error message to the console
    > group()	            Creates a new inline group in the console. This indents following console messages by an additional level, until console.groupEnd() is called
    > groupCollapsed()	 Creates a new inline group in the console. However, the new group is created collapsed. The user will need to use the disclosure button to expand it
    > groupEnd()	            Exits the current inline group in the console
    > info()	            Outputs an informational message to the console
    > log()	            Outputs a message to the console
    > table()	            Displays tabular data as a table
    > time()	            Starts a timer (can track how long an operation takes)
    > timeEnd()	            Stops a timer that was previously started by console.time()
    > trace()	            Outputs a stack trace to the console
    > warn()	            Outputs a warning message to the console
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    

- JavaScript Statement Identifiers

    > break	                    Exits a switch or a loop
    > class	                    Declares a class
    > const	                    Declares a variable with a constant value
    > continue	                    Breaks one iteration (in the loop) if a specified condition occurs, and continues with the next iteration in the loop
    > debugger	                    Stops the execution of JavaScript, and calls (if available) the debugging function
    > do while	              Executes a block of statements and repeats the block while a condition is true
    > for	                         Loops through a block of code a number of times
    > for in	                    Loops through the properties of an object
    > for of	                    Loops through the values of an iterable object
    > function	                    Declares a function
    > if else - else if	    Marks a block of statements to be executed depending on a condition
    > let	                          Declares a variable
    > return	                    Stops the execution of a function and returns a value from that function
    > switch	                    Marks a block of statements to be executed depending on different cases
    > throw	                    Throws (generates) an error
    > try ... catch ... finally	    Marks the block of statements to be executed when an error occurs in a try block, and implements error handling
    > var	                          Declares a variable
    > while	                    Marks a block of statements to be executed while a condition is true    
     
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    

- Math Object Methods and Properties: Javascript provee el objeto Math que funciona como un contenedor de herramientas y métodos para realizar operaciones matemáticas

    > abs(x)	      Returns the absolute value of x
    > acos(x)	      Returns the arccosine of x, in radians
    > acosh(x)	      Returns the hyperbolic arccosine of x
    > asin(x)	      Returns the arcsine of x, in radians
    > asinh(x)	      Returns the hyperbolic arcsine of x
    > atan(x)	      Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians
    > atan2(y, x)	  Returns the arctangent of the quotient of its arguments
    > atanh(x)	      Returns the hyperbolic arctangent of x
    > cbrt(x)	      Returns the cubic root of x
    > ceil(x)	      Returns x, rounded upwards to the nearest integer
    > clz32(x)	      Returns the number of leading zeros in a 32-bit binary representation of x
    > cos(x)	      Returns the cosine of x (x is in radians)
    > cosh(x)	      Returns the hyperbolic cosine of x
    > E	              Returns Euler's number (approx. 2.718)
    > exp(x)	      Returns the value of Ex
    > expm1(x)	      Returns the value of Ex minus 1
    > floor(x)	      Returns x, rounded downwards to the nearest integer
    > fround(x)	      Returns the nearest (32-bit single precision) float representation of a number
    > LN2	          Returns the natural logarithm of 2 (approx. 0.693)
    > LN10	          Returns the natural logarithm of 10 (approx. 2.302)
    > log(x)	      Returns the natural logarithmof x
    > log10(x)	      Returns the base-10 logarithm of x
    > LOG10E	      Returns the base-10 logarithm of E (approx. 0.434)
    > log1p(x)	      Returns the natural logarithm of 1 + x
    > log2(x)	      Returns the base-2 logarithm of x
    > LOG2E	          Returns the base-2 logarithm of E (approx. 1.442)
    > max(x1,x2,..)	  Returns the number with the highest value
    > min(x1,x2,..)	  Returns the number with the lowest value
    > PI	            Returns PI (approx. 3.14)
    > pow(x, y)	      Returns the value of x to the power of y
    > random()	      Returns a random number between 0 and 1. Para generar números aleatorios dentro de un rango deseado, distinto de 0-1, podemos multiplicar su resultado por el rango esperado. A la vez podemos sumar el límite inferior.
                      console.log( Math.random() * 10 )// números entre 0 y 10
                      console.log( Math.random() * 50) // números entre 0 y 50
                      console.log( Math.random() * 30 + 20 ) // números entre 20 y 50
    > round(x)	      Rounds x to the nearest integer
    > sign(x)	      Returns the sign of a number (checks whether it is positive, negative or zero)
    > sin(x)	      Returns the sine of x (x is in radians)
    > sinh(x)	      Returns the hyperbolic sine of x
    > sqrt(x)	      Returns the square root of x
    > SQRT1_2	      Returns the square root of 1/2 (approx. 0.707)
    > SQRT2	          Returns the square root of 2 (approx. 1.414)
    > tan(x)	      Returns the tangent of an angle
    > tanh(x)	      Returns the hyperbolic tangent of a number
    > trunc(x)	      Returns the integer part of a number (x)


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Number                      
  
constructor	       Returns the function that created JavaScript's Number prototype
EPSILON	            Returns the difference between 1 and the smallest number greater than 1
isFinite()	            Checks whether a value is a finite number
isInteger()	       Checks whether a value is an integer
isNaN()	            Checks whether a value is Number.NaN
isSafeInteger()	      Checks whether a value is a safe integer
MAX_SAFE_INTEGER      Returns the maximum safe integer in JavaScript.
MIN_SAFE_INTEGER      Returns the minimum safe integer in JavaScript
MAX_VALUE	           Returns the largest number possible in JavaScript
MIN_VALUE	           Returns the smallest number possible in JavaScript
NaN	                Represents a "Not-a-Number" value
NEGATIVE_INFINITY	Represents negative infinity (returned on overflow)
POSITIVE_INFINITY	Represents infinity (returned on overflow)
parseFloat()	     Parses a string an returns a number
parseInt()	          Parses a string an returns a whole number
prototype	          Allows you to add properties and methods to an object
toExponential(x)	    Converts a number into an exponential notation
toFixed(x)	          Formats a number with x numbers of digits after the decimal point
toLocaleString()	     Converts a number into a string, based on the locale settings
toPrecision(x)	    Formats a number to x length
toString()	         Converts a number to a string
valueOf()	         Returns the primitive value of a number

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

- Built-in JavaScript Constructors

new String()    // Create a new String object
new Number()    // Create a new Number object
new Boolean()   // Create a new Boolean object
new Object()    // Create a new Object object
new Array()     // Create a new Array object
new RegExp()    // Create a new RegExp object
new Function()  // Create a new Function object
new Date()      // Create a new Date object


As you can see above, JavaScript has object versions of the primitive data types String, Number, and Boolean. But there is no reason to create complex objects. Primitive values are much faster:
Use string literals "" instead of new String().
Use number literals 50 instead of new Number().
Use boolean literals true / false instead of new Boolean().
Use object literals {} instead of new Object().
Use array literals [] instead of new Array().
Use pattern literals /()/ instead of new RegExp().
Use function expressions () {} instead of new Function().
        
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        
    
- JavaScript date reference
    > constructor	             Returns the function that created the Date object's prototype
    > getDate()	               Returns the day of the month (from 1-31)
    > getDay()	               Returns the day of the week (from 0-6)
    > getFullYear()	           Returns the year
    > getHours()	             Returns the hour (from 0-23)
    > getMilliseconds()	       Returns the milliseconds (from 0-999)
    > getMinutes()	           Returns the minutes (from 0-59)
    > getMonth()	             Returns the month (from 0-11)
    > getSeconds()	           Returns the seconds (from 0-59)
    > getTime()	               Returns the number of milliseconds since midnight Jan 1 1970, and a specified date
    > getTimezoneOffset()	     Returns the time difference between UTC time and local time, in minutes
    > getUTCDate()	           Returns the day of the month, according to universal time (from 1-31)
    > getUTCDay()	             Returns the day of the week, according to universal time (from 0-6)
    > getUTCFullYear()	       Returns the year, according to universal time
    > getUTCHours()	           Returns the hour, according to universal time (from 0-23)
    > getUTCMilliseconds()	   Returns the milliseconds, according to universal time (from 0-999)
    > getUTCMinutes()	         Returns the minutes, according to universal time (from 0-59)
    > getUTCMonth()	           Returns the month, according to universal time (from 0-11)
    > getUTCSeconds()	         Returns the seconds, according to universal time (from 0-59)
    > now()	                   Returns the number of milliseconds since midnight Jan 1, 1970
    > parse()	                 Parses a date string and returns the number of milliseconds since January 1, 1970
    > prototype	               Allows you to add properties and methods to an object
    > setDate()	               Sets the day of the month of a date object
    > setFullYear()	           Sets the year of a date object
    > setHours()	             Sets the hour of a date object
    > setMilliseconds()	       Sets the milliseconds of a date object
    > setMinutes()	           Set the minutes of a date object
    > setMonth()	             Sets the month of a date object
    > setSeconds()	           Sets the seconds of a date object
    > setTime()	               Sets a date to a specified number of milliseconds after/before January 1, 1970
    > setUTCDate()	           Sets the day of the month of a date object, according to universal time
    > setUTCFullYear()	       Sets the year of a date object, according to universal time
    > setUTCHours()	           Sets the hour of a date object, according to universal time
    > setUTCMilliseconds()	   Sets the milliseconds of a date object, according to universal time
    > setUTCMinutes()	         Set the minutes of a date object, according to universal time
    > setUTCMonth()	           Sets the month of a date object, according to universal time
    > setUTCSeconds()	         Set the seconds of a date object, according to universal time
    > toDateString()	         Converts the date portion of a Date object into a readable string
    > toISOString()	           Returns the date as a string, using the ISO standard
    > toJSON()	               Returns the date as a string, formatted as a JSON date
    > toLocaleDateString()	   Returns the date portion of a Date object as a string, using locale conventions
    > toLocaleTimeString()	   Returns the time portion of a Date object as a string, using locale conventions
    > toLocaleString()	       Converts a Date object to a string, using locale conventions
    > toString()	             Converts a Date object to a string
    > toTimeString()	         Converts the time portion of a Date object to a string
    > toUTCString()	           Converts a Date object to a string, according to universal time
    > UTC()	                   Returns the number of milliseconds in a date since midnight of January 1, 1970, according to UTC time
    > valueOf()	               Returns the primitive value of a Date object
   
    
- La clase Date: Seguramente en algún momento necesitemos manipular fechas dentro de los datos que manejamos. Para esto, JavaScript posee la clase Date diseñada para representar fechas.
  ~ Date: Instanciar un objeto Date nos genera la fecha y tiempo actual
    console.log(new Date())  //Fri Dec 17 2021 11:35:08 GMT-0300 (hora estándar de Argentina
    
  ~ Constructor: El constructor de la clase Date nos permite crear objetos date confechas diferentes. Puede recibir parámetros en el orden año, mes, día, hora, minutos, segundos, milisegundos (todos tipo number).
    La convención con la que trabaja Javascript para construir fechas cuenta los meses a partir del 0 (0 = enero, 11 = diciembre) y los días a partir del 1:
    
    console.log(new Date(2020, 1, 15)) // Sat Feb 15 2020 00:00:00 GMT-0300 (hora estándar de Argentina)
    const casiNavidad = new Date(2021, 11, 25, 23, 59, 59)
    console.log(casiNavidad) // Sat Dec 25 2021 23:59:59 GMT-0300 (hora estándar de Argentina)

    El constructor de la clase Date nos permite crear objetos date con fechas diferentes. Puede recibir parámetros en el orden año, mes, día, hora, minutos, segundos, milisegundos (todos tipo number).
    
    const casiNavidad = new Date("December 25, 2021 23:59:59" )
    console.log(casiNavidad) // Sat Dec 25 2021 23:59:59 GMT-0300 (hora estándar de Argentina)
    
  ~ Obtener un valor singular de la fecha: Instanciado un objeto Date, podemos aplicar distintos métodos que nos evuelven determinados valores de la misma. 
    + getMonth(); nos retornará el number que representa el mes (entre 0 y 11)
    + getFullYear(); nos devolverá el number que representa el año creado
    + getDay(); nos retornará el number que representa el día creado (1 = lunes, 7 = domingo)
      
      const hoy = new Date("December 17, 2021")
      console.log(hoy.toDateString()) // Fri Dec 17 2021
      console.log(hoy.toLocaleString()) // 17/12/2021 00:00:00
      console.log(hoy.toLocaleDateString()) // 17/12/2021
      console.log(hoy.toTimeString()) // 00:00:00 GMT-0300 (hora estándar de Argentina)
      
  ~ Diferencias entre fechas: ;os resultados de las diferencias entre fechas se generan en milisegundos. Si quisiera calcular la diferencia de días entre dos fechas habría que generar cálculos adicionales sobre esta diferencia en 
    milisegundos. Por suerte, existen librerías que solucionan estos problemas de forma eficiente y rápida, pero las trabajaremos en clases posteriores.
    
    const navidad = new Date("December 25, 2021")
    const hoy = new Date("December 17, 2021")
    console.log( navidad - hoy ) // 691200000
    const milisegundosPorDia = 86400000
    console.log( (navidad - hoy ) / milisegundosPorDia) // 8
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
-  Sets and Map Methods

   ~ Map: Un Map es una colección de pares tipo clave-valor (como un objeto) donde la clave puede ser de cualquier tipo, siendo la principal diferencia con un objeto, además de ciertos métodos que permiten una simple manipulación proveyendo 
      una forma eficiente de buscar y obtener datos. Además un Map permite que se agreguen datos de forma dinámica. Además Map incluye algunos métodos que te permiten iterar sobre los elementos del mismo, estos métodos retornan un tipo 
      MapIterator que permite el uso de loops for-of o forEach directamente.
      
      Si bien son estructuras de datos similares hay ciertos momentos para decantar por uno u otro usa Map cuando:
        1) Necesitas almacenar información en donde las claves no son siempre strings.
        2) Necesitas una estructura de datos donde los objetos pueden ser ordenados.
        3) Necesitas realizar búsquedas eficientes en los datos (sin utilizar librerías externas).
        
   ~ Set: Es una colección de elementos unicos (no se pueden repetir los mismos valores) que pueden ser de cualquier tipo, muy similar a un arreglo. Esta también es una colección ordenada de elementos. Puedes crear e inicializar un Set 
      usando new. Al igual que Map, Set también tiene métodos que te permiten agregar o eliminar elementos del mismo. Set también cuenta con el método Set.has(element) para saber si un element está o no en un set, además del método 
      Set.delete(element) para eliminar un elemento. 
      Para iterar sobre un Set puedes usar el método Set.values() que retorna un SetIterator, sobre este iterador puedes utilizar forEach o for-of. Set y Array son similarres y puedes convertirlos entre sí utilizando el operador spread.
   
   

    > new Set()	       Creates a new Set
    > add()	           Adds a new element to the Set
    > delete()	       Removes an element from a Set
    > has()	           Returns true if a value exists
    > clear()	       Removes all elements from a Set
    > forEach()	       Invokes a callback for each element
    > values()	       Returns an Iterator with all the values in a Set
    > keys()	       Same as values()
    > entries()	       Returns an Iterator with the [value,value] pairs from a Set

    > new Map()	      Creates a new Map object
    > set()	       Sets the value for a key in a Map
    > get()	       Gets the value for a key in a Map
    > clear()	       Removes all the elements from a Map
    > delete()	       Removes a Map element specified by a key
    > has()	       Returns true if a key exists in a Map
    > forEach()	       Invokes a callback for each key/value pair in a Map
    > entries()	      Returns an iterator object with the [key, value] pairs in a Map
    > fromEntries()    method creates an object from iterable key / value pairs.
    > keys()	       Returns an iterator object with the keys in a Map
    > values()	      Returns an iterator object of the values in a Map
    
    
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
    
-  Métodos de los STRINGS

    > charAt()	            Returns the character at a specified index (position)
    > charCodeAt()	        Returns the Unicode of the character at a specified index
    > concat()	            Returns two or more joined strings
    > constructor	        Returns the string's constructor function
    > endsWith()	            Returns if a string ends with a specified value
    > fromCharCode()	      Returns Unicode values as characters
    > includes()	           Returns true or false if a string contains a specified value
    > indexOf()	            Returns the index (position) of the first occurrence of a value in a string
    > lastIndexOf()	        Returns the index (position) of the last occurrence of a value in a string
    > length	            Returns the length of a string
    > localeCompare()	       Compares two strings in the current locale
    > match()	            Searches a string for a value, or a regular expression, and returns the matches
    > padStart()            method pads a string from the start. And also pads a string with another string (multiple times) until it reaches a given length.
    > padEnd()              method pads a string at the end. And also pads a string with another string (multiple times) until it reaches a given length.
    > prototype	            Allows you to add properties and methods to an object
    > repeat()	            Returns a new string with a number of copies of a string
    > replace()	            Searches a string for a value, or a regular expression, and returns a string where the values are replaced
    > replaceAll()	       Searches a string for a pattern and returns a new string where all matches are replaced
    > search()	            Searches a string for a value, or regular expression, and returns the index (position) of the match
    > slice()	            Extracts a part of a string and returns a new string
    > split()	            Splits a string into an array of substrings. Returns the new array, does not change the original string. If (" ") is used as separator, the string is split between words.
    > startsWith()	        Checks whether a string begins with specified characters
    > substr()	            Extracts a number of characters from a string, from a start index (position)
    > substring()	        Extracts characters from a string, between two specified indices (positions)
    > toLocaleLowerCase()	  Returns a string converted to lowercase letters, using the host's locale
    > toLocaleUpperCase()	 Returns a string converted to uppercase letters, using the host's locale
    > toLowerCase()	        Returns a string converted to lowercase letters
    > toString()	             Returns a string or a string object as a string
    > toUpperCase()	        Returns a string converted to uppercase letters
    > trim()	            Returns a string with removed whitespaces
    > trimEnd()	            Returns a string with removed whitespaces from the end
    > trimStart()	        Returns a string with removed whitespaces from the start
    > valueOf()	            Returns the primitive value of a string or a string object
    
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        
       

- Métodos y propiedades de las ARRAYS

    > at()        	Returns an indexed element of an array

    > concat()	      Joins arrays and returns an array with the joined arrays. Mediante el método concat podemos combinar dos Arrays en un único Array resultante. se usa para unir dos o más arrays. Este método no cambia los arrays 
                      existentes, sino que devuelve un nuevo array. Tambien se puede usar para unir ya sea un numero y un array, por ejemplo: 1 y [2] daria como resultado [1,2].
   
    > constructor     Returns the function that created the Array object's prototype
   
    > copyWithin()    Copies array elements within the array, to and from specified positions
   
    > entries()	      Returns a key/value pair Array Iteration Object
   
    >* every()	      Checks if every element in an array pass a test
   
    > fill()	      Fill the elements in an array with a static value   array.fill(value, start, end)
    
    > flat()	      Concatenates sub-array elements
    
    > flatMap()	      Maps all array elements and creates a new flat array
    
    >* filter()	      Creates a new array with every element in an array that pass a test. Consiste en filtrar uno o más elementos (un subconjunto) de una colección más grande de elementos (un superconjunto) basándose en alguna 
                      condición/preferencia. Recibe, al igual que find(), una función comparadora por parámetro, y retorna un nuevo array con todos los elementos que cumplan esa condición, o bien, que sean true. Si no hay coincidencias, 
                      retornará un array vacío. Toma una función callback y llama a esa función para cada elemento sobre el que itera dentro del arreglo de destino. La función callback de llamada puede tomar los siguientes parámetros:
                      1- valorActual: Es el elemento del arreglo sobre el que se está iterando actualmente. 
                      2- indice: Es la posición del índice del valorActual dentro del arreglo. 
                      3- arreglo: Representa el arreglo de destino(final) junto con todos sus elementos. Este método crea un nuevo arreglo y devuelve todos los elementos que pasan la condición especificada en la llamada en el callback.
                      
    >* find()	      Returns the value of the first element in an array that pass a test. Recibe una función de comparación por parámetro. Captura el elemento que se está recorriendo y retorna true o false según la comparación ejecutada, o 
                      bien el objeto donde se encuentra lo que estamos buscando. El método retorna el primer elemento que cumpla con esa condición enviada, de ahí que podemos almacenarlo en una variable o usarlo de referencia para otro 
                      proceso. Si no hay ninguna coincidencia en el array, el método find retorna undefined.
                      Toma una función de callback y llama a esa función para cada elemento que recorre dentro del arreglo al que está vinculado. Cuando encuentra una coincidencia (en otras palabras, la función callback devuelve true), el 
                      método devuelve ese elemento particular del arreglo e inmediatamente rompe el bucle. Así que el método find() devuelve el primer elemento dentro de un arreglo que satisface la función callback. 
                      La función callback puede tomar los siguientes parámetros: 1- currentItem: Es el elemento del arreglo sobre el que se está iterando actualmente. 2- index: Esta es la posición de índice de currentItem dentro del arreglo. 
                      3- array: Representa el arreglo de destino junto con todos sus elementos.

    >* findIndex()    Returns the index of the first element in an array that pass a test. It executes a function for each array element. It returns the index (position) of the first element that passes a test. It returns -1 if no match is 
                      found. It does not execute the function for empty array elements. It does not change the original array.
    
    >* forEach()	      Calls a function for each array element. Itera sobre el array y por cada elemento ejecuta la función que enviemos por parámetro, la cual recibe a su vez el elemento del array que se está recorriendo. 
                      Es muy similar al for of, pero con la diferencia de que aqui no podemos salir de la iteracion, mientras qu con for of si.
                      Este a diferencia del map, sirve para ejecutar instrucciones en una iteracion, mientras que el map devuelve un array en cada vuelta.
    
    > for in          Loops through the properties of an object Permite acceder a todas las propiedades del objeto, obteniendo una propiedad por cada iteración. (Solo sirve para iterar objetos). Iterates over all enumerable string properties 
                      of an object (ignoring properties keyed by symbols), including inherited enumerable properties.
    
    > for of          Loops through the values of an iterable object. Permite recorrer un array ejecutando un bloque de código por cada elemento del objeto. (Solo sirve para iterar arrays). It executes a loop that operates on a sequence of 
                      values sourced from an iterable object. Iterable objects include instances of built-ins such as Array, String, TypedArray, Map, Set, NodeList (and other DOM collections), the arguments object, generators produced by 
                      generator functions, and user-defined iterables. 
    
    
    > from()	      Creates an array from an object from any object with a length property, or from any iterable object.
    
    > includes()	      Check if an array contains the specified element. Permite saber si un elemento que recibo por parámetro existe o no dentro de un array, retornando un valor booleano en caso afirmativo o negativo.
   
    > indexOf()	      Search the array for an element and returns its position. El método indexOf() nos permite obtener el índice de un elemento en un array. Recibe por parámetro el elemento que queremos buscar en el array y, en caso de 
                      existir, nos retorna su índice. Si el elemento no existe nos retornará como valor: -1
   
    > isArray()	      Checks whether an object is an array
   
    > join()	      Joins all elements of an array into a string. Sirve para generar un string con todos los elementos del array, separados por el valor que pasamos por parámetro
   
    > keys()	      Returns a Array Iteration Object, containing the keys of the original array
   
    > lastIndexOf()   Search the array for an element, starting at the end, and returns its position
    
    > length	      Sets or returns the number of elements in an array. Al igual que en un String, la propiedad length nos sirve para obtener el largo de un Array, es decir, para identificar cuántos elementos tiene. Es común utilizarlo 
                      para definir el límite de una iteración sobre un array, ya que la propiedad length me permite saber explícitamente la longitud del mismo.
    
    >* map()	      Creates a new array with the result of calling a function for each array element. El método map() crea un nuevo array con todos los elementos del original transformados según las operaciones de la función enviada por 
                      parámetro. Tiene la misma cantidad de elementos pero los almacenados son el return de la función. En el ejemplo, la función retorna la propiedad nombre de cada elemento y eso es lo que se almacena en el nuevo array 
                      nombres. Map() se utiliza mucho para transformación de arrays. Este a diferencia del for each, es que devuelve un array en cada vuelta, mientras que el foreach solo sirve para ejecutar instrucciones.
                      En REACT, debemos incluir en cada elemento la propiedad key, que marque la identidad del elemento. Esto ayudará a react a optimizar el rendering ante cambios en el array. De no tenerla podemos auto-generarla con el 
                      index provisto por el segundo parámetro de map, pero sólo optimizará si hay adiciones al final del array.
    
    > pop()	      Removes the last element of an array, and returns that element. Si queremos eliminar el último elemento, el método pop().
   
    > prototype	      Allows you to add properties and methods to an Array object
    
    > push()	      Adds new elements to the end of an array, and returns the new length. Para sumar un elemento a un Array ya existente, se utiliza el método push, pasando como parámetro el valor (o variable) a agregar.
   
    >* reduce()	      Reduce the values of an array to a single value (going left-to-right). Permite obtener un único valor tras iterar sobre el array. Funciona como un método que resume el array a un único valor de retorno. Este recibe dos 
                      parámetros: 
                      1.El primero es la función que ordena qué queremos resumir del array. Recibe un parámetro que funciona como acumulador, y el elemento del array que iteramos. 
                      2.El segundo es el valor inicial del acumulador.
                      3. El tercer parametro pertenece a la inicializacion. Puede ser opcional su uso y debe ir despues del afuncion
    
   
    > reduceRight()   Reduce the values of an array to a single value (going right-to-left)

    > reverse()       Reverses the order of the elements in an array. Invierte el orden de los elementos dentro de un array. (es destructivo, o sea que modifica el array original, al igual que los métodos para agregar o quitar elementos)
    
    > shift()	      Removes the first element of an array, and returns that element. Si queremos eliminar el primer elemento del array utilizamos el método shift();
    
    > slice()	      Devuelve una copia de una parte del Array dentro de un nuevo Array (no se modifica el original), empezando por el inicio hasta fin (fin no incluído). 
                      Si usamos slice(1), decimos que el array se crea a partir de esa posicion, y si usamos slice(1, 4), el 4 indica el limite, que va de derecha a izquierda, contrario al primer parametro que va de izquierda a derecha.
                      Si elegimos un valor negativo, por ejemplo (1, -2), se lee como "Empiza en la posicion 1 y los ultimos dos valores no los considera". O bien, si tenemos (-2), quiere decir que tomamos los ultimos dos valores del array.
                      Si elegimos dos valores negativos, por ejemplo (-4, -1), se lee como "Empieza en la posicion 4 de derecha a izquierda, y el ultimo valore no se considera (tambien de derecha a izquierda)".
                      
    >* some()	      Checks if any of the elements in an array pass a test. Es igual que el find() recibiendo una función de búsqueda. En vez de retornar el elemento encontrado, retorna true o false según el resultado de la iteración. 
                      Analiza cada elemento de un array a partir de la función que le pasemos. Como su nombre indica, este método nos devolverá el resultado true cuando alguno de los elementos del array cumpla la condición insertada. De 
                      manera lógica, este método nos devolverá el resultado false solo si ninguno de los elementos del array cumple con la condición. Para usar el método some, insertamos el mismo comando de cualquier método array.método. 
                      Luego, entre sus paréntesis, insertamos la función que queremos usar como condición a analizar. Para usar una función como parámetro, podemos insertar su operación directamente o llamarla por su nombre.
    
    >* sort()	      Sorts the elements of an array. Permite reordenar un array según un criterio que definamos. Recibe una función de comparación por parámetro que, a la vez, recibe dos elementos del array. La función 
                      retorna un valor numérico (-1, 1, 0) que indica qué elemento se posiciona antes, después o se mantieneigual. Este método es destructivo, es decir, modifica el array sobre el cual se llama. Para ordenar números, basta 
                      con restar uno al otro, y el orden indica si será ordenado de forma ascendente o descendente. Para ordenar un array por algún string, debemos definir una función comparadora que retorne un valor numérico de referencia, 
                      según queramos el orden ascendente o descendente. No se necesita crear una variable cuando utilicemos este metodo, puesto que el array original mismo es el que se modifica.
    
    > splice()	      Adds/Removes elements from an array. Permite eliminar uno o varios elementos de un array en cualquier posición. Este modifica el array original pero con o sin los elementos establecidos. 
                      Funciona con 2 parámetros: el primero es el índice donde se ubica el método para trabajar, y el segundo es  la cantidad de elementos a eliminar desde esa posición.
                      Si creamos una varaible y la igualamos a un arreglo que utiliza splice(), entonces obtendremos NO el array, sino los elementos eliminados o agregados.
                      splice returns an array. When you push an array into an array, you get an array of arrays. By adding the [0], you push the first element of the array instead    -->  array.splice(0, 1)[0];
                      
    > split()	      Splits a string into an array of substrings. Returns the new array, does not change the original string. If (" ") is used as separator, the string is split between words.
                      
    > toString()	      Converts an array to a string, and returns the result
    > typeof:         You can use the typeof operator to find the data type of a JavaScript variable. The typeof operator can return one of two complex types: function and object.
                      The typeof operator returns "object" for objects, arrays, and null. The typeof operator does not return "object" for functions.
    > unshift()	      Adds new elements to the beginning of an array, and returns the new length. Agrega elementos al inicio del array.
    > valueOf()	      Returns the primitive value of an array
    
    > for in vs for of        En el caso de for in, este devuelve un numero (indice) y se usa generalmente en objetos, y el for of conseguimos el valor que hay en esa posicion.
    
    > arrays vs objetos       Los objetos no son iterables mientras que las arrays sí lo son. Los objetos tienen keys de cualquier valor, los arrays tienen keys numéricos y por estricto orden
    
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
   
                                                                                                           JSON & storage
                                                                                                           
     
   > localstorage.Setitem(); Los datos almacenados en localStorage (variable global preexistente) se almacenan en el navegador de forma indefinida (o hasta que se borren los datos de navegación del browser). La información persiste reinicio 
     de navegador y hasta del sistema operativo.
   > Clave-valor: La información almacenada en el Storage se guarda en la forma de clave-valor. Similar al tratamiento de objetos, definimos claves en el storage donde almacenamos valores.
   > localstorage.getItem(); Podemos acceder a la información almacenada en localStorage utilizando getItem. Las claves y valores de Storage se guardan en formato de cadena de caracteres (DOMString).
   > localstorage.setItem(); La información almacenada en sessionStorage (variable global preexistente) se almacena en el navegador hasta que el usuario cierra la ventana. Solo existe dentro de la pestaña actual del navegador. Otra pestaña 
     con la misma página tendrá otro sessionStorage distinto, pero se comparte entre iframes en la pestaña (asumiendo que tengan el mismo origen).
   > sessionStorage.getItem(); Podemos acceder a la información almacenada en sessionStorage utilizando getItem. Las claves y valores de Storage se guardan siempre en formato de cadena de caracteres
   > Recorriendo el storage: Es posible obtener todos los valores almacenados en localStorage o sessionStorage con un bucle. Pero no podemos usar for of porque no son objetos iterables, ni for in porque obtenemos otras propiedades del 
     objeto que no son valores almacenados.
   > Eliminar datos del storage: Podemos eliminar la información almacenada en sessionStorage o localStorage usando el método removeItem o clear. 
     ~ localStorage.removeItem(); 
     ~ sessionStorage.removeItem();
     ~ localStorage.clear(); //elimina toda la información
     ~ sessionStorage.clear(); //elimina toda la información
     
   > Almacenar objetos en storage Si queremos almacenar la información de un objeto en un storage, hay que tener en cuenta que tanto la clave como el valor se almacenan en strings. Ante cualquier otro tipo a guardar, como un número o un 
     objeto, se convierte a cadena de texto automáticamente. Entonces, al buscar almacenar un objeto sin una transformación previa, guardamos [object Object], la conversión por defecto de objeto a string. Para guardar la información 
     correctamente hay que transformar el objeto a JSON.
   > Acceso tipo objeto Dado que localStorage y sessionStorage son objetos globales, es posible crear y acceder a las claves como si fueran propiedades. Pero esto no es recomendable, porque hay eventos asociados a la modificación del storage 
     cuando se emplea getItem o setItem.
         
   > Conversiones de/hacia JSON: Cuando sea necesario enviar un objeto Javascript al servidor o almacenarlo en storage, será necesario convertirlo a un JSON (una cadena) antes de ser enviado.
     Cuando sea necesario enviar un objeto Javascript al servidor o almacenarlo en storage, será necesario convertirlo a un JSON (una cadena) antes de ser enviado. Para eso usamos los siguientes métodos:
     
     ~ JSON.stringify(); acepta un objeto como parámetro, y devuelve la forma de texto JSON equivalente. Podemos transformar un objeto JavaScript a un string en formato JSON. 
       Los parametros que existen en esta funcion son:            JSON.stringify(value, replacer, space);
       + value: The value to convert to a JSON string
       + replacer: function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that 
         are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g. null or not provided), all string-keyed properties 
         of the object are included in the resulting JSON string.
       + space: A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes. If this is a number, it indicates the number of space characters 
         to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
         If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array. If space is anything other than a string or number (can be either a primitive or a 
         wrapper object) — for example, is null or not provided — no white space is used.
         
       This static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.

     ~ JSON.parse(); recibe un texto JSON como parámetro, y devuelve el objeto JavaScript correspondiente. Podemos transformar string en formato JSON a objeto JavaScript. 
       Los parametros que existen en esta funcion son:            JSON.parse(text, reviver);    
        + text: The string to parse as JSON. See the JSON object for a description of JSON syntax.
        + reviver: If a function, this prescribes how each value originally produced by parsing is transformed before being returned. Non-callable values are ignored. The function is called with the following arguments: key and value.
       
       This static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.

   
   > Recuperar datos: Muchas veces usamos el Storage para recuperar datos relacionados a la última navegación del usuario. Por ejemplo, su última sesión de login o el último estado de su carrito de compras. Para esto, pensamos en inicializar 
     las variables de la app consultando el Storage en el momento de inicio.
     
- Storage API: The Storage object of the Web Storage API provides access to the session storage or local storage for a particular domain. This allows you to read, add, modify, and delete stored data items.
   > localStorage:   The localStorage object stores the data with no expiration date. The data will not be deleted when the browser is closed, and will be available the next day, week, or year.
   > sessionStorage: The sessionStorage object is equal to the localStorage object, except that it stores the data for only one session. The data is deleted when the user closes the specific browser tab.
   > getItem()	     Returns the value of the specified key name. Podemos acceder a la información almacenada en localStorage utilizando getItem. Las claves y valores de Storage se guardan en formato de cadena de caracteres (DOMString).
   > setItem()	     Adds a key to the storage, or updates a key's value if it already exists. Los datos almacenados en localStorage (variable global preexistente) se almacenan en el navegador de forma indefinida (o hasta que se borren 
                     los datos de navegación del browser). La información persiste reinicio de navegador y hasta del sistema operativo. Solo existe dentro de la pestaña actual del navegador. Otra pestaña con la misma página tendrá otro 
                     sessionStorage distinto, pero se comparte entre iframes en la pestaña (asumiendo que tengan el mismo origen)
   > clear()	     Empty all key out of the storage
   > key(            Returns the name of the nth key in the storage. Es posible obtener todos los valores almacenados en localStorage o sessionStorage con un bucle for convencional unicamente y colocando localStorage.key(i);
   > length	     Returns the number of data items stored in the Storage object
   > removeItem()    Removes a key from the storage    
    
- JSON: It is a format for storing and transporting data. JSON is text, and text can be transported anywhere, and read by any programming language.   
   > JSON.parse();          Parses a JSON string and returns a JavaScript object. Recibe un texto JSON como parámetro, y devuelve el objeto JavaScript correspondiente. Podemos transformar string en formato JSON a objeto JavaScript.
   > JSON.stringify();      Convert a JavaScript object to a JSON string. acepta un objeto como parámetro, y devuelve la forma de texto JSON equivalente. Podemos transformar un objeto JavaScript a un string en formato JSON.     
     
     
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


- Propiedades del objeto WINDOW

    > closed	        Returns a boolean true if a window is closed.
    > console	        Returns the Console Object for the window.
    > document	        Returns the Document object for the window.
    > frameElement	   Returns the frame in which the window runs.
    > frames	        Returns all window objects running in the window.
    > history	        Returns the History object for the window.
    > innerHeight	    Returns the height of the window's content area (viewport) including scrollbars
    > innerWidth	         Returns the width of a window's content area (viewport) including scrollbars
    > length	        Returns the number of <iframe> elements in the current window
    > localStorage	   Allows to save key/value pairs in a web browser. Stores the data with no expiration date
    > location	        Returns the Location object for the window.
    > name	             Sets or returns the name of a window
    > navigator	        Returns the Navigator object for the window.
    > opener	        Returns a reference to the window that created the window
    > outerHeight	    Returns the height of the browser window, including toolbars/scrollbars
    > outerWidth	         Returns the width of the browser window, including toolbars/scrollbars
    > pageXOffset	    Returns the pixels the current document has been scrolled (horizontally) from the upper left corner of the window
    > pageYOffset	    Returns the pixels the current document has been scrolled (vertically) from the upper left corner of the window
    > parent	        Returns the parent window of the current window
    > screen	        Returns the Screen object for the window
    > screenLeft	        Returns the horizontal coordinate of the window relative to the screen
    > screenTop	        Returns the vertical coordinate of the window relative to the screen
    > screenX	        Returns the horizontal coordinate of the window relative to the screen
    > screenY	        Returns the vertical coordinate of the window relative to the screen
    > sessionStorage	   Allows to save key/value pairs in a web browser. Stores the data for one session
    > scrollX	        An alias of pageXOffset
    > scrollY	        An alias of pageYOffset
    > self	              Returns the current window
    > top	             Returns the topmost browser window

- Métodos del objeto WINDOW

    > addEventListener()         Attaches an event handler to the window
    > alert()	                 Displays an alert box with a message and an OK button
    > atob()	                 Decodes a base-64 encoded string
    > blur()	                 Removes focus from the current window
    > btoa()	                 Encodes a string in base-64
    > clearInterval()            Clears a timer set with setInterval()
    > clearTimeout()             Clears a timer set with setTimeout()
    > close()	                 Closes the current window
    > confirm()	                 Displays a dialog box with a message and an OK and a Cancel button
    > focus()	                 Sets focus to the current window
    > getComputedStyle()	      Gets the current computed CSS styles applied to an element
    > getSelection()             Returns a Selection object representing the range of text selected by the user
    > matchMedia()               Returns a MediaQueryList object representing the specified CSS media query string
    > moveBy()	                 Moves a window relative to its current position
    > moveTo()	                 Moves a window to the specified position
    > open()	                 Opens a new browser window
    > print()	                 Prints the content of the current window
    > prompt()	                 Displays a dialog box that prompts the visitor for input
    > removeEventListener()	 Removes an event handler from the window
    > requestAnimationFrame()	 Requests the browser to call a function to update an animation before the next repaint
    > resizeBy()	                 Resizes the window by the specified pixels
    > resizeTo()	                 Resizes the window to the specified width and height
    > scrollBy()	                 Scrolls the document by the specified number of pixels
    > scrollTo()	                 Scrolls the document to the specified coordinates
    > stop()	                 Stops the window from loading
     
 

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
   
                                                                                                    Operadores logicos avanzados

Operador ternario ?:  	               a ? b : c	                Si a es true, devuelve b, sino devuelve c.
Operador unario lógico NOT	               !a	   
Operador de asignación lógica nula ??=    a ??= b	                Es equivalente a   a ?? (a = b)

Operador lógico AND                       a && b	                     Devuelve a si es false, sino devuelve b.
Operador lógico OR                        a || b	                     Devuelve a si es true, sino devuelve b.
Operador lógico Nullish coalescing        a ?? b	                     Devuelve b si a es null o undefined, sino devuelve a.  funciona igual que el Operador OR ( || ), con la diferencia que admite más valores como ‘verdaderos’.
Operador de encadenamiento opcional ?.    data?.name                 Permite intentar acceder a una propiedad, aunque su padre no exista. Si intentamos acceder a un objeto que no existe naturalmente obtendremos un error en consola. Pero, si 
                                                                     usamos el operador ?. sobre la referencia de un objeto para condicionar su acceso podemos tener un mejor control de errores en la ejecución. En este caso, en caso de que 
                                                                     algo no exista, en lugar de tirar un error en consola, obtendremos un undefinded
                                                                     
  > Desestructuración Es decir, los nombres de las variables deben coincidir exactamente con los nombres de las propiedades que queremos obtener del objeto. En el ejemplo anterior, podemos desestructurar el objeto de la siguiente forma:
  
    const usuario = {nombre: "John Doe", edad: 32}
    const { nombre, edad } = usuario
    console.log(nombre) // "John Doe"
    console.log(edad) // 32
    
    Si intentamos desestructurar una propiedad inexistente en el objeto, obtendremos undefined. Cada propiedad que queramos desestructurar del objeto las declaramos separadas por comas. Recordemos que en este caso y en los anteriores, 
    estamos declarando variables con los nombres nombre, edad, y teléfono; por lo que luego las referenciamos con este nombre.
    Si queremos acceder a propiedades más internas dentro de un objeto, es decir desestructurar alguna propiedad que sea a la vez un objeto, es posible hacerlo siguiendo el mismo patrón. 
    En este caso, como teléfono es un objeto, desestructuramos la propiedad trabajo de éste, dentro de la desestructuración de usuario. Nótese que finalmente se terminan declarando dos variables, nombre y trabajo. 
    Recordar que siempre se deben utilizar las mismas variables cuando desestructuramos un objeto, pero en un array SI se pueden cambiar.
    
    const usuario = { nombre: "John Doe", edad: 32, telefono: {cel: 113334444, casa: null, trabajo: 113325555} }
    const { nombre, telefono: {trabajo} } = usuario; 
    console.log(nombre); // "John Doe"
    console.log(trabajo); // 113325555
    
  > Alias: Para que la desestructuración funcione debe haber coincidencia con los nombres de las propiedades del objeto.
    Sin embargo a veces puede que los nombres de las propiedades no sean muy descriptivos para el uso que queremos darle, y por ello podemos desestructurarlas con un alias, es decir declarar la variable con un nombre alternativo tras haber 
    desestructurado el objeto. Esto lo hacemos simplemente con el operador : luego del nombre de la propiedad. En este caso desestructuramos todas las propiedades de item, pero lo almacenamos en variables denominadas id, nombre, precio, a 
    través del alias que indicamos para cada una.
    
    const item = {item_id: 432, product_name: "Some product", price_per_unit: 5600}
    const {item_id: id, product_name: nombre, price_per_unit: precio} = item
    console.log(id) // 432
    console.log(nombre) // "Some product"
    console.log(precio) // 5600
    
  > Desestructuración en parámetros: Si en una función recibimos objetos por parámetros, también es posible desestructurarlos directamente en el llamado, definiendo esto al declarar la función. Por ejemplo, supongamos una función que recibe 
    un objeto producto por parámetro y debe trabajar con sus propiedades id y nombre
    
  > Desestructuración de arrays: Es posible desestructurar arrays de forma similar, usando corchetes [] en vez de llaves. La diferencia con la desestructuración de objetos es que la de arrays es posicional. Es decir, declaramos las 
    variables en orden y estas almacenan los valores de las mismas posiciones del array de referencia:   
    No funciona aquí la coincidencia por nombres, sino que se toman los valores según la posición. Las dos primeras variables que declaramos tomarán los valores de los dos primeros elementos del array. Si queremos acceder a otras 
    posiciones, o mejor dicho omitir las primeras, podemos hacerlo dejando espacios vacíos con comas:
    
  > Operador Spread: Spread (...) es una herramienta que nos permite, como su nombre indica, desparramar un array u objeto. En otras palabras, cambiar la forma en la que presentamos este array u objeto. Esta se puede utilizar para crear 
    copias de un objeto o array sin necesidad de alterar o modificar los valores principales de esos elementos. Se le conoce como copia por valor. 
     
  > Spread de arrays: Lo que hace el spread (...) al aplicarse sobre un array, es enviar todos sus elementos como parámetros individuales. Esto es útil cuando tenemos datos ordenados dentro de una colección pero trabajamos con funciones 
    que no funcionan recibiendo arrays sino una serie de parámetros individuales, como pueden ser Math.max() o Math.min(). Con spread podemos solucionar esto ya que Math.max() recibirá cada elemento del array como un parámetro individual:
    También podemos hacer spread de un array dentro de otras estructuras que lo admitan. Esto nos permite, por ejemplo, replicar el contenido de un array dentro de otra estructura al desparramar su contenido dentro. 
    Si lo hacemos dentro de un objeto veremos algo interesante, que cada propiedad toma como nombre el índice de los elementos.
         
  > Spread de objetos:  Se puede hacer spread de objetos también, pero debe hacerse dentro de una estructura que lo permita, como otro objeto.
    Un spread aplicado sobre un objeto presentaría cada par de clave-valor separado por comas, y ésto en una función no sería admisible, pero sí puede serlo dentro de otro objeto.
    Esto suele ser útil cuando queremos replicar o modificar estructuras de objetos, ya que nos permite primero listar todas sus propiedades y valores y luego modificar/agregar las que queramos.
       
  > Rest parameters El operador spread también puede utilizarse dentro de la declaración de una función para indicar que queremos recibir una cantidad indeterminada de parámetros. Supongamos que quiero tener una función para sumar 
    cualquier cantidad de números ue reciba por parámetro. Puedo hacer esto con el operador spread definiendo rest parameters, lo que significa que mi función va a recibir una cantidad indeterminada de parámetros, pero los va a agrupar 
    dentro de un array con el nombre que defina, y con eso trabajará dentro.
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Asincronia
                                                                                                                   
    > setInterval()              Calls a function or evaluates an expression at specified intervals (in milliseconds).
                                 setInterval funciona como setTimeout, la diferencia radica en que éste reiniciará el conteo y ejecutará la tarea nuevamente cada vez que se cumpla dicho intervalo de tiempo. Un timer devuelve un apagador el 
                                 cual permite detener el intervalo cuando se cumpla cierta operación. Suele utilizarse mucho para poner tiempos límites en alguna página para llenar formularios (Hay ciertas páginas que te dan tiempo límite 
                                 para hacer la operación, O TE BOTAN).
    > setTimeout()               Calls a function or evaluates an expression after a specified number of milliseconds. 
                                 setTimeout se utiliza para establecer un temporizador que ejecute una tarea después de un determinado tiempo. permite entender en un par de líneas la idea del asincronismo. A diferencia de una operación 
                                 síncrona, podremos notar como setTimeout inicia su ejecución, y una vez que haya transcurrido el tiempo, veremos el resultado, aun cuando el resto de las operaciones hayan terminado. 
                                                                                                                  
                                                                                                                   
  
  > setTimeout: Es una función que permite realizar acciones asincrónicamente. La función recibe dos parámetros: Una función de callback y un valor numérico que representa milisegundos. Así, la función que pasamos por primer parámetro se 
    ejecuta luego de que transcurra el tiempo definido en el segundo parámetro. Por ejemplo:
    
    setTimeout(()=> {
       console.log("Proceso asincrónico" )
    }, 3000);
    
  > CALL STACK (PILA): Es una lista donde se apilan las distintas tareas a ejecutar por nuestro programa. Javascript es un lenguaje single threaded, o de un único hilo, lo que significa que tiene un único stack o pila de ejecución. De ahí 
    que la ejecución es implícitamente sincrónica. Cuando se está a punto de ejecutar una función, ésta es añadida al stack. Si la función llama a la vez, a otra función, ésta es agregada sobre la anterior. Es igual a llamar a una funcion 
    dentro de otra funcion, ya que esta primera funcion queda pendiente su ejecucion y al termina de emplearse la segunda funcion, entonces esta desaparece y continua terminandose la primera funcion.
  
  > Callbacks: Una función callback es una función de primer nivel que se pasa a otra función como variable y ésta es ejecutada en algún punto de la ejecución de la función que la recibe.
    
  > EVENT LOOP: Muchas funciones asincrónicas se ejecutan en un stack diferente. El Event Loop es la herramienta que permite la sincronización entre nuestro call stack con estas tareas asincrónicas que funcionan en un thread aparte. Si el 
    stack está vacío, el Event Loop envía la primera función que esté en la callback queue al call stack y comienza a ejecutarse.
    
  > setInterval: Tiene la misma sintaxis que setTimeout, pero la unidad de tiempo es un intervalo para la repetición de la función asociada: Permite ejecutar funciones de manera reiterativa tras los milisegundos indicados hasta que 
    indiquemos su detención o se cierre la aplicación
    
    setInterval(() => {
       console.log("Tic")
    }, 1000)
   
  > ClearInterval & clearTimeout: En caso de querer remover un Intervalo, utilizamos la función clearInterval ().También podemos detener la ejecución de un setTimeout invocando clearTimeout ().
    Cuando llamamos un setInterval() éste retorna una referencia al intervalo generado, el cual podemos almacenar en una variable. Es esta referencia la que debemos pasar a la función clearInterval para que la limpieza tenga efecto.
    Funciona igual con los timeout. Si guardamos en una variable la referencia al timeout generado, podemos usarla para removerlo luego. En el siguiente caso, el timeout generado nunca llega a ejecutarse
    
  > Promesas (promise): Es un objeto de Javascript que representa un evento a futuro y permite representar y seguir el ciclo de vida de una tarea/operación (función). Es una acción asincrónica que se puede completar en algún momento y 
    producir un valor, y notificar cuando esto suceda. Una promesa cuenta con tres estados posibles: pending, fulfilled y rejected. Las promesas pueden ser resueltas o rechazadas.
    Podemos crear promesas a través de su constructor new Promise. Su sintaxis es algo compleja, ya que recibe una función por parámetro que a su vez recibe por parámetro las funciones de resolve y reject
    
    new Promise( (resolve, reject) => {
       //cuerpo de la promesa
    })
    
    En contra de lo que se suele pensar, la sincronicidad o asincronicidad de una promise depende de qué tarea le demos. Por defecto y diseño, lo único que ocurre de manera asincrónica es la entrega del resultado.
    Las funciones callback nunca serán llamadas previo a la terminación de la ejecución actual del bucle de eventos en JavaScript.
    Las funciones callback añadidas con .then serán llamadas después del éxito o fracaso de la operación

  
  > Resolve & Reject: En principio, una promesa se retorna con estado pending, entendiendo que el valor a generar aún no fue resuelto: 
  Esta función retorna una promesa que no se resuelve. Por lo tanto, veremos que el valor que genera es un objeto Promise con estado pendiente.

  const eventoFuturo = () => {
     return new Promise( (resolve, reject) => {
        //cuerpo de la promesa
     })
  }
  console.log( eventoFuturo() ) // Promise { <pending> }
   
  El valor de retorno de la promesa se define a través del llamado a las funciones de resolve o reject:
    ✓ Si el cuerpo de la promesa llama a resolve(), la promesa cambiará su estado a fulfilled, con el valor enviado a resolve().
    ✓ Si la promesa llama a reject(), cambiará su estado a rejected con el valor enviado al reject(). Aqui decidimos que la promesa retornara un valor que se interpreta como error y se muestra en la consola en rojo y con una x.  
       
  > Then & Catch: Al llamado de una función que retorne una promesa, podemos concatenar el método .then() o .catch(), los cuales reciben una función por parámetro con la cual se captura el valor de la promesa:
    ✓ .then():    Si la promesa es resuelta, su valor de retorno se captura dentro del .then(), recibiendo por parámetro de su función ese valor. Siempre que coloquemos un return dentro de un .then, automáticamente el resultado se convierte 
                  en otra promesa y puede ser encadenada con otro .then, y así sucesivamente hasta finalizar el proceso. Si en alguno de los .then algo llegara a salir mal, sólo se necesita un catch para atraparlo.
    ✓ .catch():   Si la promesa es rechazada, su valor se captura dentro de un .catch() siguiendo la misma lógica
    ✓ .finally() es un método que recibe una función la cual se ejecutará siempre al finalizar la secuencia, sin importar si se haya resuelto o no la promesa.
   
    Como una promesa puede tener varios estados posibles, se puede concatenar varios .then() o .catch() en un mismo llamado, y caeremos en el caso que corresponda según cómo se haya resuelto la promesa. Para cada promesa podemos definir una 
    estructura para trabajar los distintos casos posibles. Cada promesa sólo puede resolverse o rechazarse una única vez. Es un mecanismo de control claro y ordenado para trabajar la asincronía y los posibles valores a recibir.   
   
   > Try-catch: This statement is comprised of a try block and either a catch block, a finally block, or both. The code in the try block is executed first, and if it throws an exception, the code in the catch block will be executed. The code 
     in the finally block will always be executed before control flow exits the entire construct.
   
   > Try-catch-throw:
     If you use the keyword 'throw' in an async function, the function will call the 'reject()' function behind the scenes and the promise will get rejected...
     However, when using try...catch block inside an async function and an error occurs in some function that returns a promise (like fetch) or if you use the 'throw' keyword yourself, the code execution will stop and move to the first 
     available catch block. So try...catch block gives you control to handle errors manually and internally and then decide how to proceed.
     For example, you could handle 10 different errors in a single or multiple try...catch blocks withing the async function and decide to reject the promise only for major errors, but still resolve it manually for smaller errors.
     The bottom line is that try...catch block gives you more control over error handling. So if you only have 1 possible error message like we do here, then you don't need the try/catch block in getJSON function nor loadRecipe function and
     the promises those functions return will normally reject/resolve based on what happened with the promises inside
   
   > fetch: Sirve para hacer peticiones HTTP a algún servicio externo. Como estas peticiones son asincrónicas, convenientemente el método fetch() trabaja con promesas. El método recibe un primer parámetro que es la URL a la cual hacer la 
     petición, y un segundo parámetro opcional de configuración: fetch(url, config). Al final, fetch retorna una nueva promesa.
     Por defecto el método fetch hace peticiones del tipo GET. Según la documentación, para obtener una lista de posts debemos hacer una petición del siguiente tipo.
     Podemos hacer un request de manera simple, utilizando Fetch API.
     Esta nos provee con una promesa, que se resuelve al terminar el request.
     Esta respuesta es una promise, que nos permite acceder a la respuesta.
       
   > Response: Llamar a fetch() retorna una promesa que resuelve en un objeto Response que contiene información sobre la respuesta del servidor, como su código de estado y headers. Para acceder al contenido de la respuesta debemos dar un 
     paso adicional, y por eso es que se ven dos .then() concatenados. Generalmente, se transfieren datos en formato JSON. Por lo tanto, para obtener el contenido de la respuesta debemos aplicar el método .json() a ese objeto. Éste retorna 
     a su vez una Promesa, por lo que capturamos su contenido (los datos enviados por la API) en un segundo .then(): 

         fetch('https://jsonplaceholder.typicode.com/posts')
           .then( (resp) => resp.json() )
           .then( (data) => {
            console.log(data)
         });
         
       En el parámetro data tenemos el contenido de la respuesta de nuestra petición. En este caso, la API nos responde con un array de 100 elemento donde cada elemento es un post.
         
  > async & await: Trabajar con promesas facilita mucho el control de los procesos asincrónicos Sin embargo, en procesos extensos se puede dificultar el trabajo escribiendo todo dentro de varios .then(). 
       Por suerte, los desarrolladores de JS ya pensaron en esto y nos ofrecen una herramienta que nos permite trabajar las promesas como si escribiéramos código sincrónico : async await.
       El método fetch retorna una promesa. De forma sincrónica, si guardamos esta promesa en una variable veremos la promesa pendiente, porque esto sucede sincrónicamente.

       const resp = fetch('https://jsonplaceholder.typicode.com/posts' ); console.log(resp) // Promise {<pending>}
       
    Significa que el console.log() no espera a que se resuelva la promesa de la línea anterior para ejecutarse.

    ✓ async: Se colocará al inicio de una función, indicando que todo el cuerpo de esa función deberá ejecutarse de manera asíncrona 
      Esta palabra reservada sirve para declarar una función como asincrónica, y se agrega como prefijo a la función. Así, dentro de una función async podemos utilizar la sentencia await vista previamente. Esto nos permite esperar a 
      que se resuelvan las promesas vistas para continuar con la instrucción siguiente.
      Lo que hace await es detener la ejecución y no continuar. Se espera a que se resuelva la promesa, y hasta que no lo haga, no continua. A diferencia del fetch(), tenemos un código bloqueante.
      
    ✓ await: servirá (como indica su nombre) para esperar por el resultado de la promesa y extraer su resultado. Al ser operaciones que podrían salir bien, PERO TAMBIÉN MAL, es importante encerrar el cuerpo en un bloque try {} catch {} 
      Nos permite establecer un punto de espera en el código. Aplicado como prefijo a una promesa (en este caso, el return del fetch) se bloquea la ejecución de la siguiente instrucción hasta que la promesa se resuelva.     
      Lo malo es que await sólo puede utilizarse dentro de una función asincrónica. Aquí es donde entra la sentencia async. Ésta palabra reservada sirve para declarar una función como asincrónica, y se agrega como prefijo a la función.             
      Así, dentro de una función async podemos utilizar la sentencia await vista previamente. Esto nos permite esperar a que se resuelvan las promesas vistas para continuar con la instrucción siguiente. 

   > micro-tasks queue: 
   
   
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Typescript   
npm create vite@latest
npm install -g npm@10.9.0
npm i nodemon concurrently
npm i @types/node

tsc --init
npx tsx src/index.ts
ts-node src/index.ts

"start:build": "tsc -w",
"start:run": "nodemon build/index.js",
"start": "concurrently npm:start:*",
"start:db": "json-server -p 3000 -w db.json",
"dev": "vite",
"build": "tsc && vite build",
"preview": "vite preview"

https://stackoverflow.com/questions/37233735/interfaces-vs-types-in-typescript
https://blog.logrocket.com/types-vs-interfaces-typescript/

- interface: 
  Remember that In an interface or type, you cannot use a traditional function definition with the function keyword or include a function body ({ ... }). You can only use arrow functions.

- type: 

- class: 

- implements: It is used in a class to indicate that the class is going to implement a particular interface. It ensures that the class includes all the properties and methods specified by the interface.
  In Typescript an implements clause can be used to verify that a class conforms to a specific interface. If a class fails to implement an interface correctly, an error will be generated. Classes can implement a single 
  interface or multiple interfaces at once. 
  implements means that The new class can be treated as the same "shape", but it is not a child. It could be passed to any method where Person is required, regardless of having a different parent than Person.
   ~ Inheritance: Implements is used for interface implementation. It enables a class to provide specific implementations for the methods defined in an interface.
   ~ Multiple Inheritance: A class can implement multiple interfaces
   ~ Implementation of Methods: Requires the class to provide concrete implementations for all methods declared in the interface.
   ~ Code Reusability: Promotes code reusability and abstraction through interfaces.
   ~ Abstract Classes: Cannot extend abstract classes but can implement abstract methods.

- declare:

   
- extends

- as: 

- keyof

- Record: 

                                                                 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- children

- ReactNode: 

- ReactElement: 

- MouseEvent: 

- ChangeEvent

                                                                 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Type annotations: 

- Types Inference

- Composing Types
  > Unions
  > Generics

- Structural Type System

- Gradual typing

- Structural typing: 
     type One = { p: string };
     interface Two { p: string };
     class Three { p = "Hello" };
     
     let x: One = { p: "hi" };
     let two: Two = x;
     two = new Three();

- Arrays: 

- Functions: 

- Tuple: A tuple type is another sort of Array type that knows exactly how many elements it contains, and exactly which types it contains at specific positions.

- Object types: 

- Union types: 

- Type Aliases: 

- Interfaces: 

- Differences Between Type Aliases and Interfaces

- Type annotations: 

- Type Assertions:

- Literal Types: 

- Literal Inference: 

- Unions

- Unit types:

- Rest parameters and arguments:

- classes
  > visibility modifiers
  > Implementing an interface to a class
  > Getters and Setters

- Index Signatures & keyof Assertions

- Generics

- Generic Constraints

- Utility Types
  > Partial 
  > Required
  > readonly
  > Record
  > Pick
  > Omit
  > Exclude
  > Extract
  > NonNullable
  > ReturnType
  > Parameters
  > Awaited


 


























