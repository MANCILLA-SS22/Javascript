{"mappings":"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","sources":["node_modules/@parcel/runtime-browser-hmr/lib/runtime-8264eb199b3ed956.js","ApuntesDeClase/main.js"],"sourcesContent":["var HMR_HOST = null;var HMR_PORT = null;var HMR_SECURE = false;var HMR_ENV_HASH = \"d6ea1d42532a7575\";module.bundle.HMR_BUNDLE_ID = \"4f68ae3771eb84b3\";\"use strict\";\n\n/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */\n/*::\nimport type {\n  HMRAsset,\n  HMRMessage,\n} from '@parcel/reporter-dev-server/src/HMRServer.js';\ninterface ParcelRequire {\n  (string): mixed;\n  cache: {|[string]: ParcelModule|};\n  hotData: {|[string]: mixed|};\n  Module: any;\n  parent: ?ParcelRequire;\n  isParcelRequire: true;\n  modules: {|[string]: [Function, {|[string]: string|}]|};\n  HMR_BUNDLE_ID: string;\n  root: ParcelRequire;\n}\ninterface ParcelModule {\n  hot: {|\n    data: mixed,\n    accept(cb: (Function) => void): void,\n    dispose(cb: (mixed) => void): void,\n    // accept(deps: Array<string> | string, cb: (Function) => void): void,\n    // decline(): void,\n    _acceptCallbacks: Array<(Function) => void>,\n    _disposeCallbacks: Array<(mixed) => void>,\n  |};\n}\ninterface ExtensionContext {\n  runtime: {|\n    reload(): void,\n    getURL(url: string): string;\n    getManifest(): {manifest_version: number, ...};\n  |};\n}\ndeclare var module: {bundle: ParcelRequire, ...};\ndeclare var HMR_HOST: string;\ndeclare var HMR_PORT: string;\ndeclare var HMR_ENV_HASH: string;\ndeclare var HMR_SECURE: boolean;\ndeclare var chrome: ExtensionContext;\ndeclare var browser: ExtensionContext;\ndeclare var __parcel__import__: (string) => Promise<void>;\ndeclare var __parcel__importScripts__: (string) => Promise<void>;\ndeclare var globalThis: typeof self;\ndeclare var ServiceWorkerGlobalScope: Object;\n*/\nvar OVERLAY_ID = '__parcel__error__overlay__';\nvar OldModule = module.bundle.Module;\nfunction Module(moduleName) {\n  OldModule.call(this, moduleName);\n  this.hot = {\n    data: module.bundle.hotData[moduleName],\n    _acceptCallbacks: [],\n    _disposeCallbacks: [],\n    accept: function (fn) {\n      this._acceptCallbacks.push(fn || function () {});\n    },\n    dispose: function (fn) {\n      this._disposeCallbacks.push(fn);\n    }\n  };\n  module.bundle.hotData[moduleName] = undefined;\n}\nmodule.bundle.Module = Module;\nmodule.bundle.hotData = {};\nvar checkedAssets /*: {|[string]: boolean|} */, assetsToDispose /*: Array<[ParcelRequire, string]> */, assetsToAccept /*: Array<[ParcelRequire, string]> */;\n\nfunction getHostname() {\n  return HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');\n}\nfunction getPort() {\n  return HMR_PORT || location.port;\n}\n\n// eslint-disable-next-line no-redeclare\nvar parent = module.bundle.parent;\nif ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {\n  var hostname = getHostname();\n  var port = getPort();\n  var protocol = HMR_SECURE || location.protocol == 'https:' && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? 'wss' : 'ws';\n  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');\n\n  // Web extension context\n  var extCtx = typeof chrome === 'undefined' ? typeof browser === 'undefined' ? null : browser : chrome;\n\n  // Safari doesn't support sourceURL in error stacks.\n  // eval may also be disabled via CSP, so do a quick check.\n  var supportsSourceURL = false;\n  try {\n    (0, eval)('throw new Error(\"test\"); //# sourceURL=test.js');\n  } catch (err) {\n    supportsSourceURL = err.stack.includes('test.js');\n  }\n\n  // $FlowFixMe\n  ws.onmessage = async function (event /*: {data: string, ...} */) {\n    checkedAssets = {} /*: {|[string]: boolean|} */;\n    assetsToAccept = [];\n    assetsToDispose = [];\n    var data /*: HMRMessage */ = JSON.parse(event.data);\n    if (data.type === 'update') {\n      // Remove error overlay if there is one\n      if (typeof document !== 'undefined') {\n        removeErrorOverlay();\n      }\n      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH);\n\n      // Handle HMR Update\n      let handled = assets.every(asset => {\n        return asset.type === 'css' || asset.type === 'js' && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);\n      });\n      if (handled) {\n        console.clear();\n\n        // Dispatch custom event so other runtimes (e.g React Refresh) are aware.\n        if (typeof window !== 'undefined' && typeof CustomEvent !== 'undefined') {\n          window.dispatchEvent(new CustomEvent('parcelhmraccept'));\n        }\n        await hmrApplyUpdates(assets);\n\n        // Dispose all old assets.\n        let processedAssets = {} /*: {|[string]: boolean|} */;\n        for (let i = 0; i < assetsToDispose.length; i++) {\n          let id = assetsToDispose[i][1];\n          if (!processedAssets[id]) {\n            hmrDispose(assetsToDispose[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n\n        // Run accept callbacks. This will also re-execute other disposed assets in topological order.\n        processedAssets = {};\n        for (let i = 0; i < assetsToAccept.length; i++) {\n          let id = assetsToAccept[i][1];\n          if (!processedAssets[id]) {\n            hmrAccept(assetsToAccept[i][0], id);\n            processedAssets[id] = true;\n          }\n        }\n      } else fullReload();\n    }\n    if (data.type === 'error') {\n      // Log parcel errors to console\n      for (let ansiDiagnostic of data.diagnostics.ansi) {\n        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;\n        console.error('🚨 [parcel]: ' + ansiDiagnostic.message + '\\n' + stack + '\\n\\n' + ansiDiagnostic.hints.join('\\n'));\n      }\n      if (typeof document !== 'undefined') {\n        // Render the fancy html overlay\n        removeErrorOverlay();\n        var overlay = createErrorOverlay(data.diagnostics.html);\n        // $FlowFixMe\n        document.body.appendChild(overlay);\n      }\n    }\n  };\n  ws.onerror = function (e) {\n    console.error(e.message);\n  };\n  ws.onclose = function () {\n    console.warn('[parcel] 🚨 Connection to the HMR server was lost');\n  };\n}\nfunction removeErrorOverlay() {\n  var overlay = document.getElementById(OVERLAY_ID);\n  if (overlay) {\n    overlay.remove();\n    console.log('[parcel] ✨ Error resolved');\n  }\n}\nfunction createErrorOverlay(diagnostics) {\n  var overlay = document.createElement('div');\n  overlay.id = OVERLAY_ID;\n  let errorHTML = '<div style=\"background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;\">';\n  for (let diagnostic of diagnostics) {\n    let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame) => {\n      return `${p}\n<a href=\"/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}\" style=\"text-decoration: underline; color: #888\" onclick=\"fetch(this.href); return false\">${frame.location}</a>\n${frame.code}`;\n    }, '') : diagnostic.stack;\n    errorHTML += `\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          🚨 ${diagnostic.message}\n        </div>\n        <pre>${stack}</pre>\n        <div>\n          ${diagnostic.hints.map(hint => '<div>💡 ' + hint + '</div>').join('')}\n        </div>\n        ${diagnostic.documentation ? `<div>📝 <a style=\"color: violet\" href=\"${diagnostic.documentation}\" target=\"_blank\">Learn more</a></div>` : ''}\n      </div>\n    `;\n  }\n  errorHTML += '</div>';\n  overlay.innerHTML = errorHTML;\n  return overlay;\n}\nfunction fullReload() {\n  if ('reload' in location) {\n    location.reload();\n  } else if (extCtx && extCtx.runtime && extCtx.runtime.reload) {\n    extCtx.runtime.reload();\n  }\n}\nfunction getParents(bundle, id) /*: Array<[ParcelRequire, string]> */{\n  var modules = bundle.modules;\n  if (!modules) {\n    return [];\n  }\n  var parents = [];\n  var k, d, dep;\n  for (k in modules) {\n    for (d in modules[k][1]) {\n      dep = modules[k][1][d];\n      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {\n        parents.push([bundle, k]);\n      }\n    }\n  }\n  if (bundle.parent) {\n    parents = parents.concat(getParents(bundle.parent, id));\n  }\n  return parents;\n}\nfunction updateLink(link) {\n  var href = link.getAttribute('href');\n  if (!href) {\n    return;\n  }\n  var newLink = link.cloneNode();\n  newLink.onload = function () {\n    if (link.parentNode !== null) {\n      // $FlowFixMe\n      link.parentNode.removeChild(link);\n    }\n  };\n  newLink.setAttribute('href',\n  // $FlowFixMe\n  href.split('?')[0] + '?' + Date.now());\n  // $FlowFixMe\n  link.parentNode.insertBefore(newLink, link.nextSibling);\n}\nvar cssTimeout = null;\nfunction reloadCSS() {\n  if (cssTimeout) {\n    return;\n  }\n  cssTimeout = setTimeout(function () {\n    var links = document.querySelectorAll('link[rel=\"stylesheet\"]');\n    for (var i = 0; i < links.length; i++) {\n      // $FlowFixMe[incompatible-type]\n      var href /*: string */ = links[i].getAttribute('href');\n      var hostname = getHostname();\n      var servedFromHMRServer = hostname === 'localhost' ? new RegExp('^(https?:\\\\/\\\\/(0.0.0.0|127.0.0.1)|localhost):' + getPort()).test(href) : href.indexOf(hostname + ':' + getPort());\n      var absolute = /^https?:\\/\\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;\n      if (!absolute) {\n        updateLink(links[i]);\n      }\n    }\n    cssTimeout = null;\n  }, 50);\n}\nfunction hmrDownload(asset) {\n  if (asset.type === 'js') {\n    if (typeof document !== 'undefined') {\n      let script = document.createElement('script');\n      script.src = asset.url + '?t=' + Date.now();\n      if (asset.outputFormat === 'esmodule') {\n        script.type = 'module';\n      }\n      return new Promise((resolve, reject) => {\n        var _document$head;\n        script.onload = () => resolve(script);\n        script.onerror = reject;\n        (_document$head = document.head) === null || _document$head === void 0 ? void 0 : _document$head.appendChild(script);\n      });\n    } else if (typeof importScripts === 'function') {\n      // Worker scripts\n      if (asset.outputFormat === 'esmodule') {\n        return __parcel__import__(asset.url + '?t=' + Date.now());\n      } else {\n        return new Promise((resolve, reject) => {\n          try {\n            __parcel__importScripts__(asset.url + '?t=' + Date.now());\n            resolve();\n          } catch (err) {\n            reject(err);\n          }\n        });\n      }\n    }\n  }\n}\nasync function hmrApplyUpdates(assets) {\n  global.parcelHotUpdate = Object.create(null);\n  let scriptsToRemove;\n  try {\n    // If sourceURL comments aren't supported in eval, we need to load\n    // the update from the dev server over HTTP so that stack traces\n    // are correct in errors/logs. This is much slower than eval, so\n    // we only do it if needed (currently just Safari).\n    // https://bugs.webkit.org/show_bug.cgi?id=137297\n    // This path is also taken if a CSP disallows eval.\n    if (!supportsSourceURL) {\n      let promises = assets.map(asset => {\n        var _hmrDownload;\n        return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch(err => {\n          // Web extension bugfix for Chromium\n          // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12\n          if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {\n            if (typeof ServiceWorkerGlobalScope != 'undefined' && global instanceof ServiceWorkerGlobalScope) {\n              extCtx.runtime.reload();\n              return;\n            }\n            asset.url = extCtx.runtime.getURL('/__parcel_hmr_proxy__?url=' + encodeURIComponent(asset.url + '?t=' + Date.now()));\n            return hmrDownload(asset);\n          }\n          throw err;\n        });\n      });\n      scriptsToRemove = await Promise.all(promises);\n    }\n    assets.forEach(function (asset) {\n      hmrApply(module.bundle.root, asset);\n    });\n  } finally {\n    delete global.parcelHotUpdate;\n    if (scriptsToRemove) {\n      scriptsToRemove.forEach(script => {\n        if (script) {\n          var _document$head2;\n          (_document$head2 = document.head) === null || _document$head2 === void 0 ? void 0 : _document$head2.removeChild(script);\n        }\n      });\n    }\n  }\n}\nfunction hmrApply(bundle /*: ParcelRequire */, asset /*:  HMRAsset */) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (asset.type === 'css') {\n    reloadCSS();\n  } else if (asset.type === 'js') {\n    let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];\n    if (deps) {\n      if (modules[asset.id]) {\n        // Remove dependencies that are removed and will become orphaned.\n        // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.\n        let oldDeps = modules[asset.id][1];\n        for (let dep in oldDeps) {\n          if (!deps[dep] || deps[dep] !== oldDeps[dep]) {\n            let id = oldDeps[dep];\n            let parents = getParents(module.bundle.root, id);\n            if (parents.length === 1) {\n              hmrDelete(module.bundle.root, id);\n            }\n          }\n        }\n      }\n      if (supportsSourceURL) {\n        // Global eval. We would use `new Function` here but browser\n        // support for source maps is better with eval.\n        (0, eval)(asset.output);\n      }\n\n      // $FlowFixMe\n      let fn = global.parcelHotUpdate[asset.id];\n      modules[asset.id] = [fn, deps];\n    } else if (bundle.parent) {\n      hmrApply(bundle.parent, asset);\n    }\n  }\n}\nfunction hmrDelete(bundle, id) {\n  let modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (modules[id]) {\n    // Collect dependencies that will become orphaned when this module is deleted.\n    let deps = modules[id][1];\n    let orphans = [];\n    for (let dep in deps) {\n      let parents = getParents(module.bundle.root, deps[dep]);\n      if (parents.length === 1) {\n        orphans.push(deps[dep]);\n      }\n    }\n\n    // Delete the module. This must be done before deleting dependencies in case of circular dependencies.\n    delete modules[id];\n    delete bundle.cache[id];\n\n    // Now delete the orphans.\n    orphans.forEach(id => {\n      hmrDelete(module.bundle.root, id);\n    });\n  } else if (bundle.parent) {\n    hmrDelete(bundle.parent, id);\n  }\n}\nfunction hmrAcceptCheck(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  if (hmrAcceptCheckOne(bundle, id, depsByBundle)) {\n    return true;\n  }\n\n  // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.\n  let parents = getParents(module.bundle.root, id);\n  let accepted = false;\n  while (parents.length > 0) {\n    let v = parents.shift();\n    let a = hmrAcceptCheckOne(v[0], v[1], null);\n    if (a) {\n      // If this parent accepts, stop traversing upward, but still consider siblings.\n      accepted = true;\n    } else {\n      // Otherwise, queue the parents in the next level upward.\n      let p = getParents(module.bundle.root, v[1]);\n      if (p.length === 0) {\n        // If there are no parents, then we've reached an entry without accepting. Reload.\n        accepted = false;\n        break;\n      }\n      parents.push(...p);\n    }\n  }\n  return accepted;\n}\nfunction hmrAcceptCheckOne(bundle /*: ParcelRequire */, id /*: string */, depsByBundle /*: ?{ [string]: { [string]: string } }*/) {\n  var modules = bundle.modules;\n  if (!modules) {\n    return;\n  }\n  if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {\n    // If we reached the root bundle without finding where the asset should go,\n    // there's nothing to do. Mark as \"accepted\" so we don't reload the page.\n    if (!bundle.parent) {\n      return true;\n    }\n    return hmrAcceptCheck(bundle.parent, id, depsByBundle);\n  }\n  if (checkedAssets[id]) {\n    return true;\n  }\n  checkedAssets[id] = true;\n  var cached = bundle.cache[id];\n  assetsToDispose.push([bundle, id]);\n  if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {\n    assetsToAccept.push([bundle, id]);\n    return true;\n  }\n}\nfunction hmrDispose(bundle /*: ParcelRequire */, id /*: string */) {\n  var cached = bundle.cache[id];\n  bundle.hotData[id] = {};\n  if (cached && cached.hot) {\n    cached.hot.data = bundle.hotData[id];\n  }\n  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {\n    cached.hot._disposeCallbacks.forEach(function (cb) {\n      cb(bundle.hotData[id]);\n    });\n  }\n  delete bundle.cache[id];\n}\nfunction hmrAccept(bundle /*: ParcelRequire */, id /*: string */) {\n  // Execute the module.\n  bundle(id);\n\n  // Run the accept callbacks in the new version of the module.\n  var cached = bundle.cache[id];\n  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {\n    cached.hot._acceptCallbacks.forEach(function (cb) {\n      var assetsToAlsoAccept = cb(function () {\n        return getParents(module.bundle.root, id);\n      });\n      if (assetsToAlsoAccept && assetsToAccept.length) {\n        assetsToAlsoAccept.forEach(function (a) {\n          hmrDispose(a[0], a[1]);\n        });\n\n        // $FlowFixMe[method-unbinding]\n        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);\n      }\n    });\n  }\n}","//         $$$$$$$$$$$$$$$ Proyectos $$$$$$$$$$$$$$$\r\n\r\n\r\n/* //Proyecto 1: Bankist\r\nconst labelWelcome = document.querySelector('.welcome');\r\nconst labelDate = document.querySelector('.date');\r\nconst labelBalance = document.querySelector('.balance__value');\r\nconst labelSumIn = document.querySelector('.summary__value--in');\r\nconst labelSumOut = document.querySelector('.summary__value--out');\r\nconst labelSumInterest = document.querySelector('.summary__value--interest');\r\nconst labelTimer = document.querySelector('.timer');\r\nconst containerApp = document.querySelector('.app');\r\nconst containerMovements = document.querySelector('.movements');\r\nconst btnLogin = document.querySelector('.login__btn');\r\nconst btnTransfer = document.querySelector('.form__btn--transfer');\r\nconst btnLoan = document.querySelector('.form__btn--loan');\r\nconst btnClose = document.querySelector('.form__btn--close');\r\nconst btnSort = document.querySelector('.btn--sort');\r\nconst inputLoginUsername = document.querySelector('.login__input--user');\r\nconst inputLoginPin = document.querySelector('.login__input--pin');\r\nconst inputTransferTo = document.querySelector('.form__input--to');\r\nconst inputTransferAmount = document.querySelector('.form__input--amount');\r\nconst inputLoanAmount = document.querySelector('.form__input--loan-amount');\r\nconst inputCloseUsername = document.querySelector('.form__input--user');\r\nconst inputClosePin = document.querySelector('.form__input--pin');\r\n\r\nconst account1 = {\r\n    owner: 'Jonas Schmedtmann',\r\n    movements: [200, 455.23, -306.5, 25000, -642.21, -133.9, 79.97, 1300],\r\n    interestRate: 1.2, // %\r\n    pin: 1111,\r\n    movementsDates: [ // Las fechas se muestran con el formato toISOString()\r\n        '2019-11-18T21:31:17.178Z',\r\n        '2019-12-23T07:42:02.383Z',\r\n        '2020-01-28T09:15:04.904Z',\r\n        '2020-04-01T10:17:24.185Z',\r\n        '2020-05-08T14:11:59.604Z',\r\n        '2023-05-27T17:01:17.194Z',\r\n        '2023-07-23T23:36:17.929Z',\r\n        '2023-07-18T10:51:36.790Z',\r\n    ],\r\n    currency: 'EUR',\r\n    locale: 'pt-PT', // de-DE\r\n};\r\nconst account2 = {\r\n    owner: 'Jessica Davis',\r\n    movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30],\r\n    interestRate: 1.5,\r\n    pin: 2222,\r\n    movementsDates: [ // Las fechas se muestran con el formato toISOString()\r\n        '2019-11-01T13:15:33.035Z',\r\n        '2019-11-30T09:48:16.867Z',\r\n        '2019-12-25T06:04:23.907Z',\r\n        '2020-01-25T14:18:46.235Z',\r\n        '2020-02-05T16:33:06.386Z',\r\n        '2020-04-10T14:43:26.374Z',\r\n        '2020-06-25T18:49:59.371Z',\r\n        '2020-07-26T12:01:20.894Z',\r\n    ],\r\n    currency: 'USD',\r\n    locale: 'en-US',\r\n};\r\nconst accounts = [account1, account2]; //Almacenamos la informacion de los 4 objetos en un array.\r\n\r\n// FAKE ALWAYS LOGGED IN\r\n// currentAccount = account1;\r\n// updateUI(currentAccount);\r\n// containerApp.style.opacity = 100;\r\n\r\nlet currentAccount, timer;\r\nlet sorted = false;// For the btnSort, we fix this variable to false so the function displayMovements still recieve false, which means that it doesn't sort the array.\r\n\r\ncreateUserNames(accounts);\r\nfunction createUserNames (accs){\r\n    accs.forEach(function(num_acc){\r\n        num_acc.username = num_acc.owner.toLowerCase().split(\" \").map(name => name[0]).join(\"\"); // We create a new element (num_acc.username) that will contain the lower case letters of each owner's name\r\n    })\r\n}\r\n\r\nfunction updateUI(acc){\r\n    displayMovements(acc);\r\n    calcDisplayBalance(acc);\r\n    calcDisplaySummary(acc);\r\n}\r\n\r\nfunction formatMovementDate(date, locale){\r\n\r\n    function calcDaysPassed(date1, date2){\r\n        return Math.round(Math.abs(date2 - date1) / (1000*60*60*24));\r\n    }\r\n\r\n    const dayPassed = calcDaysPassed(new Date(), date);\r\n    if (dayPassed === 0) return \"Today\";\r\n    if (dayPassed === 1) return \"Yesterday\";\r\n    if (dayPassed <= 7)  return `${dayPassed} days`;\r\n    \r\n    // // METODO 1\r\n    // const day = `${date.getDate()}`.padStart(2, 0);\r\n    // const month = `${date.getMonth() + 1}`.padStart(2, 0);\r\n    // const year = date.getFullYear();\r\n    // return `${day}/${month}/${year}`;\r\n    \r\n    //METODO 2\r\n    return new Intl.DateTimeFormat(locale).format(date)\r\n\r\n}\r\n\r\nfunction formatCur(value, locale, currency){\r\n    return new Intl.NumberFormat(locale, {style: \"currency\", currency: currency}).format(value);\r\n}\r\n\r\nfunction displayMovements(acc, sort=false){\r\n\r\n    containerMovements.innerHTML=\"\";\r\n    const movs = sort ? acc.movements.slice().sort((a,b) => a - b) : acc.movements;\r\n    \r\n    movs.forEach(function(mov, i) {\r\n        const date = new Date(acc.movementsDates[i]); //Accedemos a las fechas que estan en account1.movementsDates[]\r\n        const displayDate = formatMovementDate(date, acc.locale);\r\n\r\n        const type = mov > 0 ? \"deposit\" : \"withdrawal\";    \r\n\r\n        //METODO 1\r\n        // const html = `\r\n        //     <div class=\"movements__row\">\r\n        //         <div class=\"movements__type movements__type--${type}\">${i + 1} ${type}</div>\r\n        //         <div class=\"movements__date\">${displayDate}</div>\r\n        //         <div class=\"movements__value\">${mov.toFixed(2)}€</div>\r\n        //     </div>`\r\n        // containerMovements.insertAdjacentHTML(\"afterbegin\", html);\r\n\r\n        //METODO 2\r\n        const formattedMov = formatCur(mov, acc.locale, acc.currency);\r\n        const html = `\r\n            <div class=\"movements__row\">\r\n                <div class=\"movements__type movements__type--${type}\">${i + 1} ${type}</div>\r\n                <div class=\"movements__date\">${displayDate}</div>\r\n                <div class=\"movements__value\">${formattedMov}</div>\r\n            </div>`\r\n        containerMovements.insertAdjacentHTML(\"afterbegin\", html);\r\n    });\r\n}\r\n\r\nfunction calcDisplayBalance(acc){\r\n    acc.balance = acc.movements.reduce(function(acc, mov){\r\n        return acc + mov;\r\n    }, 0);\r\n\r\n    //METODO 1\r\n    // labelBalance.textContent = `${acc.balance.toFixed(2)}€`\r\n\r\n    //METODO 2\r\n    const formattedMov = formatCur(acc.balance, acc.locale, acc.currency);\r\n    labelBalance.textContent = formattedMov;\r\n}\r\n\r\nfunction calcDisplaySummary(acc){\r\n    // //METODO 1\r\n    // const incomes = acc.movements.filter(mov => mov > 0).reduce((acc, mov) => acc + mov, 0);\r\n    // labelSumIn.textContent = `${incomes.toFixed(2)}€`;\r\n\r\n    // const out = acc.movements.filter(mov => mov < 0).reduce((acc, mov) => acc + mov, 0);\r\n    // labelSumOut.textContent = `${Math.abs(out).toFixed(2)}€`;\r\n\r\n    // const interest = acc.movements.filter(mov => mov > 0).map( deposit => (deposit*acc.interestRate)/100 ).filter((int) => int >= 1).reduce((acc, int) => acc + int, 0);\r\n    // labelSumInterest.textContent = `${interest.toFixed(2)}€`;\r\n\r\n    //METODO 2\r\n    const incomes = acc.movements.filter(mov => mov > 0).reduce((acc, mov) => acc + mov, 0);\r\n    labelSumIn.textContent = formatCur(incomes, acc.locale, acc.currency);\r\n\r\n    const out = acc.movements.filter(mov => mov < 0).reduce((acc, mov) => acc + mov, 0);\r\n    labelSumOut.textContent = formatCur(Math.abs(out), acc.locale, acc.currency);\r\n\r\n    const interest = acc.movements.filter(mov => mov > 0).map( deposit => (deposit*acc.interestRate)/100 ).filter((int) => int >= 1).reduce((acc, int) => acc + int, 0);\r\n    labelSumInterest.textContent = formatCur(interest, acc.locale, acc.currency);\r\n}\r\n\r\nfunction startLogOutTimer(){\r\n    function tick(){\r\n        const min = String(Math.trunc(tiempo / 60)).padStart(2, 0);\r\n        const sec = String(tiempo % 60).padStart(2, 0);\r\n        labelTimer.textContent = `${min}:${sec}`;\r\n        if(tiempo === 0) {\r\n            clearInterval(startLogOutTimer);\r\n            labelWelcome.textContent = \"Log in to get started\"\r\n            containerApp.style.opacity = 0;\r\n        }\r\n        tiempo--;\r\n    }\r\n\r\n    let tiempo = 20;\r\n    tick(); //Llamamos a la funcion antes de que se ejecute el setInterval para que, al final se ejecuten al mismo tiempo. Ya que, de ejecutarse esta funcion dentro del setInterval, entonces obtendremos primero un '1' en la pantalla y luego iniciara el temporizador.\r\n    return setInterval(tick, 1000); //Volvemos a llamar a la funcion tick en el setInterval para que cada segundo que pase, se vuelva a ejecutar.\r\n}\r\n\r\nbtnLogin.addEventListener(\"click\", function(evento){\r\n    evento.preventDefault();\r\n    \r\n    currentAccount = accounts.find(acc => acc.username === inputLoginUsername.value) //We verify if the username typed in the input is the same as the one in the array that is into \"accounts\". If so, we get the found object.\r\n\r\n    if(currentAccount?.pin === Number(inputLoginPin.value)){ //We check if the pin in the object is the same as the one typed in the input. (We must write use \"?.\" so that we can get an \"undefined\" and not an error)\r\n        labelWelcome.textContent = `Welcome back, ${currentAccount.owner.split(\" \")[0]}`; //If so, then we change the sentence in the upper right corner.\r\n        containerApp.style.opacity = 100; //We do this so that we can see the menu with information.\r\n\r\n        //METODO 1\r\n        // const now = new Date();\r\n        // const day = `${now.getDate()}`.padStart(2, 0);\r\n        // const month = `${now.getMonth() + 1}`.padStart(2, 0);\r\n        // const year = now.getFullYear();\r\n        // const hour = `${now.getHours()}`.padStart(2, 0);\r\n        // const min = `${now.getMinutes()}`.padStart(2, 0);\r\n        // labelDate.textContent = `${day}/${month}/${year}, ${hour}:${min}`;\r\n\r\n        //METODO 2\r\n        const now = new Date();\r\n        const options = {hour:\"numeric\", minute: \"numeric\", day: \"numeric\", month: \"numeric\", year: \"numeric\", }; //weekday: \"numeric\"\r\n\r\n        // const locale = navigator.language;\r\n        labelDate.textContent = new Intl.DateTimeFormat(currentAccount.locale, options).format(now);\r\n        inputLoginUsername.value = inputLoginPin.value = \"\"; //Now we delete the written values in our inputs (user and PIN)\r\n        inputLoginPin.blur(); //This work so that when we want to log in and finally press \"enter\", then our cursor will disappear.\r\n\r\n        if (timer) {//Cuando iniciamos sesion, timer es undefined, por lo que no se ejecuta el if.\r\n            clearInterval(timer)\r\n        }\r\n        timer = startLogOutTimer(); //pero cuando iniciamos sesion, ejecutamos la funcion del conteo y se almacena en timer. Posterior a eso, como ya existira timer, ahora si se ejecutara el if, el cual reiniciara el conteo.\r\n        updateUI(currentAccount);\r\n    }\r\n});\r\n\r\nbtnTransfer.addEventListener(\"click\", function(evento){\r\n    evento.preventDefault();\r\n    const amount = Number(inputTransferAmount.value); //Recuperamos el numero ingresado en el input donde introducimos el dinero\r\n    const receiverAcc = accounts.find(acc => acc.username === inputTransferTo.value); //Recuperamos el objeto contenido en uno de los arrays de accounts, al verificar si el nombre de usuario existe dentro de los 4 arrays de accounts y si es igual al ingresado en el input.\r\n    inputTransferAmount.value = inputTransferTo.value = \"\";\r\n\r\n    if (amount > 0 && receiverAcc && currentAccount.balance >= amount && receiverAcc?.username !== currentAccount.username) {\r\n        currentAccount.movements.push(-amount);\r\n        receiverAcc.movements.push(amount);\r\n\r\n        currentAccount.movementsDates.push(new Date().toISOString());\r\n        receiverAcc.movementsDates.push(new Date().toISOString());\r\n\r\n        updateUI(currentAccount);\r\n\r\n        clearInterval(timer); //Cuando iniciamos sesion, timer es undefined, por lo que no se ejecuta el if.\r\n        timer = startLogOutTimer(); //pero cuando iniciamos sesion, ejecutamos la funcion del conteo y se almacena en timer. Posterior a eso, como ya existira timer, ahora si se ejecutara el if, el cual reiniciara el conteo.\r\n    }\r\n});\r\n\r\nbtnClose.addEventListener(\"click\", function(evento){\r\n    evento.preventDefault();\r\n\r\n    if (inputCloseUsername.value === currentAccount.username && Number(inputClosePin.value) === currentAccount.pin) { //We verify if the written values in the inputs are the same as those in the current object.\r\n        const index = accounts.findIndex(acc => acc.username === currentAccount.username); //If so, we proceed to find the index of the object in the array \"accounts\"\r\n        accounts.splice(index, 1);\r\n        containerApp.style.opacity = 0; \r\n        console.log(accounts);\r\n    }\r\n\r\n    inputCloseUsername.value = inputClosePin.value = \"\";\r\n});\r\n\r\nbtnLoan.addEventListener(\"click\", function(evento){\r\n    evento.preventDefault();\r\n\r\n    const amount = Math.floor(inputLoanAmount.value)\r\n    if (amount > 0 && currentAccount.movements.some(mov => (mov >= amount*0.1))) {\r\n        \r\n        setTimeout(function(){\r\n            currentAccount.movements.push(amount);\r\n            currentAccount.movementsDates.push(new Date().toISOString());\r\n\r\n            updateUI(currentAccount);\r\n\r\n            clearInterval(timer);\r\n            timer = startLogOutTimer();\r\n        }, 2500);\r\n\r\n    }\r\n    inputLoanAmount.value = \"\";\r\n});\r\n\r\nbtnSort.addEventListener(\"click\", function(evento){\r\n    evento.preventDefault();\r\n\r\n    displayMovements(currentAccount.movements, !sorted); //When clicking the button, then that variable changes to true and the array is sorted.\r\n    sorted =! sorted; //After that, we need to change the \"sorted\" variable to the opposite boolean value. We do this so that when we press the button again, this back to normal (unsorted).\r\n})\r\n\r\nlabelBalance.addEventListener('click', function () {\r\n    let valor = document.querySelectorAll('.movements__value'); \r\n    const movementsUI = Array.from(valor, function(el){   // Array.from(Array-like or iterable object, mapFunction, thisValue)\r\n        return Number(el.textContent.replace('€', ''))\r\n    });  console.log(movementsUI);\r\n    // const movementsUI2 = [...document.querySelectorAll('.movements__value')];\r\n\r\n\r\n    [...document.querySelectorAll(\".movements__row\")].forEach(function(row, i){\r\n        if (i % 2 === 0) row.style.backgroundColor = \"orangered\";\r\n        if (i % 3 === 0) row.style.backgroundColor = \"blue\";\r\n    })\r\n}); */\r\n\r\n/* //Proyecto 2: Bankist_Advanced-DOM\r\nconst modal = document.querySelector('.modal');\r\nconst overlay = document.querySelector('.overlay');\r\nconst btnCloseModal = document.querySelector('.btn--close-modal');\r\nconst btnsOpenModal = document.querySelectorAll('.btn--show-modal');\r\nconst btnScrollTo = document.querySelector(\".btn--scroll-to\");\r\nconst section1 = document.querySelector(\"#section--1\");\r\nconst tabsContainer = document.querySelector('.operations__tab-container');\r\nconst tabs = document.querySelectorAll('.operations__tab');\r\nconst tabsContent = document.querySelectorAll('.operations__content');\r\nconst nav = document.querySelector(\".nav\");\r\nconst header = document.querySelector(\".header\");\r\n\r\nfunction openModal(evento) {\r\n    evento.preventDefault();\r\n    modal.classList.remove('hidden');\r\n    overlay.classList.remove('hidden');\r\n};\r\n\r\nfunction closeModal() {\r\n    modal.classList.add('hidden');\r\n    overlay.classList.add('hidden');\r\n};\r\n\r\n//Metodo 2\r\nbtnsOpenModal.forEach(function(evento) {\r\n    evento.addEventListener(\"click\", openModal)\r\n});\r\n\r\nbtnCloseModal.addEventListener('click', closeModal);\r\noverlay.addEventListener('click', closeModal);\r\n\r\n//Closing a card by using the keydown method in addEventListener\r\ndocument.addEventListener('keydown', function (evento) {\r\n    if (evento.key === 'Escape' && !modal.classList.contains('hidden')) {\r\n        closeModal();\r\n    }\r\n});\r\n\r\n//Finding coordenates and position, and use of scroll\r\nbtnScrollTo.addEventListener(\"click\", function(evento){\r\n    section1.scrollIntoView({behavior: \"smooth\"});\r\n});\r\n\r\n//Page navigation\r\ndocument.querySelector(\".nav__links\").addEventListener(\"click\", function(evento){\r\n    evento.preventDefault();\r\n\r\n    //Aqui usamos evento.target porque en este caso estamos utilizando el <ul> como elemento padre, y sus hijos son <li> y <a>. Ahora, con el addEventListener podemos hacer click en el elemento padre o incluso sus hijos y JS ejecutara la tarea deseada. Si usamos this como en el metodo 1, este solo funcionara para elelemento actual o el padre, es decir <ul>.\r\n    if (evento.target.classList.contains(\"nav__link\")) {\r\n        const id = evento.target.getAttribute(\"href\"); //Retorna unicamente el nombre del atriuto contenido en esa etiqueta. Si usamos const id = this.href, entonces tendremos el link completo que aparece en la barra de navegacion\r\n        document.querySelector(id).scrollIntoView({behavior: \"smooth\"});\r\n    }\r\n});\r\n\r\n// Building a Tabbed Component\r\ntabsContainer.addEventListener('click', function (evento) {\r\n\r\n    //Debemos añadir el closest(), ya que operations__tab-container tiene de hijos tres elementos botones con un span cada uno. Por lo que al presionar el boton, especificamente el texto (span), no funcionara correctamente el boton. Es por eso que agregamos el closest(), para que al presionar el boton, considere unicamente el elemento mas cercano con el nombre operations__tab (incluyendo su hijo <span>).  Cabe mencionar que, si precionamos donde esta el <div class=\"operations__tab-container\"> entonces tendremos un null en consola, ya que no existe ningun elemento padre con el  class \".operations__tab\". Para eso usamos el Guard clause, para que al no haber un click en el botton, simplemente salga de la funcion y no ejecute las lineas siguientes.\r\n    const clicked = evento.target.closest('.operations__tab');  console.log(clicked);\r\n    \r\n    // Guard clause\r\n    if (!clicked) return;\r\n\r\n    //Realizamos un barrido en cada uno de los 3 botones y en cada uno de los 3 contenidos de texto. Dependiendo del boton seleccionado, a este se le eliminaran sus \"active\"\r\n    tabs.forEach(evento => evento.classList.remove('operations__tab--active'));\r\n    tabsContent.forEach(evento => evento.classList.remove('operations__content--active'));\r\n\r\n    //Una vez eliminado los \"active\" en el boton y el contenido seleccinado, ahora se procede a \"activar\" el boton y su contenido seleccionado.\r\n    clicked.classList.add('operations__tab--active');\r\n\r\n    //Dependiendo del boton que se haya presionado, este realizara la animacion en el boton, y tambien se desplegara el contenido de texto del boton seleccionado.\r\n    document.querySelector(`.operations__content--${clicked.dataset.tab}`).classList.add('operations__content--active'); \r\n});\r\n\r\n//Passing Arguments to Event Handlers\r\nfunction handleHover(evento) {\r\n    //Recordar que cuando utilizamos bind(), la keyword \"this\" representa los parametros que le enviamos a la funcion, en este caso, 0.5 y 1.\r\n    if (evento.target.classList.contains('nav__link')) {\r\n        const link = evento.target;\r\n        const siblings = link.closest('.nav').querySelectorAll('.nav__link');\r\n\r\n        siblings.forEach(iter => { //Convertir a arrow function\r\n            if (iter !== link) iter.style.opacity = this;\r\n        });\r\n    }\r\n};\r\n\r\n// Usamos bind para retornar una nueva funcion de esa funcion handleHover, y de esa forma, no tener que usar una funcion que llame a otra funcion.\r\nnav.addEventListener('mouseover', handleHover.bind(0.5));\r\nnav.addEventListener('mouseout', handleHover.bind(1));\r\n\r\n//Sticky navigation\r\nfunction stickyNav(entries, observer){\r\n    const [entry] = entries; //entries is always an array because the options in IntersectionObserver can have multiple thresholds, and for each threshold, there will be an entry in the array, even if there is only one threshold.\r\n    // console.log(entry, observer);\r\n\r\n    if (entry.isIntersecting) { //When the target isn't intersecting the root, then we want the sticky class to be applied.\r\n        nav.classList.remove(\"sticky\");\r\n    }else{\r\n        nav.classList.add(\"sticky\");\r\n    }\r\n}\r\n\r\nconst options = {\r\n    root: null, //We select null because we are interested in the entire viewport\r\n    threshold: 0, //A value of 0 means that even a single visible pixel counts as the target being visible. That's to say, when the header shows a 0% of itself, then the function will get called .\r\n\r\n    //We use getBoundingClientRect().height to calculate dynamically the height (for responsive webpages) of the nav without the needed of hard coding and tupe an specific height. It'll be 90px.\r\n    rootMargin: `-${nav.getBoundingClientRect().height}px` //This value is in pixels and will be applied outside of the target element\r\n};\r\n\r\nconst headerObserver = new IntersectionObserver(stickyNav, options);\r\nheaderObserver.observe(header);\r\n\r\n\r\n// Revealing Elements on Scroll\r\nconst allSections = document.querySelectorAll(\".section\");\r\n\r\nconst revealSection = function(entries, observer){\r\n    const [entry] = entries;     //console.log(entry)\r\n\r\n    if(entry.isIntersecting === false) return;\r\n    entry.target.classList.remove(\"section--hidden\");\r\n\r\n    observer.unobserve(entry.target);\r\n};\r\nconst opciones = {\r\n    root: null,\r\n    threshold: 0.15, //We use something greater than zero because we don't want to show the section right as it enters the viewport, but a litte latter.\r\n}\r\n\r\nconst sectionObserver = new IntersectionObserver(revealSection, opciones)\r\n\r\nallSections.forEach(function(section){\r\n    sectionObserver.observe(section);\r\n    // section.classList.add(\"section--hidden\");\r\n});\r\n\r\n\r\n//Lazy Loading Images\r\nconst imgTarget = document.querySelectorAll(\"img[data-src]\");  // console.log(imgTarget);\r\n\r\nconst loadImg = function(entries, observer){\r\n    const [entry] = entries;   //console.log(entry);\r\n\r\n    if(entry.isIntersecting === false) return;\r\n\r\n    //Replace the src (\"imgs/grow-lazy.jpg\") with data-src (\"imgs/grow.jpg\"). That's to say, src is the blur image and the data-src is the high-quality image.\r\n    entry.target.src = entry.target.dataset.src;\r\n\r\n    entry.target.addEventListener(\"load\", function(){\r\n        entry.target.classList.remove(\"lazy-img\");\r\n    })\r\n\r\n    observer.unobserve(entry.target)\r\n}\r\n\r\nconst Opciones = {\r\n    root: null,\r\n    threshold: 0,\r\n    rootMargin: \"200px\"\r\n}\r\n\r\nconst imgObserver = new IntersectionObserver(loadImg, Opciones);\r\nimgTarget.forEach(evento => imgObserver.observe(evento));\r\n\r\n\r\n//Slider\r\nconst slides = document.querySelectorAll('.slide');\r\nconst btnLeft = document.querySelector('.slider__btn--left');\r\nconst btnRight = document.querySelector('.slider__btn--right');\r\nconst dotContainer = document.querySelector(\".dots\");\r\nlet curSlide = 0;\r\nconst maxSlide = slides.length;\r\n\r\n\r\nfunction goToSlide(slide) {\r\n    slides.forEach(function(evento, iter){\r\n        evento.style.transform = `translateX(${100 * (iter - slide)}%)`; //0%, 100%, 200%\r\n        // console.log(`${iter} , ${evento.style.transform}`);\r\n    })\r\n};\r\n\r\nfunction nextSlide() {\r\n    curSlide === maxSlide - 1 ? curSlide = 0 : curSlide++;\r\n    goToSlide(curSlide);\r\n    activateDot(curSlide)\r\n};\r\n\r\nfunction prevSlide() {\r\n    curSlide === 0 ? curSlide = maxSlide - 1 : curSlide--;\r\n    goToSlide(curSlide);\r\n    activateDot(curSlide)\r\n};\r\n\r\nfunction createDots() {\r\n    slides.forEach(function (_, i) {\r\n        dotContainer.insertAdjacentHTML('beforeend',\r\n            `<button class=\"dots__dot\" data-slide=\"${i}\"></button>`\r\n        );\r\n    });\r\n};\r\n\r\nfunction activateDot(slide){\r\n    document.querySelectorAll('.dots__dot').forEach(dot => dot.classList.remove('dots__dot--active'));\r\n    document.querySelector(`.dots__dot[data-slide=\"${slide}\"]`).classList.add('dots__dot--active');\r\n};\r\n\r\nfunction init(){\r\n    createDots();\r\n    goToSlide(0);\r\n    activateDot(0);\r\n}\r\n\r\ninit();\r\nbtnRight.addEventListener('click', nextSlide);\r\nbtnLeft.addEventListener('click', prevSlide);\r\n\r\ndocument.addEventListener('keydown', function (evento) {\r\n    console.log(evento)\r\n    if (evento.key === 'ArrowLeft') prevSlide();\r\n    if (evento.key === 'ArrowRight') nextSlide();\r\n});\r\n\r\ndotContainer.addEventListener('click', function (evento) {\r\n    if (evento.target.classList.contains('dots__dot')) {\r\n        const slide = evento.target.dataset.slide;  //const { slide } = e.target.dataset;\r\n        goToSlide(slide);\r\n        activateDot(slide);\r\n    }\r\n}); */\r\n\r\n/* //Proyecto 3: Mapty\r\n\r\n// Application architecture\r\nconst form = document.querySelector('.form');\r\nconst containerWorkouts = document.querySelector('.workouts');\r\nconst inputType = document.querySelector('.form__input--type');\r\nconst inputDistance = document.querySelector('.form__input--distance');\r\nconst inputDuration = document.querySelector('.form__input--duration');\r\nconst inputCadence = document.querySelector('.form__input--cadence');\r\nconst inputElevation = document.querySelector('.form__input--elevation');\r\n\r\n// Parent class and child classes\r\nclass Workout{ \r\n    // date = new Date(); //This line and the next one are the same as the line 549 amd 550.\r\n    // id = (Date.now() + \"\").slice(-10);  \r\n    // clicks = 0;\r\n\r\n    constructor(coords, distance, duration){\r\n        this.date = new Date();\r\n        this.id = (Date.now() + \"\").slice(-10);  //now() returns the number of milliseconds since midnight Jan 1, 1970\r\n        this.clicks = 0;\r\n        this.coords = coords;     // Must be an array [lat, lng]\r\n        this.distance = distance; // in km\r\n        this.duration = duration; // in min\r\n    }\r\n\r\n    _setDescription(){\r\n        const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\r\n        this.description = `${this.type[0].toUpperCase()}${this.type.slice(1)} on ${months[this.date.getMonth()]} ${this.date.getDate()}`;\r\n    }\r\n\r\n    _click(){\r\n        this.clicks++;\r\n    }\r\n}\r\n\r\nclass Running extends Workout{\r\n    type = \"running\"; //This property is gonna be available on all the instances\r\n    constructor(coords, distance, duration, cadence){\r\n        super(coords, distance, duration);\r\n        this.cadence = cadence;\r\n        this.calcPace();\r\n        this._setDescription(); //We can't use this method on the Workout object becuase the \"type\" variable is defined in the child classes. Through this the scope chain this constructor methid will get access to all the methods of the parent class, and of course, that includes the _setDescription() which is in the Workout class.\r\n    }\r\n\r\n    calcPace(){\r\n        this.pace = this.duration / this.distance;\r\n        return this.pace;\r\n    }\r\n}\r\n\r\nclass Cycling extends Workout{\r\n    type = \"cycling\"; //This property is gonna be available on all the instances\r\n    constructor(coords, distance, duration, elevationGain){\r\n        super(coords, distance, duration);\r\n        this.elevationGain = elevationGain;\r\n        this.calcSpeed();\r\n        this._setDescription(); //We can't use this method on the Workout object becuase the \"type\" variable is defined in the child classes. Through this the scope chain this constructor methid will get access to all the methods of the parent class, and of course, that includes the _setDescription() which is in the Workout class.\r\n    }\r\n\r\n    calcSpeed(){\r\n        this.speed = this.distance / (this.duration / 60);\r\n        return this.speed;\r\n    }\r\n}\r\n\r\nclass App{\r\n    //We're gonna define the map and mapEvent as properties of the object and will use a private class field. Now, both of the will become private instances properties which are gonna be present  on all the instances created through this class.\r\n    #map;\r\n    #mapZoomLevel = 13;\r\n    #mapEvent;\r\n    #workouts = [];\r\n\r\n    constructor(){\r\n        //Get user's position\r\n        this._getPosition();\r\n\r\n        //Get data from local storage\r\n        this._getLocalStorage();\r\n\r\n        //Atach event handlers\r\n        form.addEventListener(\"submit\", this._newWorkout.bind(this));  //When we have event listeners inside of a class, you'll have to bind the this keywords all the time. Because if not, this._newWorkout will only point to the form. So we always want our this keywords to still point to the object itself (in this case, the app object, which is what \"this\" is currently pointing to).\r\n        inputType.addEventListener(\"change\",this._toggleElevaionField); //In _toggleElevaionField there aren't any this keyword, so we can avoid using the bind() method in inputType.addEventListener\r\n        containerWorkouts.addEventListener('click', this._moveToPopup.bind(this));\r\n    }\r\n\r\n    _getPosition(){\r\n        if (navigator.geolocation){\r\n            navigator.geolocation.getCurrentPosition(  //First callback: It will be called on success.  Second callback: It will be called on error\r\n\r\n                //JS will callback the _loadMap function here and pass in the position argument as soon as the curent position of the user is determined. This method is called by getCurrentPosition(), and this._loadMap is treated as a regular funcion call NOT AS A METHOD CALL. So, since this._loadMap is a  callback function, we're not calling it ourselves, it is to getCurrentPosition function that we'll call the callback funcion once that it gets its  current position of the user. So, when it calls the _loadMap function, then it does so as a regular function call. And, in a regular function,  the this keyword is set to undefined. To fix that, we bind (bind will simply return a new function) this function and finally the this keyword into bind points  to the current object so that the this is also inside of _loadMap(position). Bind() used when you want 'this' keyword in the method you are calling to point to the object.\r\n                this._loadMap.bind(this), //First callback of getCurrentPosition. \r\n                function(){               //Second callback of getCurrentPosition. \r\n                alert(\"Coultn't get your position!\")\r\n            });\r\n            // console.dir(this._loadMap);\r\n        }; \r\n    }\r\n\r\n    _loadMap(position){ //The getCurrentPosition method passes the GeolocationPosition object to the callback. That's why we don't need to put any parameter in this._loadMap. Into getCurrentPosition we don't invoke _loadMap. We just pass function's name so, there is no any parentheses and parameters. \r\n        const {latitude} = position.coords;\r\n        const {longitude} = position.coords;\r\n        const coords = [latitude, longitude];\r\n\r\n        this.#map = L.map('map').setView(coords, this.#mapZoomLevel); //We use 'this.#map' and 'this.#mapEvent' because this is like a property that is defined on the object itself. It's no longer just a normal variable\r\n        \r\n        L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {\r\n            attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors'\r\n        }).addTo(this.#map);\r\n\r\n        this.#map.on(\"click\", this._showForm.bind(this));\r\n        this.#workouts.forEach(work => this._renderWorkoutMarker(work));\r\n\r\n        //console.log(position);\r\n        //console.log(latitude, longitude); \r\n        //console.log(`https://www.google.com.mx/maps/@${latitude},${longitude}`);\r\n        // console.log(map);\r\n    }\r\n\r\n    _showForm(mapE){\r\n        this.#mapEvent = mapE;\r\n        form.classList.remove(\"hidden\");\r\n        inputCadence.focus();\r\n    }\r\n\r\n    _hideForm(){\r\n        inputDistance.value = inputDuration.value = inputCadence.value = inputElevation.value = \"\";\r\n        form.style.display = \"none\";\r\n        form.classList.add(\"hidden\");\r\n        setTimeout(function(){\r\n            form.style.display = \"grid\";\r\n        }, 1000)\r\n    }\r\n    \r\n    _toggleElevaionField(){\r\n        inputElevation.closest('.form__row').classList.toggle(\"form__row--hidden\");\r\n        inputCadence.closest('.form__row').classList.toggle(\"form__row--hidden\");\r\n    }\r\n\r\n    _newWorkout(event){\r\n        event.preventDefault();\r\n\r\n        function validInputs(...inputs){\r\n            return inputs.every(inp => Number.isFinite(inp));\r\n        }\r\n\r\n        function allPositives(...inputs){\r\n            return inputs.every(inp => inp > 0);\r\n        }\r\n\r\n        //Get data from form\r\n        const type = inputType.value;\r\n        const distance = Number(inputDistance.value);\r\n        const duration = Number(inputDuration.value);\r\n        const {lat, lng} = this.#mapEvent.latlng;    // console.log(this.#mapEvent); console.log(lat, lng);\r\n        let workout;\r\n\r\n        //If workout rining, creat runing object\r\n        if (type === \"running\") {\r\n            const cadence = Number(inputCadence.value);\r\n\r\n            //Check if data is valid. (The reason why we did this cheking here inside of the parent if, is because if we did the same out of the if, then we would also want to check for the elevation. That's to say, only one of the cadence and elevation can be defined at the same time. They can't both be defined at the same time)\r\n            if(!validInputs(distance, duration, cadence) || !allPositives(distance, duration, cadence)){\r\n                return alert(\"Inputs have to be positive numbers!\"); \r\n            }\r\n\r\n            workout = new Running([lat, lng], distance, duration, cadence);\r\n        }\r\n\r\n        //If workout cycling, creat cycling object\r\n        if (type === \"cycling\") {\r\n            const elevation = Number(inputElevation.value);\r\n\r\n            //Check if data is valid. (The reason why we did this cheking here inside of the parent if, is because if we did the same out of the if, then we would also want to check for the elevation. That's to say, only one of the cadence and elevation can be defined at the same time. They can't both be defined at the same time)\r\n            if(!validInputs(distance, duration, elevation) || !allPositives(distance, duration)){\r\n                return alert(\"Inputs have to be positive numbers!\"); \r\n            }\r\n\r\n            workout = new Cycling([lat, lng], distance, duration, elevation);\r\n        }\r\n\r\n        //Add new object to workout array\r\n        this.#workouts.push(workout);      console.log(workout);\r\n\r\n        //Render workout on map as marker\r\n        this._renderWorkoutMarker(workout);\r\n\r\n        //Render workout on list\r\n        this._renderWorkout(workout);\r\n\r\n        //Hide form + clear input fields\r\n        this._hideForm();\r\n\r\n        //Set local storage to all workouts\r\n        this._setLocalStorage();\r\n    }\r\n\r\n    _renderWorkoutMarker(workout){\r\n        L.marker(workout.coords)\r\n        .addTo(this.#map) //There's no need to use the this keyword in this line because we're already using it in the \"render workout on map as marker\" line as a method of the this keyword. Besides that, we're calling it ourselves, so it's not a callback funcion of any other funcion in JS. And so therefore, the this keyword in this method here, will still be the current object. And so, no need to using bind in this case.\r\n        .bindPopup(L.popup({\r\n            maxWidth: 250,\r\n            minWidth: 100,\r\n            autoClose: false,\r\n            closeOnClick: false,\r\n            className: `${workout.type}-popup`\r\n        }))\r\n        .setPopupContent(`${workout.type === \"running\" ? \"🏃‍♂️\" : \"🚴‍♀️\"} ${workout.description}`)\r\n        .openPopup()\r\n    }\r\n\r\n    _renderWorkout(workout){\r\n        let html = `\r\n            <li class=\"workout workout--${workout.type}\" data-id=\"${workout.id}\">\r\n            <h2 class=\"workout__title\">${workout.description}</h2>\r\n            <div class=\"workout__details\">\r\n                <span class=\"workout__icon\">${workout.type === \"running\" ? \"🏃‍♂️\" : \"🚴‍♀️\"}</span>\r\n                <span class=\"workout__value\">${workout.distance}</span>\r\n                <span class=\"workout__unit\">km</span>\r\n            </div>\r\n    \r\n            <div class=\"workout__details\">\r\n                <span class=\"workout__icon\">⏱</span>\r\n                <span class=\"workout__value\">${workout.duration}</span>\r\n                <span class=\"workout__unit\">min</span>\r\n            </div>\r\n        `;\r\n\r\n        if(workout.type === 'running'){\r\n            html += `\r\n                    <div class=\"workout__details\">\r\n                        <span class=\"workout__icon\">⚡️</span>\r\n                        <span class=\"workout__value\">${workout.pace.toFixed(1)}</span>\r\n                        <span class=\"workout__unit\">min/km</span>\r\n                    </div>\r\n                    <div class=\"workout__details\">\r\n                        <span class=\"workout__icon\">🦶🏼</span>\r\n                        <span class=\"workout__value\">${workout.cadence}</span>\r\n                        <span class=\"workout__unit\">spm</span>\r\n                    </div>\r\n                </li>\r\n            `;\r\n        }\r\n        if(workout.type === 'cycling'){\r\n            html += `\r\n                    <div class=\"workout__details\">\r\n                        <span class=\"workout__icon\">⚡️</span>\r\n                        <span class=\"workout__value\">${workout.speed.toFixed(1)}</span>\r\n                        <span class=\"workout__unit\">km/h</span>\r\n                    </div>\r\n                    <div class=\"workout__details\">\r\n                        <span class=\"workout__icon\">⛰</span>\r\n                        <span class=\"workout__value\">${workout.elevationGain}</span>\r\n                        <span class=\"workout__unit\">m</span>\r\n                    </div>\r\n                </li>\r\n            `;\r\n        }\r\n        \r\n        form.insertAdjacentHTML('afterend', html);\r\n    }\r\n\r\n    _moveToPopup(event){\r\n        const workoutEl = event.target.closest(\".workout\");   // console.log(workoutEl);\r\n\r\n        if (!workoutEl) return;\r\n\r\n        const workout = this.#workouts.find(event => event.id === workoutEl.dataset.id);      console.log(workoutEl.dataset.id);\r\n        this.#map.setView(workout.coords, this.#mapZoomLevel, {\r\n            animate: true, \r\n            pan: {duration: 1}\r\n        });\r\n        \r\n        // workout._click(); // using the public interface\r\n    }\r\n\r\n    _setLocalStorage(){\r\n        localStorage.setItem(\"workouts\", JSON.stringify(this.#workouts));\r\n    }\r\n\r\n    _getLocalStorage(){\r\n        const data = JSON.parse(localStorage.getItem('workouts'));\r\n        console.log(data);\r\n\r\n        if(!data) return;\r\n\r\n        this.#workouts = data; //This method will be executed right at the begining. And data will always start with an empty array with that will be stored in this.#workouts\r\n        this.#workouts.forEach(work => this._renderWorkout(work)); //We ise _renderWorkout instead of _renderWorkoutMarker because once our page is reloaded right at the beginning, the #map in the _renderWorkoutMarker is not yed defined. So, that's why we get an error. On the other hand, the method _renderWorkout doesn't have this variable (#map).\r\n\r\n        //When we convert our objects to a string and then back to a script from object, we lose the prototype chain. So, the new objects that we recover from the local storage are now regular objects. They're now no longer objects that were created by the running class or by the cycling class. And therefore, they won't be able to inherit any of their methods.\r\n    }\r\n\r\n    _reset(){\r\n        localStorage.removeItem(\"workouts\");\r\n        location.reload(); //location is basically a big object that contains a lot of methods and properties in the browser. \r\n    }\r\n    \r\n}\r\n\r\nconst app = new App();   \r\n// console.log(app); */\r\n\r\n//         $$$$$$$$$$$$$$$ Funciones $$$$$$$$$$$$$$$\r\n\r\n\r\n/* //Ejemplo 1: Definicion de mi funcion\r\nfunction saludar (){\r\n    console.log(\"--> Hola !!\");\r\n}\r\n\r\n //Ejemplo 2: Llamado de mi funcion\r\nfor (let index = 0; index < 6; index++) {\r\n    saludar();\r\n} */\r\n\r\n/* //Ejemplo 2: Definicion de mi funcion\r\n\r\nfunction pedirNombre(){\r\n    let nombreIngresado = prompt(\"Ingresar nombre\");\r\n    console.log(\"El nombre es: \"+ nombreIngresado);\r\n}\r\n\r\npedirNombre(); */\r\n\r\n/* //Ejemplo 3: Como crear una funcion si necesito reiterar varias veces su funcionalidad\r\n\r\nfunction pedirNombre(){\r\n    let index = 0;\r\n    let cantidad = 3;\r\n\r\n    for (index; index < cantidad; index++) {\r\n        let nombreIngresado = prompt(\"Ingresar nombre\");\r\n        alert(\"El nombre es: \"+ nombreIngresado);\r\n    }\r\n}\r\n\r\npedirNombre(); */\r\n\r\n/* //Ejemplo 4: Creacion de una funcion que recibe parametros\r\nfunction verParametros(p1,p2){\r\n    let res = p1 - p2;\r\n    console.log(\"La resta es: \".concat(res));\r\n}\r\n\r\nlet variable1 = parseFloat(prompt(\"Ingrese el valor de la variable 1: \"));\r\nlet variable2 = parseFloat(prompt(\"Ingrese el valor de la variable 2: \"));\r\n\r\nverParametros(variable1, variable2); */\r\n\r\n/* //Ejemplo 5: Creacion de una funcion que recibe parametros, esta calcula una resta aritmetica y devuelve su valor.\r\nfunction resta(p1,p2){\r\n    let res = p1 - p2;\r\n    return res;\r\n}\r\n\r\nlet variable1 = parseFloat(prompt(\"Ingrese el valor de la variable 1: \"));\r\nlet variable2 = parseFloat(prompt(\"Ingrese el valor de la variable 2: \"));\r\n\r\n//let res = verParametros(variable1, variable2);\r\n//console.log(\"El resultado es: \" + res);\r\n\r\nconsole.log(\"El resultado es: \" + resta(variable1, variable2)); */\r\n\r\n/* //Ejemplo 6: Uso de una funcion para validar una contrasena.\r\n\r\nfunction passwordValidation(password, repeatPassword)\r\n{\r\n    if (password == \"\" || repeatPassword) \r\n    {\r\n        console.log(\"Las contrasenas deben contener caracteres.\");\r\n    }\r\n\r\n    if (password != repeatPassword) ;\r\n    {\r\n        console.log(\"Las contrasenas ingresadas no son iguales.\");\r\n    }\r\n\r\n    if (password.length < 8);\r\n    {\r\n        console.log(\"La contrasena debe tener al menos 8 caracteres.\");\r\n    }\r\n\r\n    if (password.length > 15);\r\n    {\r\n        console.log(\"La contrasena no debe tener mas de 15 caracteres.\");\r\n    }\r\n} \r\n\r\npasswordValidation(\"123\", \"pass\"); */\r\n\r\n/* //Ejemplo 7: Uso del ambito de varaibles para cambiar el valor de variables globales\r\nlet res = 0;\r\nfunction suma(num1, num2){\r\n    res = num1 + num2;\r\n}\r\nsuma(5,6);\r\nconsole.log(res); */\r\n\r\n/* //Ejemplo 8: Uso del ambito de varaibles para cambiar el valor de variables locales\r\nlet res = \"\"; //let resultado = undefined; let resultado = null;\r\nfunction suma(num1, num2)\r\n{\r\n    let res = num1 + num2;\r\n    return res; \r\n}\r\nres = suma(5,6);\r\nconsole.log(res); */\r\n\r\n/* //Ejemplo 9: Creacion de variables anonimas y su uso.\r\n\r\nconst sum = function(a,b)\r\n{\r\n    return a + b;\r\n};\r\n\r\nconst res = function(a,b)\r\n{\r\n    return a - b;\r\n};\r\n\r\nconsole.log( sum(15,20) );\r\nconsole.log( res(15,5) ); */\r\n\r\n/* //Ejemplo 10: Uso de finiciones flecha (Si es una funcion de una sola linea con retorno podemos evitar escribir el cuerpo.)\r\n\r\nconst add = (a, b) => {return a + b}; //Metodo 1 para utilizar flecha \r\nconst subs = (a, b) => a - b;         //Metodo 2 para utilizar flecha\r\n\r\nconsole.log( add(15,20));\r\nconsole.log( subs(20,5));\r\n\r\n//Ejemplo de practica - Si una funci�n es una sola l�nea con retorno y un par�metro puede evitar escribir los ().\r\n\r\nconst suma = (a,b) => a + b;\r\nconst resta = (a,b) => a - b;\r\nconst iva = x => x * 0.21;\r\n\r\nlet precioProducto = 500;\r\nlet descuento = 50;\r\n\r\nlet nuevoPrecio = resta( suma(precioProducto, iva(precioProducto)), descuento );\r\nconsole.log(nuevoPrecio); */\r\n\r\n\r\n//         $$$$$$$$$$$$$$$ Funciones de orde superior $$$$$$$$$$$$$$$\r\n\r\n\r\n/* //Ejemplo 1: Desarrollo de una funcion para conseguir la abstraccion de la suma consecutiva de numeros dentro de un rango.\r\n\r\nlet total = 0;\r\nfunction sumarRango(inicio, fin){\r\n    for (let i = inicio; i <= fin; i++) {\r\n        total += i;\r\n    }\r\n    return total;\r\n}\r\nconsole.log( sumarRango(1, 100) ) \r\nconsole.log(\"La suma total de 1 hasta 10 es: \"+ total.toString()); */\r\n\r\n/* //Ejemplo 2: Retorno de funciones y concepto sobre funciones con un esquema superior\r\nfunction mayorQue(n) {\r\n    return (m) => m > n\r\n}\r\n\r\n// Retorna    (m) => m>17     y nos queda     mayorDeEdad = (m) => m>17    donde (m) contendra el valor que le mandaremos desde la linea 28. En este caso, ahora la variable\r\n// mayorDeEdad se convertira en una funcion, en la cual (m) sera el parametro al que le llegara el valor enviado desde la linea 32, que es 5.\r\nlet mayorDeEdad = mayorQue(17); \r\n\r\n// Como tenemos que \\ mayorDeEdad = (m) => m>17 /. Entonces nos damos cuenta que en la funcion ahora tenemos el parametro (m) y no (n) como en la primera funcion, por lo que \r\n//ahora desde la linea 32 mandamos un 5, que se almacenara en ese variable (m) y obtendremos que  5>17, lo que resulta como un valor booleano, que se almacena en \"res\".\r\nlet numero = parseInt(5); \r\nlet res = mayorDeEdad(numero); \r\n\r\nif (res) {\r\n    console.log(\"El numero \"+ numero+ \" es mayor que 17.\"+ mayorDeEdad);\r\n}else{\r\n    console.log(\"El numero \"+ numero+ \" NO es mayor que 17.\"+ mayorDeEdad);\r\n} */\r\n\r\n/* //Ejemplo 3: Aplicacion de una funcion en CALL STACK\r\nfunction multiply (x, y) {\r\n return x * y;\r\n}\r\nfunction printSquare (x) {\r\n    let s = multiply(x,x);\r\n    console.log(s);\r\n}\r\n\r\nprintSquare(5); */\r\n\r\n/* //Ejemplo 4: Retorno de funciones con un if.\r\nfunction asignarOperacion (op) {\r\n    if (op == \"sumar\") {\r\n        return (a, b) => a + b\r\n    }else if (op == \"restar\") {\r\n        return (a, b) => a - b\r\n    }\r\n}\r\nlet suma = asignarOperacion (\"sumar\")\r\nlet resta = asignarOperacion (\"restar\")\r\nconsole.log( suma(4, 6) ) // 10\r\nconsole.log( resta(5, 3) ) // 2 */\r\n\r\n/* //Ejemplo 5: Como podemos pasar por parametro una funcion (funcionalidad)\r\nfunction porCadaElemento(elementos, funcionalidad){\r\n    for (const unElemento of elementos) {\r\n        funcionalidad(unElemento);\r\n    }\r\n}\r\n\r\nfunction acumular(numero){\r\n    total += numero;\r\n}\r\n\r\nlet total = 0;\r\nlet numeros = [10, 20, 30, 40, 50];\r\nporCadaElemento(numeros, console.log);\r\nporCadaElemento(numeros, acumular);\r\nconsole.log(\"El valor total de la suma de los elementos de \"+ numeros.toString()+ \" es: \"+ total+\".\"); */\r\n\r\n/* // Ejemplo 6.1: Default Parameters\r\nconst bookings = [];\r\n\r\nconst createBooking = function( flightNum, numPassengers = 1, price = (199*numPassengers) ){\r\n    \r\n    // Metodo utilizado en ES5 para establecer un valor inicial a esos parametros\r\n    // numPassengers = numPassengers || 1;\r\n    // price = price || 199\r\n    const booking = {\r\n        flightNum,\r\n        numPassengers,\r\n        price\r\n    };\r\n    console.log(booking);\r\n    bookings.push(booking);\r\n}\r\n\r\ncreateBooking(\"LH123\");\r\ncreateBooking(\"LH123\", 2, 800);\r\ncreateBooking(\"LH123\", 5);\r\ncreateBooking(\"LH123\", undefined, 1000); */\r\n\r\n/* // Ejemplo 6.2: How Passing Arguments Works: Value vs Reference\r\nconst flight = 'LH234';\r\nconst jonas = {name: 'Jonas Schmedtmann', passport: 24739479284};\r\n\r\nconst checkIn = function (flightNum, passenger) {\r\n    flightNum = 'LH999';\r\n    passenger.name = 'Mr. ' + passenger.name;\r\n\r\n    if (passenger.passport === 24739479284) {\r\n        console.log('Checked in');\r\n    } else {\r\n        console.log('Wrong passport!');\r\n    }\r\n};\r\n\r\ncheckIn(flight, jonas);\r\n// console.log(flight);\r\n// console.log(jonas); //When we try to copy an object, we're really only copying the reference to that object in the memory heap. They are both the same object in the memory heap\r\n\r\nconst newPassport = function(person){\r\n    person.passport = Math.trunc(Math.random()*10000000000)\r\n}\r\n\r\nnewPassport(jonas);\r\ncheckIn(flight, jonas); */\r\n\r\n/* // Ejemplo 6.3: Functions Accepting Callback Functions\r\nconst oneWord = function (str) {\r\n    const res = str.replace('/ /g', '').toLowerCase(); //     / /g sirve para capturar todos los elementos globales y no solamente 1. En este casi, queremos todos los espacios en blanco, y si no usamos esto, unicamente obtendremos el primer espacio en blanco.\r\n    return res;\r\n};\r\n\r\nconst upperFirstWord = function (str) {\r\n    const [first, ...others] = str.split(' '); //El string tiene 4 palabras. Capturamos la 1era palabra con first, y las otras 3 las capturamos en una variable desestructurada (others), la cual devolvera un nuevo array con las 3 palabras restantes.\r\n    const res = [first.toUpperCase(), ...others].join(' '); //Convertimos las letras de la 1era palabra a mayusculas, y a esa palabra, le unimos con ayuda del join(), las otras 3 que estan en el array generado con el split().\r\n    return res;\r\n};\r\n\r\n// Higher-order function\r\nconst transformer = function (str, fn) {\r\n    console.log(`Original string: ${str}`);\r\n    console.log(`Transformed string: ${fn(str)}`);\r\n    console.log(`Transformed by: ${fn.name}`);\r\n};\r\n\r\ntransformer('JavaScript is the best!', upperFirstWord);\r\ntransformer('JavaScript is the best!', oneWord);\r\n\r\nconst high5 = function () {\r\n    console.log('👋');\r\n};\r\ndocument.body.addEventListener('click', high5);\r\n['Jonas', 'Martha', 'Adam'].forEach(high5); */\r\n\r\n/* // Ejemplo 6.4: Functions Returning Functions\r\nconst greet = function (greeting) {\r\n\r\n    return function (name) {\r\n        console.log(`${greeting} ${name}`);\r\n    };\r\n};\r\n\r\n//Llamamos a la funcion greet y le mandamos \"hey\". Despues, esta funcion retorna otra funcion que se almacena en greeterHey. Entonces, cuando en la linea de abajo volvemos a llamar a la funcion greeterHey, ahora ejecutaremos la funcion pero que esta almacenada en esta variable. O sea, la funcion del return.\r\nconst greeterHey = greet('Hey');\r\ngreeterHey('there');\r\ngreet('Hey')('there'); //Esto es lo mismo que las dos lineas de arriba.\r\n\r\n// Esto es lo mismo que el procedimiento de arriba pero con arrow functions.\r\nconst greetArr = greeting => name => console.log(`${greeting} ${name}`);\r\ngreetArr('Hey')('there'); */\r\n\r\n/* // Ejemplo 6.5: The call(), apply() and bind() Methods\r\nconst lufthansa = {airline: 'Lufthansa',iataCode: 'LH',bookings: [],\r\n    book: function(flightNum, name) {\r\n        console.log(`${name} booked a seat on ${this.airline} flight ${this.iataCode}${flightNum}`);\r\n        this.bookings.push({ flight: `${this.iataCode}${flightNum}`, name });\r\n    }\r\n};\r\n\r\nconst eurowings = {airline: 'Eurowings',iataCode: 'EW',bookings: []};\r\nconst swiss = {airline: 'Swiss Air Lines',iataCode: 'LX',bookings: []};\r\n\r\nlufthansa.book(239, 'Jonas Schmedtmann');\r\nlufthansa.book(635, 'John Smith');\r\nconsole.log(lufthansa);\r\n\r\n// Call method: You can write a method that can be used on different objects. It takes arguments separately. No recive una lista de argumentos despues del this. Permitira que la palabra recerbada this apunte a eurowings.\r\nconst book = lufthansa.book; //Al hacer esto, ahora la funcion (metodo) del objeto lufthansa pasa a ser una funcion global, por lo que, no pudemos utilizarla asi nada mas y mandarle valores ya que esta funcion tiene \"this\", los cuales pertenecian al objeto lufthansa.\r\nbook.call(eurowings, 23, 'German mancilla'); \r\nbook.call(lufthansa, 514, 'Chavez german');\r\n// book(23, \"res\"); Esto NO funciona\r\n\r\n// Apply method: You can write a method that can be used on different objects. It takes arguments as an array.\r\nconst flightData = [583, 'George Cooper'];\r\nbook.apply(swiss, flightData);\r\nbook.call(swiss, ...flightData);\r\nconsole.log(swiss);\r\n\r\n\r\n\r\nconst bookEW = book.bind(eurowings); // Bind method: Allows us to manually set \"this\" for any function call. With the bind() method, an object can borrow a method from another object.\r\nbookEW(23, \"German Mancilla Chavez\");\r\n\r\nconst bookEWX = book.bind(eurowings, 23);\r\nbookEWX(\"German Mancilla Chavez\");\r\n\r\n// Bind method with eventListener:\r\nlufthansa.planes = 300;             // Agregamos una nueva propiedad a lufthansa\r\nlufthansa.buyPlane = function () {  // Agregamos un nuevo metodo a lufthansa\r\n    this.planes++;                  // Ponemos el this para representar o llamar al objeto que dicha función está modificando.\r\n    console.log(this);\r\n    console.log(this.planes);\r\n};                                  // lufthansa.buyPlane(); Esto despliega exacamente lo que queremos ver una vez que precionamos el boton del addEventListener().\r\n\r\n//Al hacer esto, entonces decimos que, al hacer click, el console.log(this); retornara el boton. La razon de esto es porque en un event handler function, el \"this\" siempre \r\n//apunta al elemento donde se adjunta el handler. Por lo tanto, lufthansa.buyPlane es el handler function, y esta adjunto a la parte del querySelector, que seria el \r\n//elemento padre. Por eso, el console.log(this), muestra el elemento del boton. Ahora bien, en el handler function, necesitamos que el this de lufthansa.buyPlane apunte\r\n//objeto de lufthansa, y no a la parte del querySelector. Para ello, tenemos que definirlo ahi mismo como se muestra en la linea que le sigue, y la manera de hacerlo es pasarle\r\n//la funcion (bind) y no llamarla (call) porque el bind nos retornara una nueva funcion. Y finalmente, ahora el this apuntara a lufthansa y NO al boton del querySelector\r\ndocument.querySelector('.buy').addEventListener('click', lufthansa.buyPlane);\r\ndocument.querySelector('.buy').addEventListener('click', lufthansa.buyPlane.bind(lufthansa));\r\n\r\n\r\n// Dos formas de devolver una funcion utilizando bind() y de la forma tradicional (devolviendo una funcion dentro de otra).\r\nfunction addTax (rate, value){\r\n    let res = value + value * rate;\r\n    return res;\r\n};\r\n\r\nconst addVAT = addTax.bind(null, 0.23); //Con el bind() obtendremos una nueva funcion\r\nconsole.log(\"The result of addVAT is: \"+ addVAT(100));\r\n\r\nconst addTaxRate = function (rate) {\r\n    return function (value) {\r\n        return value + value * rate;\r\n    };\r\n};\r\nconst addVAT2 = addTaxRate(0.23);\r\nconsole.log(\"The result of addVAT is: \"+addVAT2(100)); */\r\n\r\n/* // Ejemplo 6.6: Excercise with functions\r\n// A poll has a question, an array of options from which people can choose, and an array with the number of replies for each option. This data is stored in the starter 'poll' object below. Your tasks:\r\n// 1. Create a method called 'registerNewAnswer' on the 'poll' object. The method does 2 things:\r\n// 1.1. Display a prompt window for the user to input the number of the selected option. The prompt should look like this: \r\n// What is your favourite programming language?\r\n// 0: JavaScript\r\n// 1: Python\r\n// 2: Rust\r\n// 3: C++\r\n// (Write option number)\r\n\r\n// 1.2. Based on the input number, update the 'answers' array property. For example, if the option is 3, increase the value at position 3 of the array by one (1). Make sure \r\n// to check if the input is a number and if the number makes sense (e.g. answer 52 wouldn't make sense, right?)\r\n// 2. Call this method whenever the user clicks the \"Answer poll\" button.\r\n// 3. Create a method 'displayResults' which displays the poll results. The method takes a string as an input (called 'type'), which can be either 'string' or 'array'. If type is \r\n// 'array', simply display the results array as it is, using cl(). This should be the default option. If type is 'string', display a string like \"Poll results are 13, 2, 4, 1\".\r\n// 4. Run the 'displayResults' method at the end of each 'registerNewAnswer' method call.\r\n// 5. Use the 'displayResults' method to display the 2 arrays in the test data. Use both the 'array' and the 'string' option. Do not put the arrays in the poll object!\r\n\r\n// Test data for bonus: Data 1: [5, 2, 3]\r\n\r\nconst poll = {\r\n    question: \"What is your favourite programming language?\",\r\n    options: [\"0: JavaScript\", \"1: Python\", \"2: Rust\", \"3: C++\"], // This generates [0, 0, 0, 0]. More in the next section!\r\n    answers: new Array(4).fill(0),\r\n\r\n    registerNewAnswer(){ // (1)\r\n        const res = Number(prompt(`${this.question}\\n${this.options.join(\"\\n\")}\\n (Write option number)`)); // (1.1)\r\n        typeof res === \"number\" && res < this.answers.length && this.answers[res]++; // (1.2) Si el primer if es verdadero, pasamos al siguiente, pero cuando lleguemos a un false, se corta el condicional (&& representa un if)\r\n        console.log(\"Imprimos el objeto: \", poll);\r\n        console.log(\"Imprimos el arreglo: \", this.answers);\r\n        console.log(\"Imprimos el num seleccionado: \", res);\r\n\r\n        this.displayResults();         //(4)\r\n        this.displayResults(\"array\");  //(4)\r\n        this.displayResults(\"string\"); //(4) \r\n    },\r\n    \r\n    displayResults(type = \"array\"){  //(3)\r\n        if(type === \"array\"){\r\n            console.log(\"Imprimimos el array con los valores\", this.answers);\r\n        }else if(type === \"string\"){\r\n            console.log(`Poll results are ${this.answers.join(\", \")}`);\r\n        }\r\n    }\r\n};\r\n\r\ndocument.querySelector(\".poll\").addEventListener(\"click\", poll.registerNewAnswer.bind(poll)) //(2)\r\n\r\n//Usamos call() porque necesitamos un nuevo this. Es decir, usar la funcion de un objeto en otro. Despues, como this.answers necesita apuntar a otra direccion (ya que ahora \r\n//esta fuera de poll), dentro de los parentesis de call creamos y le pasamos un objeto con el mismo nombre (ya que sino aparece como undefined) y a ese objeto le añadimos el nuevo array \r\n//que queremos. Asi mismo, le pasamos un argumento para que se pueda ejecutar el condicional.\r\npoll.displayResults.call({answers: [5, 2, 3]}, \"string\"); // (5) */\r\n\r\n/* // Ejemplo 6.7: Immediately Invoked Function Expressions (IIFE)\r\n//Se usa cuando queremos una funcion que se utilice de inmediato una vez, que no sea necesario guardarla ni darle yn nombre, y que finalmente desaparezca para no volverla a usar\r\n\r\nconst runOnce = function(){\r\n    console.log(\"This will never run again\");\r\n};\r\nrunOnce();\r\n\r\n(function(){ //Transformamos la declaracion que tenemos arriba, en una expresion.\r\n    console.log(\"This will never run again\");\r\n})(); */\r\n\r\n/* // Ejemplo 6.8: Closures\r\nconst secureBooking = function () {\r\n    let passengerCount = 0;\r\n\r\n    return function () {//Al momento de retornar esta funcion (hija), se tiene acceso a sus elementos o variables del padre. Em este caso, passengerCount, que es un global scope.\r\n        passengerCount++;\r\n        console.log(`${passengerCount} passengers`);\r\n    };\r\n};\r\n\r\nconst booker = secureBooking();\r\nbooker();\r\nbooker();\r\nbooker();\r\n\r\nconsole.dir(booker); */\r\n\r\n/* // Ejemplo 6.9: More Closure Examples\r\n\r\n//Example 1\r\nlet f; //Creamos una variable global que almacenara una funcion\r\nconst g = function () {\r\n    const a = 23; //closure\r\n    f = function () { //Podemos utilizar esta funcion repetidas ocaciones\r\n        console.log(a * 2);\r\n    };\r\n};\r\n\r\nconst h = function () {\r\n    const b = 777; //closure\r\n    f = function () {\r\n        console.log(b * 2);\r\n    };\r\n};\r\n\r\n//Para poder acceder a f no podemos simplemente llamar a esa fucnion, ya que JS no la va a reconocer. Es decir, primero tenemos que llamar a su elemento padre y despues acceder a ella. En este caso, g y posteriormente h, son los padres de f.\r\ng();\r\nf();\r\nconsole.dir(f);\r\n\r\nh();\r\nf();\r\nconsole.dir(f);\r\n\r\n//Example 2\r\nconst boardPassengers = function (n, wait) {\r\n    const perGroup = n / 3;\r\n\r\n    setTimeout(function () { //setTimeout necesita de dos parametros, en este caso usaremos una funcion y el otro debe ser el tiempo.\r\n        console.log(`We are now boarding all ${n} passengers`);\r\n        console.log(`There are 3 groups, each with ${perGroup} passengers`);\r\n    }, wait * 1000);\r\n\r\n    console.log(`Will start boarding in ${wait} seconds`);\r\n};\r\n\r\nconst perGroup = 1000; //Si fijamos un valor en perGroup como variable global, de igual manera no se vera reflejado en el console.log porque al llamar la funcion, ejecutara la variable perGroup, la cual pisara a la que primero se creo con el valor de 1000.\r\nboardPassengers(180, 3);\r\n\r\n\r\n//Example 3\r\n// Take the IIFE below and at the end of the function, attach an event listener that changes the color of the selected h1 element ('header') to blue, each time the body element \r\n// is clicked. Do not select the h1 element again. Think about when exactly the callback function is executed, and what that means for the variables involved in this example.\r\n\r\n(function () {\r\n    const header = document.querySelector('h1');\r\n    header.style.color = 'red';\r\n\r\n    document.querySelector('body').addEventListener(\"click\", function(){\r\n        header.style.color = 'blue';\r\n    });\r\n})();  */\r\n\r\n\r\n//         $$$$$$$$$$$$$$$ Objetos $$$$$$$$$$$$$$$\r\n\r\n\r\n/* // Ejemplo 1: Definicion de caracteristicas para un objeto y como podemos ver los datos dentro del objeto\r\nlet unPaciente = {DNI: \"11222333\", apellidos: \"Mancilla\", nombre: \"German\", edad: 36, altura: 170, peso: 72, generoBiologico: \"Masculino\", tipoSangre: \"A+\"};\r\nconsole.log(\"El objeto contiene estos datos: \", unPaciente);\r\nconsole.log(\"El paciente se llama: \", unPaciente.nombre);         //Forma 1 de seleccionar una variable de un objeto\r\nconsole.log(\"El paciente se apellida: \", unPaciente[\"apellidos\"]);//Forma 2 de seleccionar una variable de un objeto */\r\n\r\n/* // Elemplo 2: Aignacion de valores\r\nlet unPaciente = {DNI: \"11222333\", apellidos: \"Mancilla\", nombre: \"German\", edad: 36, altura: 170, peso: 72, generoBiologico: \"Masculino\", tipoSangre: \"A+\"};\r\nunPaciente.apellidos = \"res\";\r\nunPaciente.nombre = \"SS22\";\r\nunPaciente.DNI = 44555666;\r\nunPaciente[\"edad\"] = 33;\r\nconsole.log(\"Los datos actualizados son: \", unPaciente); */\r\n\r\n/* // Ejemplo 3: Definicion de un objeto sin datos definidos para sus propiedades.\r\nlet unPaciente = {DNI: undefined, apellidos: undefined, nombre: undefined, edad: undefined, altura: undefined, peso: undefined, generoBiologico: undefined, tipoSangre: undefined};\r\nunPaciente.apellidos = \"res\";\r\nunPaciente.nombre = \"SS22\";\r\nunPaciente.DNI = 44555666;\r\nunPaciente[\"edad\"] = 33;\r\nconsole.log(\"Los datos actualizados son: \", unPaciente); */\r\n\r\n/* // Ejemplo 4: Definicion de una funcion constructora para un objeto\r\nfunction paciente(DNI, apellidos, nombre, edad, altura, peso, generoBiologico, tipoSangre){\r\nthis.DNI = DNI;\r\nthis.apellidos = apellidos;\r\nthis.nombre = nombre;\r\nthis.edad = edad;\r\nthis.altura = altura; \r\nthis.peso = peso;\r\nthis.generoBiologico = generoBiologico;\r\nthis.tipoSangre = tipoSangre;\r\nthis.obraSocial = undefined;};\r\n\r\nlet paciente1 = new paciente(\"44555666\",\"Cosme\",\"Pricilla\",undefined,183,65,\"femenino\",undefined);\r\nconsole.log(\"Los datos actualizados son: \", paciente1); */\r\n\r\n/* // Ejemplo 5: Ejemplo de aplicacion de metodos de un objeto\r\nfunction producto(nombre, precio, cantidad){\r\n    //propiedades\r\n    this.nombre = nombre;\r\n    this.precio = parseFloat(precio);\r\n    this.cantidad = parseInt(cantidad);\r\n    this.hayInventario = !!parseInt(cantidad); //this.hayInvenatrio = hayInventario; (ambas son correctas)\r\n    \r\n    //. !parseInt(cantidad) --> es un valor booleano, si el n�mero es 10, se convierte en false, si es 0 se convierte en true.\r\n    //   Pero nosotros necesitamos el valor equivalente real, si ingres� 10 quiero que sea true, si ingres� 0 quiero que sea false. Por ello es que agregamos dos negaciones !!\r\n    //. !!parseInt(cantidad) --> lo que conseguimos con la !! es consegui el inverso de un elemento inverso. O sea, el valor booleano true de un elemento.\r\n    //   Podemos definir un par�metro como (hayInventario) y en este pasar desde la funci�n constructora a partir de la palabra reservada new. Tener en cuenta que esta segunda opci�n nos \"obliga\" a manejar este dato y su valor durante la carga de los datos que el usuario indique.    \r\n    \r\n    //metodos\r\n    this.toString = function(){\r\n        return this.nombre;\r\n    };\r\n\r\n    this.Stock = (cantidadIncrementada) => {\r\n        return this.cantidad += this.cantidad + parseInt(cantidadIncrementada);\r\n    };\r\n\r\n    this.comprar = (cantidadComprada) => {\r\n        return this.cantidad -= parseInt(cantidadComprada);\r\n    };\r\n};\r\n\r\nlet nombre = \"Carne\";\r\nlet precio = \"200\";\r\nlet cantidad = \"5\";\r\nlet unProducto1 = new producto(nombre, precio, cantidad);\r\nconsole.log(\"Los valores que cargaste para el producto son: \", unProducto1); */\r\n\r\n/* // Ejemplo 6: Uso de las construcciones IN y FOR-IN\r\nfunction paciente(DNI, apellidos, nombre, edad){\r\nthis.DNI = DNI;\r\nthis.apellidos = apellidos;\r\nthis.nombre = nombre;\r\nthis.edad = edad;\r\n};\r\n\r\nlet paciente1 = new paciente(\"44555666\", \"Cosme\", \"Pricilla\", 24);\r\n\r\nconsole.log(\"Existe la propiedad DNI dentro del objeto?\", {resultado: \"DNI\" in paciente1});\r\n//console.log(\"Existe la propiedad DNI dentro del objeto?\", \"DNI\" in paciente1); //Esto es lo mismo que la linea de arriba\r\n\r\nconsole.log(\"Existe la propiedad obraSocial dentro del objeto?\", {resultado: \"obraSocial\" in paciente1});\r\n//console.log(\"Existe la propiedad obraSocial dentro del objeto?\", \"obraSocial\" in paciente1); //Esto es lo mismo que la linea de arriba\r\n\r\nfor(const iter in paciente1){ //Despues del const podemos poner cualquier nombre, el cual servira para iterar y buscar todas las propiedades del objeto.\r\n    console.log(\"La propiedad (\"+iter + \") tiene el valor de: \"+ paciente1[iter]);\r\n} */ \r\n\r\n/* // Ejemplo 7: Ejemplo practico con objetos y funciones \r\n\r\nconst jonas = {\r\n    firstName: 'Jonas',\r\n    lastName: 'Schmedtmann',\r\n    birthYeah: 1991,\r\n    job: 'teacher',\r\n    friends: ['Michael', 'Peter', 'Steven'],\r\n    hasDriversLicense: true,\r\n\r\n    calcAge0: function (birthYeah) {\r\n        return 2037 - birthYeah;\r\n    },\r\n\r\n    calcAge1: function () {\r\n        return 3000 - this.birthYeah;\r\n    },\r\n    \r\n    calcAge2: function () {\r\n        return this.age = 4000 - this.birthYeah;\r\n    },\r\n    getSummary: function () {\r\n        return `${this.firstName} is a ${this.calcAge2() - this.birthYeah}years old ${jonas.job}, and he has ${this.hasDriversLicense ? 'a' : 'no'} driver's license.`\r\n    //  return `${jonas.firstName} is a ${this.calcAge2()}-year old ${jonas.job}, and he has ${jonas.hasDriversLicense ? 'a' : 'no'} driver's license.`\r\n    }\r\n};\r\n\r\nconsole.log(jonas);\r\nconsole.log(\"res1: \",jonas.calcAge0(1991));\r\nconsole.log(\"res2: \",jonas.calcAge1());\r\nconsole.log(\"res3: \",jonas.calcAge2());\r\nconsole.log(\"res4: \",jonas.age);\r\nconsole.log(\"res5: \",jonas.getSummary()); \r\n\r\nconst measureKelvin = function () {\r\n    const measurement = {type: 'temp', unit: 'celsius', value: parseInt(100),};\r\n    console.table(measurement);\r\n    const kelvin = measurement.value + 273;\r\n    return kelvin;\r\n};\r\n\r\nconsole.log(measureKelvin()); */\r\n\r\n/* // Ejemplo 8: Definicion de una clase y uso de los metodos dentro de una clase\r\n\r\nclass producto{\r\n    //Metodo constructor de una clase\r\n    constructor(nombre, precio, cantidad){\r\n        this.nombre = nombre;\r\n        this.precio = parseFloat(precio);\r\n        this.cantidad = parseInt(cantidad);\r\n        this.hayInventario = !!parseInt(cantidad); //this.hayInvenatrio = hayInventario; (ambas son correctas)\r\n    };\r\n\r\n    //Metodos y funciones\r\n    nombreProducto() {\r\n        return this.nombre;\r\n    }\r\n\r\n    incrementarStock(cantidadIncrementada) {\r\n        this.cantidad = this.cantidad + parseInt(cantidadIncrementada);\r\n    }\r\n\r\n    comprar(cantidadComprada){\r\n        this.cantidad = this.cantidad - parseInt(cantidadComprada);\r\n    }\r\n}\r\n\r\nlet unProducto = new producto(\"Papa\", 400, 50);\r\nconsole.log(\"Los datos del producto son: \", unProducto);\r\nconsole.log(\"El nombre del producto es: \"+ unProducto.nombreProducto());\r\n\r\nunProducto.incrementarStock(10);\r\nconsole.log(\"Compre 10 kilos mas de papa y ahora tengo: \", unProducto);\r\nunProducto.comprar(40); \r\nconsole.log(\"Compre 40 kilos mas de papa y ahora tengo:\", unProducto); */\r\n\r\n/* // Ejemplo 9: Literales de objeto mejoradas\r\n\r\nconst weekdays = [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"];\r\n\r\nconst openingHours = {\r\n        [weekdays[3]]: {open: 12,close: 22,},\r\n        [weekdays[4]]: {open: 11,close: 23,},\r\n        [weekdays[5]]: {open: 0,close: 24,},\r\n    };\r\n\r\n    console.log(openingHours);\r\n\r\nconst restaurant = {\r\n    Name: 'Classico-Italiano',\r\n    location: 'Via Angelo Tavanti 23, Firenze, Italy',\r\n    categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],\r\n    starterMenu: ['Focaccia', 'Bruschetta', 'Garlic-Bread', 'Caprese-Salad'],\r\n    mainMenu: ['Pizza', 'Pasta', 'Risotto'],\r\n    info: [\r\n        {id: 1, nombre: \"german\"},\r\n        {id: 2, nombre: \"mancilla\"}\r\n    ],\r\n    fecharegistro: new Date(),\r\n    poseeTaarjetaCredito: false, \r\n    poseeVehiculo: true,\r\n\r\n    openingHours, //openingHours: openingHours,    Ambas son lo mismo\r\n\r\n    order(starterIndex, mainIndex){  //order: function(starterIndex, mainIndex){   Ambas son lo mismo\r\n        return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];\r\n    },\r\n\r\n    orderDelivery({time, address, mainIndex, starterIndex}){\r\n        return console.log(`Desestructuracion de un objecto usando funcion --> Order received! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`);\r\n    },\r\n\r\n    orderDeliveryX2({time=\"20:00\", address, mainIndex=0, starterIndex=1}){\r\n        return console.log(`Desestructuracion de un objecto usando funcion X2--> Order received! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`);\r\n    }\r\n}; */\r\n\r\n\r\n//         $$$$$$$$$$$$$$$ POO $$$$$$$$$$$$$$$\r\n\r\n\r\n/* //Ejemplo 1: Constructor Functions, the \"new\" and the \"this\" Operator (do this)\r\n\r\n// 1. New {} is created. We create a new instance (a new empty object) of the Person function.\r\n// 2. function is called, this = {}. The this keyword will be set to this newly created object. That's to say, the \"this\" keyword points to the new empty object.\r\n// 3. {} linked to prototype\r\n// 4. function automatically return {} that empty object from the constructor function \r\n\r\n// NEVER DO THIS!\r\n// function Person(firstName, birthYear) {\r\n//     this.firstName = firstName;\r\n//     this.birthYear = birthYear;\r\n\r\n//     this.calcAge = function () {\r\n//         console.log(2037 - this.birthYear);\r\n//     };\r\n// };\r\n\r\nfunction Person(firstName, birthYear) { //Constructor function\r\n    this.firstName = firstName;\r\n    this.birthYear = birthYear;\r\n};\r\n\r\nPerson.prototype.calcAge = function () { //We create a new calcAge method with the prototype keyword to the Person object. So, we can use this method on the german or karla object even though it isn't on the object itself. The reason why we create this method outsite the constructor function, is becuase when creating it inside, this method is added to all the object created. So, it's best to add this method to every object just when necessary.\r\n    console.log(\"My age is: \", 2037 - this.birthYear);\r\n}; \r\n\r\nconst german = new Person('German', 1991);\r\nconst karla = new Person('Karla', 2017);\r\n\r\ngerman.calcAge();\r\nkarla.calcAge();\r\n\r\nconsole.log(\"german is an instance of Person? \", german instanceof Person);\r\nconsole.log(german, karla);    //Although we created a new calcAge method in both objects, they don't contain this method but we have access to it because of prototypal inherencce.\r\n\r\n// Prototypal Inheritance on Built-In Objects\r\nconsole.log(\"Person.prototype \", Person.prototype); //\"prototype\" let you to add properties and methods to JavaScript objects (in this case, the Person object). All the objects that are created through this function constructor function (Person), will inherit. So they will get access to all the methods and properties that arre defined on this prototype property.\r\nconsole.log(\"german.__proto__ \", german.__proto__); //This is the prototype of german (not the prototype porperty) It is the same as: console.log(Person.prototype); \r\nconsole.log(german.__proto__.__proto__);            //It is the prototype property of object\r\nconsole.log(german.__proto__ === Person.prototype); //It's true because the prototype of the german object is essentially the prototype property of the constructor function. (Person.prototype is actually not the prototype of Person, but it is what's gonna be used as the prototype of all the objects that are created with the person constructor function. )\r\nconsole.dir(Person.prototype.constructor);\r\n\r\nconsole.log(Person.prototype.isPrototypeOf(german));\r\nconsole.log(Person.prototype.isPrototypeOf(Person));\r\n\r\nPerson.prototype.species = 'Homo Sapiens';\r\n\r\nconsole.log(german.species, karla.species);      //Both objects will inherit and will get access to this property from the prototype.\r\nconsole.log(german.hasOwnProperty('firstName')); //This is true because \"firstname\" was created directly in the constructor function\r\nconsole.log(german.hasOwnProperty('species'));   //This is false because the species property isn't directly in the object because of it's not its own property (the ones that are declared directly on the object itself, and not including the inherited properties).\r\n\r\n\r\nconst arr = [3, 6, 6, 5, 6, 9, 9]; //  new Array === []  whenever we create an array like this, it is indeed created by the array constructor.\r\nconsole.log(\"Array.prototype \", Array.prototype)\r\nconsole.log(\"arr.__proto__ \", arr.__proto__);\r\nconsole.log(arr.__proto__.__proto__);\r\nconsole.log(arr.__proto__ === Array.prototype); \r\n\r\nArray.prototype.unique = function () { //We create a new method (unique) into the object Array. Some methods like this are filter, some, map, etc.\r\n    return [...new Set(this)];\r\n};\r\n\r\nconsole.log(arr.unique()); //Seeing in the MDN documentation, we can realize that every method (function) when using arrays, have the following sintaxis: Array.prototype.map().\r\n\r\nconst h1 = document.querySelector('h1'); console.dir(h1)\r\nconsole.dir(function funciones(x){x + 1}); */\r\n\r\n/* //Ejemplo 2: classes, Setters and Getters (assessors properties), static method and Object.create\r\n\r\n//We need to create a constructor function. Whenever we create a new object (like a new instance using the new operator), this constructor will automatically be called.\r\nclass PersonCl{\r\n    constructor(fullName, birthYear){ \r\n        this.fullName = fullName;\r\n        this.birthYear = birthYear;\r\n    }; \r\n\r\n    //Instance methods (Methods will be added to .prototype property and all instances can have access to them)\r\n    calgAge(){ //All the methods that we write in the class (outside of the constructor), will be on the prototype on the object and not on the objects themselves.\r\n        console.log(\"calgAge: \", 2037 - this.birthYear);\r\n    };\r\n\r\n    greet(){\r\n        console.log(`greet:  ${this._fullName}`)\r\n    }\r\n\r\n    get age(){\r\n        return `age: ${2037 - this.birthYear}`;\r\n    }\r\n    \r\n    //Set a property that already exists.\r\n    set fullName(name){ \r\n        //We're creating a setter for a property name that does already exists. So, fullName is already a property to set in the constructor function, but then we also have a \r\n        //setter here. Now what's gonna happen is that each time the constructor function is executed, so whenever we set the fullName on the this keyword, then actually the \r\n        //method (set fullName) is gonna be executed. And, that name that we pass in as fullName (German mancilla) will then become this name.\r\n        //Now, When we're using setters which is trying to set a property that already exists, both the setter function here and the construction function have the exact same \r\n        //property name (fullName), and will get an error. So, to fix that, we need to create a new property name, that's to say, \"fullName\" must be a different name.\r\n        //Having done so, then the \"fullName\" property in the object german won't exists, but the \"_fillname\" property will. If we aren't going to setter for a property name \r\n        //that does already exists, then there's no need to change the name of this variable.\r\n        console.log(\"name \", name);\r\n        name.includes(\" \") ? this._fullName = name : `${name} is not a full name!`\r\n    }\r\n\r\n    get fullName(){\r\n        return this._fullName;\r\n    }\r\n\r\n    static hey(){ //Static class methods are defined on the class itself. Staic are not available on instances\r\n        console.log(\"Hello world\");\r\n        console.dir(this);\r\n    }\r\n    \r\n}\r\n\r\nconst german = new PersonCl(\"German mancilla\", 1998); //We use the this keyword as before, and will be set to the newly created empty object. So, when we create a new instance here, then the constructor function is gonna be called and that will return a new object and then that will be stored in \"dani\".\r\n\r\n// This method is NOT inherited. So, we couldn't call the from method on an array like german.hey(); because it isn't in the prototype of the german object.\r\n// PersonCl.hey = function(){\r\n//     console.log(\"Hello world\");\r\n//     console.log(this)\r\n// }\r\n// german.hey(); //We will get an error because german doesn't inherit the hey() method\r\n\r\nconsole.log(german);\r\nconsole.dir(PersonCl);\r\ngerman.calgAge();\r\ngerman.greet();\r\nconsole.log(german.age);\r\nPersonCl.hey(); //That's exactly the object that is calling the method. So, whatever object is calling the method, will be the this keyword inside of that funcion. And here the this keyword  is simply the entire constructor function.\r\nconsole.dir(PersonCl.hey)\r\n\r\nconsole.log(german.__proto__);\r\nconsole.log(german.__proto__ === PersonCl.prototype);\r\n\r\n// 1. Classes are not hoisted even if they're class declarations. Functions declarations are hoisted, which means we can use them before they're declared in the code. With classes tgat doesn't work.\r\n// 2. Class are first-class citizens. This means that we can pas them into functions and also return them from functions. (classes are just a special kind of functions behind the scenes)\r\n// 3. Classes are executed in strict mode. And so even if we didn't activate it for our entire script, all the code that is in the class will be executed in strict mode.\r\n\r\nconst account = {\r\n    owner: 'Jonas',\r\n    movements: [200, 530, 120, 300],\r\n\r\n    get latest() {\r\n        return this.movements.slice(-1).pop();\r\n    },\r\n\r\n    set latest(mov) {\r\n        this.movements.push(mov);\r\n    },\r\n};\r\n\r\nconsole.log(account.latest);\r\n\r\naccount.latest = 50;\r\nconsole.log(account.movements);\r\n\r\n//Object.create \r\n// --> Here there's still the idea of prototypal inheritance. However, there are no prototypal properties involved and also no constructor funcionds and no new operator. So, we can use Object.create to manually set the prototype of an object to any other object that we want.\r\nconst PersonProto = {\r\n    init(firstName, birthYear){ //This looks like the constructor function that we created in the last methods, but here this is isn't the case becasue we don't use the new operator to call this.\r\n        this.firstName = firstName; //The this keyword will point to the mancilla object, and it does so because we explicitly called   mancilla.init(\"German\", 1998);\r\n        this.birthYear = birthYear;\r\n        console.log(this); // === console.log(mancilla);\r\n    },\r\n\r\n    calgAge(){ //All the methods that we write in the class (outside of the constructor), will be on the prototype on the object and not on the objects themselves.\r\n        console.log(\"calgAge: \", 2037 - this.birthYear);\r\n    },\r\n}\r\n\r\nconst mancilla = Object.create(PersonProto); //This will return a brand new object that is linked to the prototype that we passed in here. So, mancilla is right now an empty object and it'll be linked to the PersonProto object. PersonProto should be the prototype of mancilla.\r\n\r\nconsole.log(PersonProto);\r\nconsole.log(mancilla.__proto__);\r\nconsole.log(mancilla.__proto__ === PersonProto);\r\n\r\n// mancilla.name = \"chavez\"; //We can create properties manually like this\r\n// mancilla.year = 2002;\r\n\r\nmancilla.init(\"German\", 1998);\r\nmancilla.calgAge(); //The calcAge() method is called on an object, for example, on the mancilla object. This means that the 'this' keyword inside of the calcAge() method will reference mancilla object. The mancilla object has a property called birthYear, so this.birthYear inside of calcAge() will translate to mancilla.birthYear . */\r\n\r\n/* //Ejemplo 3: Inheritance Between \"Classes\": Constructor Functions\r\nfunction Person(firstName, birthYear) { //Constructor function\r\n    this.firstName = firstName;\r\n    this.birthYear = birthYear;\r\n};\r\n\r\nPerson.prototype.calcAge = function () { //We create a new calcAge method with the prototype keyword to the Person object. So, we can use this method on the german or karla object even though it isn't on the object itself. The reason why we create this method outsite the constructor function, is becuase when creating it inside, this method is added to all the object created. So, it's best to add this method to every object just when necessary.\r\n    console.log(\"My age is: \", 2037 - this.birthYear);\r\n}; \r\n                    \r\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n\r\nfunction Student(firstName, birthYear, course){ //Child function of the Person function, and it will inherit everything of its parent funciton.\r\n    //Person(firstName, birthYear); //❌❌❌ If we would want to avoid duplicating code (in this case, re-write firstName and birthYear in Student), the problem here is that we are now actually calling this person constructor function as a regular function call. So we are not using this new operator to call this person function constructor. And so therefore this function call here is simply a regular function call. And remember that in a regular function call, the this keyword is set to undefined. And so therefore that's why we get this error here, that it cannot set first name on undefined. So instead of simply calling the person function here, we need to manually set the this keyword as well.\r\n    Person.call(this, firstName, birthYear); // ✔✔✔ We need to call the function and at the same time set the this keyword inside that function. To do that, we can simply use the call method, which will call the function but we'll be able to specify the this keywords as the first argument in the function. In the next line, we can the this keyword inside the Person function so simply be the this keyword inside this funcion. Now, the this keyword (Person.call) is going to be in the beggining, the empty object (german) that is being created by the new operator. And so it is on that new object where we want to set the first name and the birthYear property.\r\n    this.course = course;\r\n}\r\n\r\n//Student.prototype = Person.prototype; //❌❌❌ We must not do this because if so, we're saying that the student's prototype property and the person's prototype property should be the exact same object.\r\nStudent.prototype = Object.create(Person.prototype); // ✔✔✔ We want to make Person.prototype the prototype of Student.prototype (inherit from it and should not be the same object). So, to link the two prototype objects, we do the following. That's because Object.create defines prototypes manually. Now, the Student.prototype object is an object that inherits from Person.prototype. We have to do this before any we add any more methods to the prototype object of student because Object.create, will return a new empty object.\r\n\r\nStudent.prototype.introduce = function () {\r\n    console.log(`My name is ${this.firstName} and I study ${this.course}`);\r\n}; \r\n\r\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n\r\nconst german = new Student(\"German\", 2023, \"Computer science\");\r\n\r\ngerman.introduce();\r\ngerman.calcAge(); //This function from Person works in Student as well because this last one inherit the function from Person by using Student.prototype = Object.create(Person.prototype);\r\nconsole.log(german.__proto__);\r\nconsole.log(german.__proto__.__proto__);\r\n\r\nconsole.log(german instanceof Student); //true\r\nconsole.log(german instanceof Person);  //true. If we didn't have Student.prototype = Object.create(Person.prototype), then it should be false because german wouldn't inherit from Person but Student.\r\nconsole.log(german instanceof Object);  //true. It is also an instance of Object because this is also in its prototype chain.\r\n\r\nconsole.log(german); //We must realize that when open up the [[Prototype]] element, we'll see that is says Person instead of Student, but german is actually of the type Student. \r\nconsole.dir(Student); //This is the real prototype property of Student.\r\nStudent.prototype.constructor = Student;  \r\nconsole.dir(Student.prototype.constructor); //Student.prototype.constructor is pointing back to Person, and the reason for that we set the prototype property of the student using Object.create(). So this make it so that the constructor of Student.prototype is still Person. (This will be best viewed using Firefox) */\r\n\r\n/* //Ejemplo 4: Inheritance Between \"Classes\": ES6 Classes\r\nclass PersonCl{\r\n    constructor(fullName, birthYear){ \r\n        this.fullName = fullName;\r\n        this.birthYear = birthYear;\r\n    }; \r\n\r\n    //Instance methods (Methods will be added to .prototype property and all instances can have access to them)\r\n    calgAge(){ //All the methods that we write in the class (outside of the constructor), will be on the prototype on the object and not on the objects themselves.\r\n        console.log(\"calgAge: \", 2037 - this.birthYear);\r\n    };\r\n\r\n    greet(){\r\n        console.log(`greet:  ${this._fullName}`)\r\n    }\r\n\r\n    get age(){\r\n        return `age: ${2037 - this.birthYear}`;\r\n    }\r\n    \r\n\r\n    set fullName(name){  //Set a property that already exists.\r\n        console.log(\"name \", name);\r\n        name.includes(\" \") ? this._fullName = name : `${name} is not a full name!`\r\n    }\r\n\r\n    get fullName(){\r\n        return this._fullName;\r\n    }\r\n\r\n    static hey(){ //Static class methods are defined on the class itself. Staic are not available on instances\r\n        console.log(\"Hello world\");\r\n        console.dir(this);\r\n    }\r\n}\r\n\r\nclass StudentCl extends PersonCl{\r\n    constructor(fullName, birthYear, course){\r\n        super(fullName, birthYear); //Always neets to happen first. super is basically the constructor function of the parent class. This is similar to use the \"call\" method in the Constructor Functions. We don't need to specify the name of the parent class again because that already happened in \"extends PersonCl\". Finally, we have to pass in the arguments for the constructor of the parent class (the parameters in the constructor funcion of PersonCl)\r\n        this.course = course;\r\n    }\r\n\r\n    inroduce(){\r\n        console.log(`My name is ${this.fullName} and I study ${this.course}`);\r\n    }\r\n\r\n    calgAge(){\r\n        console.log(\"Hello world\");\r\n    }\r\n}\r\n\r\nconst german = new StudentCl(\"German mancilla\", 1998, \"Computer science\");\r\nconsole.log(german);\r\ngerman.inroduce();\r\ngerman.calgAge(); */\r\n\r\n/* //Ejemplo 5: Inheritance Between \"Classes\": Object.create\r\nconst PersonProto = {\r\n    init(firstName, birthYear){     //This looks like the constructor function that we created in the last methods, but here this is isn't the case becasue we don't use the new operator to call this.\r\n        this.firstName = firstName; //The this keyword will point to the mancilla object, and it does so because we explicitly called   mancilla.init(\"German\", 1998);\r\n        this.birthYear = birthYear;\r\n        // console.log(this);\r\n    },\r\n\r\n    calgAge(){ //All the methods that we write in the class (outside of the constructor), will be on the prototype on the object and not on the objects themselves.\r\n        console.log(\"My age is: \", 2037 - this.birthYear);\r\n    },\r\n}\r\n\r\nconst mancilla = Object.create(PersonProto);\r\nconst SudentProto = Object.create(PersonProto);\r\n\r\nSudentProto.init = function(firstName, birthYear, course){\r\n    PersonProto.init.call(this, firstName, birthYear); //We do this so that we can avoid writing the same code (this.firstName = firstName and this.birthYear = birthYear).\r\n    this.course = course;\r\n}\r\n\r\nSudentProto.introduce = function(){\r\n    console.log(`My name is ${this.firstName} and I study ${this.course}`);\r\n}\r\n\r\nconst karla = Object.create(SudentProto);\r\nkarla.init(\"Karla Marquez\", 1998, \"Computer science\");\r\nkarla.introduce();\r\nkarla.calgAge();\r\nconsole.log(karla); */\r\n\r\n/* //Ejemplo 6: Another Class Example\r\nclass Account{\r\n    constructor(owner, currency, pin, movements){\r\n        this.owner = owner;\r\n        this.currency = currency;\r\n        this.pin = pin;\r\n        this.locale = navigator.language;\r\n        this.movements = []; //We can create even more properties on any instance and properties tjat are not based on any inputs. \r\n\r\n        console.log(`Thanks for opening an account, ${owner}`); //We can even execute any code here in this constructor that we want. When someone opens a new account then will recieve this message. \r\n    }\r\n\r\n    //The reason why we defined deposit and withdraw inside the class Account is because we want these two methods to be inherited by all the instances of the Account class. \r\n    //Methods put outside of the constructor(), but inside of the class's body are put in the prototype meaning they will be inherited by all of the instances of that class.\r\n    deposit(val){\r\n        this.movements.push(val)\r\n    }\r\n\r\n    withdraw(val){\r\n        this.deposit(-val); //We can call other methods inside of a certain one. But we forcelly need to use the this keyword to be able to access this other method.\r\n    }\r\n\r\n    aproveLoan(){\r\n        return true;\r\n    }\r\n\r\n    requestLoan(val){\r\n        if (this.aproveLoan(val)) {\r\n            this.deposit(val);\r\n            console.log(`Loan approved for ${val}$`);\r\n        }\r\n    }\r\n}\r\n\r\nconst acc1 = new Account(\"German\", \"EUR\", 1111);\r\n\r\nacc1.deposit(250);\r\nacc1.withdraw(140);\r\nacc1.requestLoan(1000);\r\nconsole.log(acc1); */\r\n\r\n/* //Ejemplo 7: Encapsulation, Protected Properties and Methods\r\n//Encapsulation basically means to keep some properties and methods private inside the class so that they are not accessible from outside of the class.\r\nclass Account{\r\n    constructor(owner, currency, pin){\r\n        this.owner = owner;\r\n        this.currency = currency;\r\n        this.locale = navigator.language;\r\n        \r\n        //Protected propertyes\r\n        this._pin = pin;\r\n        this._movements = []; //We can create even more properties on any instance and properties that are not based on any inputs. This doen't actually make the property truly private because it's just a convention\r\n\r\n        console.log(`Thanks for opening an account, ${owner}`); //We can even execute any code here in this constructor that we want. When someone opens a new account then will recieve this message. \r\n    }\r\n\r\n    //Public interface\r\n    getMovements(){ //if we still wanted to give access to the movements array from the outside then we would have to implement a public method for that\r\n        return this._movements;\r\n    }\r\n\r\n    //The reason why we defined deposit and withdraw inside the class Account is because we want these two methods to be inherited by all the instances of the Account class. \r\n    //Methods put outside of the constructor(), but inside of the class's body are put in the prototype meaning they will be inherited by all of the instances of that class.\r\n    deposit(val){\r\n        this._movements.push(val)\r\n    }\r\n\r\n    withdraw(val){\r\n        this.deposit(-val); //We can call other methods inside of a certain one. But we forcelly need to use the this keyword to be able to access this other method.\r\n    }\r\n\r\n    _aproveLoan(){ //This method shouldn't be part of the public API, but all the others should be.\r\n        return true;\r\n    }\r\n\r\n    requestLoan(val){\r\n        if (this._aproveLoan(val)) {\r\n            this.deposit(val);\r\n            console.log(`Loan approved for ${val}$`);\r\n        }\r\n    }\r\n}\r\n\r\nconst acc1 = new Account(\"German\", \"EUR\", 1111);\r\n\r\nacc1._movements.push(250);\r\nacc1._movements.push(-140);\r\n\r\nacc1.deposit(250);\r\nacc1.withdraw(140);\r\nacc1.requestLoan(1000);\r\nconsole.log(acc1.getMovements()); //Someone can access the movements but they can't overwrite them.\r\nconsole.log(acc1); */\r\n\r\n/* //Ejemplo 8: Encapsulation: Private Class Fields and Methods\r\n\r\n//Encapsulation basically means to keep some properties and methods private inside the class so that they are not accessible from outside of the class.\r\nclass Account{\r\n    \r\n    // 1) Public fields (instances). These public fields are gonna be presened on all the instances that we are creating through the class. (They're referenceable by the this keyword). So they're not on the prototype. Finally, these two instances are the same as the two ones on the Protected properties.\r\n    locale = navigator.language;\r\n\r\n    // 2) Private fields (instances). With this, properites are really truly not accessible from the outside.\r\n    #movements = [] //The # makes a field private\r\n    #pin;           //We cannot define a field in the constructor\r\n\r\n    constructor(owner, currency, pin){\r\n        this.owner = owner;\r\n        this.currency = currency;\r\n        this.#pin = pin;\r\n\r\n        console.log(`Thanks for opening an account, ${owner}`); //We can even execute any code here in this constructor that we want. When someone opens a new account then will recieve this message. \r\n    }\r\n\r\n    // 3) Public methods\r\n    getMovements(){\r\n        return this.#movements;\r\n    }\r\n\r\n    deposit(val){\r\n        this.#movements.push(val)\r\n        return this; //deposit returns undefined because we're not returning anything explicitly here. So, to fix that, we need to return this, because the this keyword here is the current object. This line of code will make the method chainable. Finally, you must keep in mind that we have to do the same thing in deposit(), withdraw() and requestLoan() because the three of them deal with a private property (#movements).\r\n    }\r\n\r\n    withdraw(val){\r\n        this.deposit(-val); //We can call other methods inside of a certain one. But we forcelly need to use the this keyword to be able to access this other method.\r\n        return this;\r\n    }\r\n\r\n    requestLoan(val){\r\n        if (this.#aproveLoan(val)) {\r\n            this.deposit(val);\r\n            console.log(`Loan approved for ${val}$`);\r\n            return this;\r\n        }\r\n    }\r\n\r\n    static helper(){\r\n        console.log(\"Hello world!\")\r\n    }\r\n\r\n    // 4) Private methods. This is very useful to hide the implementations details from the outside.\r\n    #aproveLoan(){ //This method shouldn't be part of the public API, but all the others should be.\r\n        return true;\r\n    }\r\n}\r\n\r\nconst acc1 = new Account(\"German\", \"EUR\", 1111);\r\n\r\n// acc1._movements.push(250);\r\n// acc1._movements.push(-140);\r\n\r\nacc1.deposit(250);\r\nacc1.withdraw(140);\r\nacc1.requestLoan(1000);\r\nconsole.log(acc1.getMovements()); //Someone can access the movements but they can't overwrite them \r\nconsole.log(acc1); \r\nAccount.helper();\r\n// console.log(acc1.#movements); //We'll get an error because this is private.\r\n\r\nacc1.deposit(300).deposit(500).withdraw(35).requestLoan(25000).withdraw(4000);\r\nconsole.log(acc1.getMovements()); */\r\n\r\n/* //Ejemplo 9:  Ejercicio de repaso numero 1: using constructor Functions, the \"new\" and the \"this\" Operator\r\n// 1. Use a constructor function to implement a 'Car'. A car has a 'brand' and a 'speed' property. The 'speed' property is the current speed of the car in km/h\r\n// 2. Implement an 'accelerate' method that will increase the car's speed by 10, and log the new speed to the console\r\n// 3. Implement a 'brake' method that will decrease the car's speed by 5, and log the new speed to the console\r\n// 4. Create 2 'Car' objects and experiment with calling 'accelerate' and 'brake' multiple times on each of them\r\n\r\n//GOOD PRACTICE\r\nfunction Car(brand, speed){\r\n    this.brand = brand;\r\n    this.speed = speed;\r\n}\r\n\r\nCar.prototype.accelerate = function(){\r\n    this.speed = this.speed + 10;\r\n    console.log(`${this.brand} is going at ${this.speed} km/h`)\r\n}\r\n\r\nCar.prototype.brake = function(){\r\n    this.speed = this.speed - 5;\r\n    console.log(`${this.brand} is going at ${this.speed} km/h`)\r\n}\r\n\r\nconst bmw = new Car(\"BMW\", 120);\r\nconst mercedes = new Car(\"Mercedes\", 95);\r\n\r\nbmw.accelerate();\r\nbmw.accelerate();\r\nbmw.accelerate();\r\nbmw.brake();\r\n\r\n//BAD PRACTICE\r\n// function Car(brand, speed){\r\n//     this.brand = brand;\r\n//     this.speed = speed;\r\n\r\n//     this.accelerate = function () {\r\n//         this.speed = this.speed + 10;\r\n//         console.log(`${this.brand} is going at ${this.speed} km/h`)\r\n//     };\r\n\r\n//     this.brake = function () {\r\n//         this.speed = this.speed - 5;\r\n//         console.log(`${this.brand} is going at ${this.speed} km/h`)\r\n//     };\r\n// }\r\n\r\n// const bmw = new Car(\"BMW\", 120);\r\n// const mercedes = new Car(\"Mercedes\", 95);\r\n\r\n// bmw.accelerate();\r\n// bmw.accelerate();\r\n// bmw.accelerate();\r\n// bmw.brake(); */\r\n\r\n/* //Ejemplo 10: Ejercicio de repaso numero 2: using classes, Setters and Getters\r\n// 1. Re-create Challenge #1, but this time using an ES6 class (call it 'CarCl')\r\n// 2. Add a getter called 'speedUS' which returns the current speed in mi/h (divide by 1.6)\r\n// 3. Add a setter called 'speedUS' which sets the current speed in mi/h (but converts it to km/h before storing the value, by multiplying the input by 1.6) methods, and with the getter and setter.\r\n// § Data car 1: 'Ford' going at 120 km/h\r\n\r\nclass CarCl {\r\n    constructor(brand, speed){\r\n        this.brand = brand;\r\n        this.speed = speed;\r\n    }\r\n    \r\n    accelerate(){\r\n        this.speed = this.speed + 10;\r\n        console.log(`${this.brand} is going at ${this.speed} km/h`)\r\n    }\r\n    \r\n    brake(){\r\n        this.speed = this.speed - 5;\r\n        console.log(`${this.brand} is going at ${this.speed} km/h`)\r\n    }\r\n\r\n    get speedUS(){\r\n        return this.speed / 1.6;\r\n    }\r\n\r\n    set speedUS(speed){\r\n        this.speed = speed*1.6;\r\n    }\r\n}\r\n\r\nconst ford = new CarCl(\"Ford\", 120);\r\nconsole.log(`${ford.speedUS} mi/h`);\r\nford.accelerate();\r\nford.speedUS = 50;\r\nconsole.log(ford); */\r\n\r\n/* //Ejemplo 11: Ejercicio de repaso numero 3: using Inheritance Between \"Classes\": Constructor Functions\r\n1. Use a constructor function to implement an Electric Car (called 'EV') as a child \"class\" of 'Car'. Besides a make and current speed, the 'EV' also has the current\r\n   battery charge in % ('charge' property)\r\n2. Implement a 'chargeBattery' method which takes an argument 'chargeTo' and sets the battery charge to 'chargeTo'\r\n3. Implement an 'accelerate' method that will increase the car's speed by 20, and decrease the charge by 1%. Then log a message like this: \r\n   'Tesla going at 140 km/h, with a charge of 22%'\r\n4. Create an electric car object and experiment with calling 'accelerate', 'brake' and 'chargeBattery' (charge to 90%). Notice what happens when you 'accelerate'!\r\n\r\nfunction Car(brand, speed){\r\n    this.brand = brand;\r\n    this.speed = speed;\r\n}\r\n\r\nCar.prototype.accelerate = function(){\r\n    this.speed = this.speed + 10;\r\n    console.log(`${this.brand} is going at ${this.speed} km/h`)\r\n}\r\n\r\nCar.prototype.brake = function(){\r\n    this.speed = this.speed - 5;\r\n    console.log(`${this.brand} is going at ${this.speed} km/h`)\r\n}\r\n\r\n//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\r\n\r\nfunction EV(brand, speed, charge){\r\n    Car.call(this, brand, speed);\r\n    this.charge = charge;\r\n}\r\n\r\nEV.prototype = Object.create(Car.prototype); //We want to make Car.prototype the prototype of EV.prototype (inherit from it and should not be the same object). So, to link the two prototype objects, we do the following. That's because Object.create defines prototypes manually. Now, the ev.prototype object is an object that inherits from Car.prototype. We have to do this before any we add any more methods to the prototype object of EV because Object.create, will return a new empty object.\r\n\r\nEV.prototype.chargeBattery = function(chargeTo){ //We create a new method\r\n    this.charge = chargeTo;\r\n}\r\n\r\nEV.prototype.accelerate = function(){ //We create a new method.\r\n    this.speed += 20; \r\n    this.charge--;\r\n    console.log(`Tesla going at ${this.speed}, with a charge of ${this.charge}`)\r\n}\r\n\r\nconst tesla = new EV(\"Tesla\", 129, 23);  \r\ntesla.brake(); //Having used the Object.create(), now we can also access to the methods in the constructor function (car), from the EV function. If we don't use EV.prototype = Object.create(Car.prototype), then we won't be able to access to this method in Car.\r\ntesla.chargeBattery(90);\r\ntesla.accelerate(); // There are two methods with the same name (accelerate). So, the first one is in the tesla's object, and the second one in the constructor function (Car). When there are two or more methods or properties with the same name in a prototype chain, then JS will always use the first one. Finally, a child class can overwrite a methid that inherited from the parent class.\r\n\r\nEV.prototype.constructor = EV;\r\nconsole.log(tesla);\r\nconsole.dir(EV.prototype.constructor); */\r\n\r\n/* //Ejemplo 12: Ejercicio de repaso numero 4: using Inheritance Between \"Classes\": ES6 Classes and Object.create(), and using encapsulation.\r\n// 1. Re-create Challenge #3, but this time using ES6 classes: create an 'EVCl' child class of the 'CarCl' class\r\n// 2. Make the 'charge' property private\r\n// 3. Implement the ability to chain the 'accelerate' and 'chargeBattery' methods of this class, and also update the 'brake' method in the 'CarCl' class. Then experiment with chaining!\r\n// Data car 1: 'Rivian' going at 120 km/h, with a charge of 23%\r\n\r\nclass CarCl{\r\n    constructor(brand, speed){\r\n        this.brand = brand;\r\n        this.speed = speed;\r\n    }\r\n    accelerate(){\r\n        this.speed = this.speed + 10;\r\n        console.log(`${this.brand} is going at ${this.speed} km/h`);\r\n        return this;\r\n    }\r\n    \r\n    brake(){\r\n        this.speed = this.speed - 5;\r\n        console.log(`${this.brand} is going at ${this.speed} km/h`);\r\n        return this;\r\n    }\r\n\r\n    get speedUS(){\r\n        return this.speed / 1.6;\r\n    }\r\n\r\n    set speedUS(speed){\r\n        this.speed = speed*1.6;\r\n    }\r\n}\r\n\r\nclass EVCl extends CarCl{\r\n    #charge\r\n\r\n    constructor(brand, speed, charge){\r\n        super(brand, speed);\r\n        this.#charge = charge;\r\n    }\r\n        \r\n    chargeBattery(chargeTo){ //We create a new method\r\n        this.#charge = chargeTo;\r\n        return this;\r\n    }\r\n    \r\n    accelerate(){ //We create a new method.\r\n        this.speed += 20; \r\n        this.#charge--;\r\n        console.log(`Tesla going at ${this.speed}, with a charge of ${this.#charge}`);\r\n        return this;\r\n    }\r\n}\r\n\r\nconst rivian = new EVCl(\"Rivian\", 120, 23);\r\nconsole.log(rivian);\r\nrivian.accelerate().accelerate().accelerate().brake().chargeBattery(50).accelerate();\r\nconsole.log(rivian.speedUS); */\r\n\r\n\r\n//         $$$$$$$$$$$$$$$ Arrays $$$$$$$$$$$$$$$\r\n\r\n\r\n/* //Ejemplo 1: Declaracion y manejo de un array con numeros que vamos a operar entre ellos\r\n\r\nconst VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\"]; console.log(\"Los datos del vector son: \", VECTOR_DE_CADENAS);\r\nconst VECTOR_DE_BANDERAS = [true, false, true, false];console.log(\"Los datos del vector son: \", VECTOR_DE_BANDERAS);\r\nconst VECTOR_HETEROGENEO = [2023, \"german\", true, 22]; console.log(\"Los datos del vector son: \", VECTOR_HETEROGENEO);\r\nconst MI_ARRAY_DE_NUMEROS = [10, 20, 50, 80]; console.log(\"Los datos del vector son: \", MI_ARRAY_DE_NUMEROS);\r\n\r\nconst res1 = MI_ARRAY_DE_NUMEROS[2] + MI_ARRAY_DE_NUMEROS[3]; console.log(\"El resultado es: \"+ res1);\r\nconst res2 = VECTOR_DE_CADENAS[0] + \" \" + VECTOR_DE_CADENAS[2]; console.log(\"Los datos del vector son: \", res2);\r\nconst res3 = MI_ARRAY_DE_NUMEROS[0] + VECTOR_DE_CADENAS[2]; console.log(\"El resultado es: \", res3); */\r\n\r\n/* //Ejemplo 2: Como recorremos un array\r\nconst VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\"];\r\n//for (let i = 0; i < VECTOR_DE_CADENAS.[\"length\"]; i++) {\r\nfor (let i = 0; i < VECTOR_DE_CADENAS.length; i++) {\r\n    console.log(\"El elemento en la posicion \" + i + \" es el nombre: \"+ VECTOR_DE_CADENAS[i])    \r\n} */\r\n\r\n/* //Ejemplo 3: Como anadir elementos en x posicion sustituyendo el de esa misma posicion\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\", \"Junior\"];\r\nlet nombre = \"karla\";\r\nVECTOR_DE_CADENAS[2] = nombre;\r\nconsole.log(\"Los nuevos nombres dentro del array son: \",VECTOR_DE_CADENAS); */\r\n\r\n/* //Ejemplo 4: Recorrer un array con |for-of|\r\nconst restaurant = {\r\n    name: 'Classico Italiano',\r\n    location: 'Via Angelo Tavanti 23, Firenze, Italy',\r\n    categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],\r\n    starterMenu: ['Focaccia', 'Bruschetta', 'Garlic Bread', 'Caprese Salad'],\r\n    mainMenu: ['Pizza', 'Pasta', 'Risotto'],\r\n\r\n    openingHours: {\r\n        thu: {open: 12,close: 22,},\r\n        fri: {open: 11,close: 23,},\r\n        sat: {open: 0, close: 24,}, // Open 24 hours\r\n    },\r\n};\r\n\r\nconst menu = [...restaurant.starterMenu, ...restaurant.mainMenu];\r\n// for (const res of menu) {\r\n//     console.log(res);\r\n// }\r\n\r\n// for (const item of menu.entries()) {\r\n//     console.log(item);\r\n// }\r\n\r\nfor (const item of menu.entries()) {\r\n    console.log(`${item[0] + 1}: ${item[1]}`);\r\n}\r\n\r\nconsole.log(\"\\n\");\r\n\r\nfor (const [i, el] of menu.entries()) {\r\n    console.log(`${i + 1}: ${el}`);\r\n} */\r\n\r\n/* //Ejemplo 5: Conocer la cantidad de elementos que tiene nuestro array con  |.length()|\r\nconst VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\"];\r\nconsole.log(\"Cuantos elementos tengo en mi array?\", VECTOR_DE_CADENAS.length);\r\nconsole.log(\"Cual es la posicion de mi ultimo elemento dentro de mi array?\", VECTOR_DE_CADENAS.length-1) */\r\n\r\n/* //Ejemplo 6: Como anadir elementos a un array con  |.push()|\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\"];\r\nlet nombre = \"karla\";\r\nVECTOR_DE_CADENAS.push(nombre);\r\nconsole.log(\"Los nuevos nombres dentro del array son: \",VECTOR_DE_CADENAS); */\r\n\r\n/* //Ejemplo 7: Como anadir elementos al principio de un array con |.unshift()|\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\"];\r\nlet nombre = \"karla\";\r\nVECTOR_DE_CADENAS.unshift(nombre);\r\nconsole.log(\"Los nuevos nombres dentro del array son: \",VECTOR_DE_CADENAS); */\r\n\r\n/* //Ejemplo 8: Como eliminar elementos en la primer posicion de un array con |.shift|\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\", \"Junior\"];\r\nlet elementoRecuperado = VECTOR_DE_CADENAS.shift();\r\nconsole.log(\"El elemento recuperado es: \",elementoRecuperado);\r\nconsole.log(\"Los nuevos nombres dentro del array son: \",VECTOR_DE_CADENAS); */\r\n\r\n/* //Ejemplo 9: Como eliminar elementos en la ultima posicion de un array con |.pop()|\r\n\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\", \"Junior\"];\r\nlet elementoRecuperado = VECTOR_DE_CADENAS.pop();\r\nconsole.log(\"El elemento recuperado es: \",elementoRecuperado);\r\nconsole.log(\"Los nuevos nombres dentro del array son: \",VECTOR_DE_CADENAS); */\r\n\r\n/* //Ejemplo 10: Como eliminar uno o mas elementos de un array con |.splice()|\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\", \"Junior\"];\r\nlet elementoRecuperado = VECTOR_DE_CADENAS.splice(1,2); //1 = la posicion - 2 = cantidad de numeros a eliminar a partir de 1\r\nconsole.log(\"Los elementos removidos dentro del array son \",elementoRecuperado);\r\nconsole.log(\"Los nuevos nombres dentro del array son: \",VECTOR_DE_CADENAS);\r\n\r\nconsole.log(\"\\n\");\r\n\r\nlet VECTOR_DE_CADENAS1 = [\"german\", \"mancilla\", \"chavez\", \"junior\"];\r\nlet elementoRecuperado1 = VECTOR_DE_CADENAS1.splice(1,0, \"karla\", \"res\"); //1 = la posicion - 0 = cantidad de numeros a eliminar a partir de 1\r\n//let elementoRecuperado1 = VECTOR_DE_CADENAS1.splice(1,0, [\"marquez\", \"beatriz\"]);\r\nconsole.log(\"Los nuevos nombres dentro del array son: \",VECTOR_DE_CADENAS1);\r\nconsole.log(\"Los elementos removidos dentro del array son \", elementoRecuperado1); */\r\n\r\n/* //Ejemplo 11: Tomar un conjunto de elementos de dentro de un array y generar un nuevo array con ellos con |.slice()|\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\", \"Junior\", \"karla\"];\r\nconsole.log([...VECTOR_DE_CADENAS]);\r\nlet resultadoDelSlice = VECTOR_DE_CADENAS.slice(2, 5); //2 = esta posicion no se toma, sino la siguiente. 5 = limite que se toma en cuenta\r\nconsole.log(\"La cadena generada con nombres es: \",resultadoDelSlice); */\r\n\r\n/* //Ejemplo 12: Obtener una cadena con cada uno de sus elementos concatenados, separados con un caracter o cadena especial con |.join()|.\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\", \"Junior\"];\r\nlet resultadoDelJoin = VECTOR_DE_CADENAS.join(\", \");\r\nconsole.log(\"Los nuevos nombres dentro del array son: \",VECTOR_DE_CADENAS);\r\nconsole.log(\"La cadena generada con nombres es: \",resultadoDelJoin); */\r\n\r\n/* //Ejemplo 13: Combinar los elementos de dos arrays con |.concat()|\r\nlet VECTOR_DE_CADENAS1 = [\"german\", \"mancilla\", \"chavez\"], VECTOR_DE_CADENAS2 = [\"Karla\", \"beatriz\", \"marquez\"];\r\nlet resultadoDelJoin = VECTOR_DE_CADENAS1.concat(VECTOR_DE_CADENAS2);\r\nconsole.log(\"La cadena generada con nombres es: \",resultadoDelJoin); */\r\n\r\n/* //Ejemplo 14: Conocer la posicion de un elemento dentro de un array (si existe o no) con |.indexof()|\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\", \"Junior\"];\r\nlet posicionDeMancilla = VECTOR_DE_CADENAS.indexOf(\"chavez\");\r\nconsole.log(\"La cadena generada con nombres es: \",posicionDeMancilla);\r\n\r\nlet posicion = VECTOR_DE_CADENAS.indexOf(\"karla\");\r\nposicion != -1 ? console.log(\"El nombre esta en la posicion: \", posicion) : console.log(\"El nombre NO existe\"); */\r\n\r\n/* //Ejemplo 15: Conocer si existe o no un elemento dentro de un array (Valor booleano) con |.includes()|\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\", \"Junior\"];\r\nlet nombre = \"mancilla\"\r\nlet existe = VECTOR_DE_CADENAS.includes(nombre);\r\n\r\nexiste ? console.log(\"El nombre SI existe\") : console.log(\"El nombre NO existe\"); */\r\n\r\n/* //Ejemplo 16: Tomar al array e invertir el orden de sus elementos con |.reverse()|\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\", \"Junior\"];\r\nVECTOR_DE_CADENAS.reverse();\r\nconsole.log(\"--> El array con los nombres cambiados de lugar es\", VECTOR_DE_CADENAS); */\r\n\r\n/* //Ejemplo 17: Retornar el elemento indexado de un array o el elemento contenido en x posicion |.at()|\r\nlet VECTOR_DE_CADENAS = [\"german\", \"mancilla\", \"chavez\", \"Junior\"];\r\nconsole.log(VECTOR_DE_CADENAS.at(3).at(1)); //Obtenemos el elemento contenido en el array (Junior), y en el siguiente at, obtenemos la posicion de la letra. */\r\n\r\n/* // Ejemplo 18: Metodo |.fill()| para llenar un array con cualquier tipo de dato\r\nconst array1 = [1, 2, 3, 4];\r\nconsole.log(array1.fill(0, 2, 4)); // Fill with 0 from position 2 until position 4  --> [1, 2, 0, 0]\r\nconsole.log(array1.fill(5, 1));    // Fill with 5 from position 1 --> [1, 5, 5, 5]\r\nconsole.log(array1.fill(6));       //Fill the array with only \"6\" --> [6, 6, 6, 6] */\r\n\r\n/* //Ejemplo 19: Uso del metodo |new Array| para crear un arreglo de x cantidad de numeros y el metodo |Array.from()| para crear un array a partir de un objeto.\r\nconst res = new Array(1, 2, 3, 4, 5, 6, 7); // const res = [1, 2, 3, 4, 5, 6, 7];\r\nconst x = new Array(7); //Creamos un array vacio de 7 espacios de memoria.\r\nx.fill(1);              //LLenamos el arreglo con puros \"1\".\r\nconsole.log(x);\r\n\r\n// Array.from(object, mapFunction, thisValue)\r\nconst y = Array.from({length: 7}, function(){\r\n    return 1;\r\n}); console.log(y);\r\n\r\nconst z = Array.from({length: 7}, function(_, i){\r\n    return i + 1;\r\n}); console.log(z); */\r\n\r\n/* //Ejemplo 20: como iterar sobre los elementos de un array, no importa si posee valores simples u objetos, con |.foreach()|\r\nclass producto{\r\n    constructor(id, nombre, precio){\r\n        this.id = id;\r\n        this.nombre = nombre;\r\n        this.precio = parseFloat(precio);\r\n    }\r\n\r\n    convertirEnString () {\r\n        return this.id + \". \" + this.nombre.toUpperCase() +\" ($\"+ this.precio.toFixed(2) +\")\"\r\n    };\r\n\r\n    // convertirEnString = () => {\r\n    //     return this.id + \". \" + this.nombre +\" ($\"+ this.precio.toFixed(2) +\")\"\r\n    // };\r\n};\r\n\r\nlet misProductos = [\r\n    new producto (1, \"azucar\", 283.25),\r\n    new producto (2, \"cafe\", 340.33),\r\n    new producto (3, \"Mermelada de arandanos\", 472.14),\r\n    new producto (4, \"Dulce de leche\", 263.98),\r\n    new producto (5, \"pan lactal\", 404.86),\r\n    new producto (6, \"galletad de vainilla\", 2113.47),\r\n    new producto (7, \"manteca pan x 500g\", 896.55),\r\n    new producto (8, \"leche entera x 1lt\", 302.6),\r\n];\r\n\r\nmisProductos.forEach( function(mov, i, arr) { //El primer parametro siempre sera el contenido de ese array (mov), el segundo la posicion (i) y el tercero el array (arr)\r\n    return console.log( \"--> \"+ mov.convertirEnString()+ \" en la posicion \"+ (i+1));\r\n});\r\n\r\n//Ejemplo aplicado a Map()\r\nconst currencies = new Map([\r\n    ['USD', 'United States dollar'],\r\n    ['EUR', 'Euro'],\r\n    ['GBP', 'Pound sterling'],\r\n]);\r\n\r\ncurrencies.forEach(function (value, key, map){ //En el caso de usar Map(), los tres parametros principales son el valor, la clave y al final el map (array).\r\n    console.log(`${value}: ${key}`);\r\n});\r\n\r\n//Ejemplo aplicado a Set()\r\nconst currenciesIsUnique = new Set([\"USD\", \"GBP\", \"USD\", \"EUR\", \"EUR\"]); //En el caso de Set(), no existe una clave, por eso se pone \"_\". lo que indica una variable innecesaria.\r\ncurrenciesIsUnique.forEach(function(value, _, map){\r\n    console.log(`${value}: ${value}`);\r\n}); */\r\n\r\n/* //Ejemplo 21: como para hallar un elemento dentro de la coleccion (el PRIMER elemento), con |.find()|\r\nclass producto {\r\n    constructor(id, nombre, precio){\r\n        this.id = id;\r\n        this.nombre = nombre.toUpperCase();\r\n        this.precio = parseFloat(precio);\r\n    }\r\n\r\n    convertirEnString () {\r\n        return this.id + \". \" + this.nombre +\" en $\"+ this.precio.toFixed(2)\r\n    };\r\n};\r\n\r\nlet misProductos = [\r\n    new producto (1, \"azucar\", 283.25),\r\n    new producto (2, \"cafe\", 340.33),\r\n    new producto (3, \"Mermelada de arandanos\", 472.14),\r\n    new producto (4, \"Dulce de leche\", 263.98),\r\n    new producto (5, \"pan lactal\", 404.86),\r\n    new producto (6, \"galletad de vainilla\", 2113.47),\r\n    new producto (7, \"manteca pan x 500g\", 896.55),\r\n    new producto (8, \"leche entera x 1lt\", 302.6),\r\n];\r\n\r\n// let nombreBuscado = \"mermelada\";\r\n// let unProductoBuscado1 = misProductos.find(unProducto => {\r\n//     return unProducto.nombre.includes( nombreBuscado.toUpperCase()); //El metodo includes() retorna true o false si existe algo en el array, y este seguira iterando aunque ya haya retornado algo. Ahora bien, con el includes, unicamente  retornara un elemento, puesto que es la funcion principal de find(), retornar lo primero que encuentre nada mas.    \r\n// });\r\n\r\nlet nombreBuscado = \"pan lactal\";\r\nlet unProductoBuscado1 = misProductos.find(unProducto => unProducto.nombre === nombreBuscado.toUpperCase());\r\n\r\nunProductoBuscado1 !== undefined ? console.log(\"El producto buscado es: \"+ unProductoBuscado1.convertirEnString()) : console.log(\"No encontramos el producto con nombre: \"+ nombreBuscado); */\r\n\r\n/* //Ejemplo 22: como hallar todos los elementos dentro de la coleccion que cumplan con una condicion, con |.filter()|\r\nclass producto {\r\n    constructor(id, nombre, precio){\r\n        this.id = id;\r\n        this.nombre = nombre.toUpperCase();\r\n        this.precio = parseFloat(precio);\r\n    }\r\n\r\n    convertirEnString () {\r\n        return this.id + \". \" + this.nombre +\" en $\"+ this.precio.toFixed(2)\r\n    };\r\n};\r\n\r\nlet misProductos = [\r\n    new producto (1, \"azucar\", 283.25),\r\n    new producto (2, \"cafe\", 340.33),\r\n    new producto (3, \"Mermelada de arandanos\", 472.14),\r\n    new producto (4, \"Dulce de leche\", 263.98),\r\n    new producto (5, \"pan lactal\", 404.86),\r\n    new producto (6, \"galletad de vainilla\", 2113.47),\r\n    new producto (7, \"manteca pan x 500g\", 896.55),\r\n    new producto (8, \"leche entera x 1lt\", 302.6),\r\n    new producto (9, \"Mermelada de naranja\", 189.88),\r\n    new producto (10,\"Mermelada de fresa\", 356.24),\r\n];\r\n\r\nlet nombreBuscado = \"Mermelada\";\r\nlet productoHallados = misProductos.filter( function(unProducto){     // let productoHallados = misProductos.filter( (unProducto) => unProducto.nombre.includes( nombreBuscado.convertirEnString() ));\r\n    return unProducto.nombre.includes( nombreBuscado.toUpperCase() ); //Si el nombre buscado posee unicamente la palabra \"Mermelada\", entonces entonces retorna un true. Esto indica que no hay necesidad de tener que escribir \"Mermelada de naranja\" o similares.\r\n});\r\nconsole.log(\"Numero de productos hallados con el nombre \"+ \"'\"+`${nombreBuscado}`+\"'\" +\" son: \"+ productoHallados.length+ \" y tienen los siguientes nombres: \", productoHallados);\r\n\r\nlet preciosMayores = misProductos.filter( function(evento){\r\n    return evento.precio > 400;\r\n});\r\nconsole.log(\"Los precios mayores a $400 son: preciosMayores\", preciosMayores); */\r\n\r\n/* //Ejemplo 23: como saber si un elemento dentro de la coleccion existe o no, con |.some()|\r\n\r\nclass producto {\r\n    constructor(id, nombre, precio){\r\n        this.id = id;\r\n        this.nombre = nombre.toUpperCase();\r\n        this.precio = parseFloat(precio);\r\n    }\r\n\r\n    convertirEnString () {\r\n        return this.id + \". \" + this.nombre +\" en $\"+ this.precio.toFixed(2)\r\n    };\r\n};\r\n\r\nlet misProductos = [\r\n    new producto (1, \"azucar\", 283.25), \r\n    new producto (2, \"cafe\", 340.33),\r\n    new producto (3, \"mermelada de arandanos\", 472.14),\r\n    new producto (4, \"Dulce de leche\", 263.98),\r\n    new producto (5, \"pan lactal\", 404.86),\r\n    new producto (6, \"galletad de vainilla\", 2113.47),\r\n    new producto (7, \"manteca pan x 500g\", 896.55),\r\n    new producto (8, \"leche entera x 1lt\", 302.6),\r\n    new producto (9, \"mermelada de naranja\", 189.88),\r\n    new producto (10,\"mermelada de fresa\", 356.24),\r\n];\r\n\r\nlet nombreBuscado = \"AZUCAR\";\r\nlet existe = misProductos.some( (unProducto) => {\r\n    return unProducto.nombre === nombreBuscado.toUpperCase();\r\n});\r\n\r\nif (existe) {\r\n    console.log(\"El producto buscado SI existe\");\r\n} else {\r\n    console.log(\"El producto buscado NO existe\");\r\n} */\r\n\r\n/* //Ejemplo 24: como saber si un elemento dentro de la coleccion existe o no, y que devuelva true o false si todo cumple la condicion. Con |.every()|\r\nmovements1 = [200, 450, 400, -3000, 650, 0, 70, 1300];  //false\r\nmovements2 = [200, 450, 100, 3000, 650, 130, 70, 1300]; //true\r\nconsole.log(movements1.every(mov => mov > 0)); //\r\nconsole.log(movements2.every(mov => mov > 0)); */\r\n\r\n/* //Ejemplo 25: como enlistar solamente los nombres de los productos, con |.map()|\r\nclass producto {\r\n    constructor(id, nombre, precio){\r\n        this.id = id;\r\n        this.nombre = nombre.toUpperCase();\r\n        this.precio = parseFloat(precio);\r\n    }\r\n\r\n    convertirEnString () {\r\n        return this.id + \". \" + this.nombre +\" en $\"+ this.precio.toFixed(2);\r\n    };\r\n};\r\n\r\nlet misProductos = [\r\n    new producto (1, \"azucar\", 283.25), \r\n    new producto (2, \"cafe\", 340.33),\r\n    new producto (3, \"mermelada de arandanos\", 472.14),\r\n    new producto (4, \"Dulce de leche\", 263.98),\r\n    new producto (5, \"pan lactal\", 404.86),\r\n    new producto (6, \"galletad de vainilla\", 2113.47),\r\n    new producto (7, \"manteca pan x 500g\", 896.55),\r\n    new producto (8, \"leche entera x 1lt\", 302.6),\r\n    new producto (9, \"mermelada de naranja\", 189.88),\r\n    new producto (10,\"mermelada de fresa\", 356.24),\r\n];\r\n\r\nlet nombres, preciosIncrementados;\r\n\r\nnombres = misProductos.map( function(unProducto){\r\n    return unProducto.nombre;\r\n});\r\nconsole.log(\"1. Los nombres del array son: \", nombres);\r\n\r\npreciosIncrementados = misProductos.map( function(unProducto) {\r\n    return incrementarPrecio(unProducto.precio, 10)\r\n});\r\nconsole.log(\"2. Los precios incrementados seran: \", preciosIncrementados);\r\n\r\npreciosIncrementados = misProductos.map(function(unProducto) {\r\n    return new producto (unProducto.id, unProducto.nombre, incrementarPrecio(unProducto.precio, 10));\r\n});\r\nconsole.log(\"3. Los precios incrementados en forma de array seran: \", preciosIncrementados);\r\n\r\npreciosIncrementados = misProductos.map( function(unProducto) {\r\n    return {id: unProducto.id, nombre: unProducto.nombre, precio: incrementarPrecio(unProducto.precio, 10)}\r\n});\r\nconsole.log(\"4. Los precios incrementados forma de objeto seran: \", preciosIncrementados);\r\n\r\nfunction incrementarPrecio(precio, porcentaje){\r\n    return precio + (precio * (porcentaje/100) )\r\n} */\r\n\r\n/* //Ejemplo 26: como calcular el valor total de una compra, con |.reduce()|\r\nclass producto{\r\n    constructor(id, nombre, precio){\r\n        this.id = id;\r\n        this.nombre = nombre.toUpperCase();\r\n        this.precio = parseFloat(precio);\r\n    }\r\n};\r\n\r\nlet misProductos = [\r\n    new producto (1, \"azucar\", 283.25), \r\n    new producto (2, \"cafe\", 340.33),\r\n    new producto (3, \"mermelada de arandanos\", 472.14),\r\n    new producto (4, \"Dulce de leche\", 263.98),\r\n    new producto (5, \"pan lactal\", 404.86),\r\n    new producto (6, \"galleta de vainilla\", 2113.47),\r\n    new producto (7, \"manteca pan x 500g\", 896.55),\r\n    new producto (8, \"leche entera x 1lt\", 302.6),\r\n    new producto (9, \"mermelada de naranja\", 189.88),\r\n    new producto (10,\"mermelada de fresa\", 356.24),\r\n];\r\n\r\nlet preciosTotales = misProductos.reduce( function(acumulador, unProducto){    //let preciosTotales = misProductos.reduce( (acumulador, unProducto) => acumulador + unProducto.precio, 0);\r\n    return acumulador + unProducto.precio\r\n}, 0);\r\n\r\nconsole.log(\"El total de la suma es: \"+ preciosTotales.toFixed(2));\r\n\r\n//Valor maximo\r\nconst max = misProductos.reduce(function(acc, mov){\r\n    return acc > mov.precio ? acc : mov.precio;\r\n})\r\nconsole.log(max); */\r\n\r\n/* //Ejemplo 27: como re-ordenar nuestro array (es DESTRUCTIVO, cambia su posicion), con |.sort()|\r\n\r\nclass producto {\r\n    constructor(id, nombre, precio){\r\n        this.id = id;\r\n        this.nombre = nombre.toUpperCase();\r\n        this.precio = parseFloat(precio);\r\n    }\r\n\r\n    convertirEnString () {\r\n        return this.id + \". \" + this.nombre +\" en $\"+ this.precio.toFixed(2)\r\n    };\r\n};\r\n\r\nlet misProductos = [\r\n    new producto (1, \"azucar\", 283.25), \r\n    new producto (2, \"cafe\", 340.33),\r\n    new producto (3, \"mermelada de arandanos\", 472.14),\r\n    new producto (4, \"Dulce de leche\", 263.98),\r\n    new producto (5, \"pan lactal\", 404.86),\r\n    new producto (6, \"galleta de vainilla\", 2113.47),\r\n    new producto (7, \"manteca pan x 500g\", 896.55),\r\n    new producto (8, \"leche entera x 1lt\", 302.6),\r\n    new producto (9, \"mermelada de naranja\", 189.88),\r\n    new producto (10,\"mermelada de fresa\", 356.24),\r\n];\r\n\r\n// Utilizar una de las 6 opciones a la vez porque todas al mismo tiempo no funcionaran.\r\n// misProductos.sort( (first, second) => first.id - second.id);                        console.log(\"Forma ascendente: \", misProductos);\r\n// misProductos.sort( (first, second) => second.id - first.id);                        console.log(\"Forma descendente: \", misProductos);\r\n// misProductos.sort( (first, second) => first.nombre.localeCompare(second.nombre));   console.log(\"Forma ascendente: \", misProductos);\r\n// misProductos.sort( (first, second) => second.nombre.localeCompare(first.nombre));   console.log(\"Forma descendente: \", misProductos);\r\n// misProductos.sort( (first, second) => first.precio - second.precio);                console.log(\"Forma ascendente: \", misProductos);\r\n// misProductos.sort( (first, second) => second.precio - first.precio);                console.log(\"Forma descendente: \", misProductos); */\r\n\r\n/* //Ejemplo 28: como crear una nueva matriz con todos los elementos de sub-array concatenados con |.flat()| y como mapear todos los elementos del array y crear un nuevo flat array con |.flatMap()|\r\nconst acc1 = {\r\n    owner: 'Jonas Schmedtmann',\r\n    movements: [200, 450, -400, 3000, -650, -130, 70, 1300],\r\n    interestRate: 1.2, // %\r\n    pin: 1111,\r\n};\r\n\r\nconst acc2 = {\r\n    owner: 'Jessica Davis',\r\n    movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30],\r\n    interestRate: 1.5,\r\n    pin: 2222,\r\n};\r\n\r\nconst acc3 = {\r\n    owner: 'Steven Thomas Williams',\r\n    movements: [200, -200, 340, -300, -20, 50, 400, -460],\r\n    interestRate: 0.7,\r\n    pin: 3333,\r\n};\r\n\r\nconst acc4 = {\r\n    owner: 'Sarah Smith',\r\n    movements: [430, 1000, 700, 50, 90],\r\n    interestRate: 1,\r\n    pin: 4444,\r\n};\r\n\r\nconst allAccounts = [acc1, acc2, acc3, acc4];\r\n\r\nconst arr = [[1, 2, 3], [4, 5, 6], 7, 8];\r\nconsole.log(arr.flat());\r\n\r\nconst arrDeep = [ [[1, 2], 3], [4, [5, 6]], 7, 8 ];\r\nconsole.log(arrDeep.flat(2));\r\n\r\n//flat ()\r\nconst overalBalance = allAccounts.map(acc => acc.movements).flat().reduce((acc, mov) => acc + mov, 0);\r\nconsole.log(overalBalance);\r\n\r\n//flatMap()\r\nconst overalBalance2 = accounts.flatMap(acc => acc.movements).reduce((acc, mov) => acc + mov, 0);\r\nconsole.log(overalBalance2); */\r\n\r\n/* //Ejemplo 30: Ejercicio practico #1\r\n// Julia and Kate are doing a study on dogs. So each of them asked 5 dog owners about their dog's age, and stored the data into an array (one array for each). For now, they are \r\n// just interested in knowing whether a dog is an adult or a puppy. A dog is an adult if it is at least 3 years old, and it's a puppy if it's less than 3 years old. Your tasks:\r\n// Create a function 'checkDogs', which accepts 2 arrays of dog's ages ('dogsJulia' and 'dogsKate'), and does the following things:\r\n// 1. Julia found out that the owners of the first and the last two dogs actually have cats, not dogs! So create a shallow copy of Julia's array, and remove the cat\r\n// ages from that copied array (because it's a bad practice to mutate function parameters)\r\n// 2. Create an array with both Julia's (corrected) and Kate's data\r\n// 3. For each remaining dog, log to the console whether it's an adult (\"Dog number 1 is an adult, and is 5 years old\") or a puppy (\"Dog number 2 is still a puppy\")\r\n// 4. Run the function for both test datasets\r\n\r\nconst dogsJulia = [3, 5, 2, 12, 7];\r\nconst dogsKate = [4, 1, 15, 8, 3];\r\n\r\nfunction checkDogs(dogsJulia, dogsKate){\r\n    const dogsJuliaCorrected = dogsJulia.slice(); //We creat a new array (By setting the empty parenthesis) because we must not mutate the original array.\r\n    // dogsJulia.slice(1, 3); Podemos usar esto tambien y obtendremos lo mismo que abajo\r\n    dogsJuliaCorrected.splice(0, 1); //Borramos en la posicion 0, 1 elemento.\r\n    dogsJuliaCorrected.splice(-2); //Borramos los ultimos dos elementos\r\n    console.log(dogsJuliaCorrected);\r\n\r\n    const newArray = dogsJuliaCorrected.concat(dogsKate);\r\n    console.log(newArray);\r\n\r\n    newArray.forEach(function(mov, key){\r\n        const res = mov >=3 ? `Dog number ${key} is an adult, and is ${mov} years old` : `Dog number ${key+1} is still a puppy`\r\n        console.log(res);\r\n    });\r\n\r\n}\r\n\r\ncheckDogs(dogsJulia, dogsKate); */\r\n\r\n/* //Ejemplo 31: Ejercicio practico #2\r\n// Julia and Kate are still studying dogs, and this time they are studying if dogs are eating too much or too little. Eating too much means the dog's current food portion is \r\n// larger than the recommended portion, and eating too little is the opposite. Eating an okay amount means the dog's current food portion is within a range 10% above and \r\n// 10% below the recommended portion. Your tasks:\r\n// 1. Loop over the 'dogs' array containing dog objects, and for each dog, calculate the recommended food portion and add it to the object as a new property. Do not create a new \r\n// array, simply loop over the array. Forumla: recommendedFood = weight^0.75 * 28. (The result is in grams of food, and the weight needs to be in kg)\r\n// 2. Find Sarah's dog and log to the console whether it's eating too much or too little. Hint: Some dogs have multiple owners, so you first need to find Sarah in the owners \r\n// array, and so this one is a bit tricky (on purpose)\r\n// 3. Create an array containing all owners of dogs who eat too much ('ownersEatTooMuch') and an array with all owners of dogs who eat too little ('ownersEatTooLittle').\r\n// 4. Log a string to the console for each array created in 3., like this: \"Matilda and Alice and Bob's dogs eat too much!\" and \"Sarah and John and Michael's dogs eat too little!\"\r\n// 5. Log to the console whether there is any dog eating exactly the amount of food that is recommended (just true or false)\r\n// 6. Log to the console whether there is any dog eating an okay amount of food (just true or false)\r\n// 7. Create an array containing the dogs that are eating an okay amount of food (try to reuse the condition used in 6.)\r\n// 8. Create a shallow copy of the 'dogs' array and sort it by recommended food portion in an ascending order (keep in mind that the portions are inside the array's objects ).\r\n\r\n// Hints:\r\n// Being within a range 10% above and below the recommended portion means: current > (recommended * 0.90) && current < (recommended *1.10). Basically, the current portion \r\n// should be between 90% and 110% of the recommended portion.\r\n\r\nconst dogs = [\r\n    { weight: 22, curFood: 250, owners: ['Alice', 'Bob'] },\r\n    { weight: 8, curFood: 200, owners: ['Matilda'] },\r\n    { weight: 13, curFood: 275, owners: ['Sarah', 'John'] },\r\n    { weight: 32, curFood: 340, owners: ['Michael'] },\r\n];\r\n\r\n//1\r\ndogs.forEach(function(evento){\r\n    evento.recFood = Number((evento.weight ** 0.75 * 28).toFixed(4));\r\n});\r\n\r\n//2\r\nconst dogSarah = dogs.find(function(evento){\r\n    return evento.owners.includes(\"Sarah\");\r\n});\r\nconsole.log(`Sarah's dog is eating too ${dogSarah.curFood > dogSarah.recFood ? \"much\" : \"little\"}`);\r\n\r\n//3 \r\n// const ownersEatTooMuch = dogs.filter(evento => evento.curFood > evento.recFood).map(evento => evento.owners).flat();\r\nconst ownersEatTooMuch = dogs.filter(evento => evento.curFood > evento.recFood).flatMap(evento => evento.owners);\r\nconst ownersEatTooLittle = dogs.filter(evento => evento.curFood < evento.recFood).flatMap(evento => evento.owners);\r\n\r\n//4\r\nconsole.log(`${ownersEatTooMuch.join(\" and \") }'s dogs eat too much!`);\r\nconsole.log(`${ownersEatTooLittle.join(\" and \") }'s dogs eat too much!`);\r\n\r\n//5\r\nconsole.log(dogs.some(evento => evento.curFood === evento.recFood));\r\n\r\n//6. \r\nfunction checkEatingOkey(evento){\r\n    return evento => evento.curFood > evento.recFood * 0.9 && evento.curFood < evento.recFood * 1.1;\r\n}\r\nlet ss = dogs.some(checkEatingOkey)\r\nconsole.log(ss);\r\n\r\n//7.\r\nlet res = dogs.filter(checkEatingOkey)\r\nconsole.log(res);\r\n\r\n//8.\r\nconst dogsSorted = dogs.slice().sort((a, b) => a.recFood - b.recFood);\r\nconsole.log(dogsSorted); */\r\n\r\n/* //Ejemplo 32: Ejercicio practico con foreach(), split() y join().\r\nconst account1 = {\r\n    owner: 'Jonas Schmedtmann',\r\n    movements: [200, 450, -400, 3000, -650, -130, 70, 1300],\r\n    interestRate: 1.2, // %\r\n    pin: 1111,\r\n};\r\n\r\nconst account2 = {\r\n    owner: 'Jessica Davis',\r\n    movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30],\r\n    interestRate: 1.5,\r\n    pin: 2222,\r\n};\r\n\r\nconst account3 = {\r\n    owner: 'Steven Thomas Williams',\r\n    movements: [200, -200, 340, -300, -20, 50, 400, -460],\r\n    interestRate: 0.7,\r\n    pin: 3333,\r\n};\r\n\r\nconst account4 = {\r\n    owner: 'Sarah Smith',\r\n    movements: [430, 1000, 700, 50, 90],\r\n    interestRate: 1,\r\n    pin: 4444,\r\n};\r\n\r\nconst accounts = [account1, account2, account3, account4];\r\n\r\nfunction createUserNames (accs){\r\n    accs.forEach(function(num_acc){\r\n        num_acc.username = num_acc.owner.toLowerCase().split(\" \").map(name => name[0]).join(\"\"); // We create a new element (num_acc.username) that will contain the lower case letters of each owner's name\r\n    })\r\n}\r\n\r\ncreateUserNames(accounts);\r\nconsole.log(accounts); */\r\n\r\n/* //Ejemplo 33: Ejercicio practico con map(), filter() y reduce() y otros elementos de arrays\r\n// Let's go back to Julia and Kate's study about dogs. This time they want to convert dog ages to human ages and calculate the average age of the dogs in their study.\r\n// Create a function 'calcAverageHumanAge', which accepts an arrays of dog's ages ('ages'), and does the following things in order:\r\n// 1. Calculate the dog age in human years using the following formula: if the dog is <= 2 years old, humanAge = 2 * dogAge. If the dog is > 2 years old, humanAge = 16 + dogAge * 4\r\n// 2. Exclude all dogs that are less than 18 human years old (which is the same as keeping dogs that are at least 18 years old)\r\n// 3. Calculate the average human age of all adult dogs (you should already know from other challenges how we calculate averages)\r\n// 4. Run the function for both test datasets\r\n// Test Data 1: [5, 2, 4, 1, 15, 8, 3]\r\n\r\nlet array = [5, 2, 4, 1, 15, 8, 3];\r\n\r\nfunction calcAverageHumanAge(res){\r\n    let newArray = res.map(function(event){\r\n        if (event <= 2) {\r\n            return 2 * event;\r\n        }else if (event > 2) {\r\n            return 16 + (event * 4);\r\n        }\r\n    });\r\n    return newArray;\r\n}\r\n\r\n\r\nlet newArray = calcAverageHumanAge(array);\r\nconsole.log(\"The new array in human age is: \", newArray);\r\n\r\nlet arrayLess18 = newArray.filter(function(evento){\r\n    return evento > 18;\r\n});\r\nconsole.log(\"The new array with dogs that are less than 18 is: \", arrayLess18);\r\n\r\nlet averageAge = arrayLess18.reduce(function(acc, mov, i){\r\n    return (acc + mov);\r\n}, 0);\r\nconsole.log(\"The average human age of adult dogs is: \", (averageAge/arrayLess18.length)); */\r\n\r\n/* //Ejemplo 34: Mas ejemplos con arrays\r\nconst account1 = {\r\n    owner: 'Jonas Schmedtmann',\r\n    movements: [200, 450, -400, 3000, -650, -130, 70, 1300],\r\n    interestRate: 1.2, // %\r\n    pin: 1111,\r\n};\r\nconst account2 = {\r\n    owner: 'Jessica Davis',\r\n    movements: [5000, 3400, -150, -790, -3210, -1000, 8500, -30],\r\n    interestRate: 1.5,\r\n    pin: 2222,\r\n};\r\nconst account3 = {\r\n    owner: 'Steven Thomas Williams',\r\n    movements: [200, -200, 340, -300, -20, 50, 400, -460],\r\n    interestRate: 0.7,\r\n    pin: 3333,\r\n};\r\nconst account4 = {\r\n    owner: 'Sarah Smith',\r\n    movements: [430, 1000, 700, 50, 90],\r\n    interestRate: 1,\r\n    pin: 4444,\r\n};\r\nconst accounts = [account1, account2, account3, account4]; //Almacenamos la informacion de los 4 objetos en un array.\r\nconst mapa = accounts.map(function(evento){\r\n    return evento.movements;\r\n}); //console.log(mapa);\r\n\r\n// 1.\r\nconst bankDepositSum = accounts.flatMap(acc => acc.movements).filter(mov => mov > 0).reduce((sum, cur) => sum + cur, 0);\r\n// console.log(bankDepositSum);\r\n\r\n// 2.\r\n//const numDeposits1000 = accounts.flatMap(acc => acc.movements).filter(mov => mov >= 1000).length;\r\nconst numDeposits1000 = accounts.flatMap(acc => acc.movements).reduce((count, cur) => (cur >= 1000 ? ++count : count), 0); //Debemos colocar ++count porque si no, el numero siempre se mantendra en 0.\r\n// console.log(numDeposits1000);\r\n\r\n// 3.\r\nconst { deposits, withdrawals } = accounts.flatMap(acc => acc.movements).reduce((acc, cur) => {        \r\n        acc[cur > 0 ? 'deposits' : 'withdrawals'] += cur;  //cur > 0 ? (acc.deposits += cur) : (acc.withdrawals += cur);\r\n        return acc;\r\n    },{ deposits: 0, withdrawals: 0 });\r\n\r\n//console.log(deposits, withdrawals);\r\n\r\n// 4.\r\n// this is a nice title -> This Is a Nice Title\r\nfunction convertTitleCase(title) {\r\n    \r\n    function capitzalize(str){\r\n        return str[0].toUpperCase() + str.slice(1); //En la posicion 0, cambiamos la letra a mayuscula, y luego concatenamos con el \"+\", el resto de la palabra en la posicion [1]\r\n    }\r\n    \r\n    const exceptions = ['a', 'an', 'and', 'the', 'but', 'or', 'on', 'in', 'with'];\r\n\r\n    const titleCase = title\r\n    .toLowerCase()\r\n    .split(' ')\r\n    .map(evento => (exceptions.includes(evento) ? evento : capitzalize(evento)))\r\n    .join(' ');\r\n    return capitzalize(titleCase);\r\n};\r\n\r\nconsole.log(convertTitleCase('and here is another title with an EXAMPLE'));\r\nconsole.log(convertTitleCase('this is a LONG title but not too long')); */\r\n\r\n\r\n//         $$$$$$$$$$$$$$$ STRINGS & MODERN OPERATORS $$$$$$$$$$$$$$$\r\n\r\n\r\n/* // Ejemplo 1: uso de los operadores Suggar Syntax con operaciones aritméticas sencillas como +, -, /, *. Te dejo para que investigues cómo se realizaría la potenciación (exponenciación).\r\n\r\n// Operador adición ++ (en una sola unidad)\r\nlet num = 10;\r\nconsole.log(\"--> El valor actual del nùmero es \" + num);\r\nnum++;\r\nconsole.log(\"--> El valor actual del nùmero es\", {num}); \r\n\r\n// Operador sustracción -- (en una sola unidad)\r\nlet numB = 10;\r\nconsole.log(\"--> El valor actual del nùmero es \" + numB);\r\nnumB--;\r\nconsole.log(\"--> El valor actual del nùmero es\", {numB});\r\n\r\n// Aplicar los mismos operadores pero con dos valores\r\nlet numeroUno = parseInt(prompt(\"Ingrese el numero 1\"));\r\nlet numeroDOs = parseInt(prompt(\"Ingrese el numero 2\"));\r\n\r\n// Adición\r\nnumeroUno += numeroDOs;\r\nconsole.log(\"--> El resultado de la suma de los dos valores es\", {numeroUno});\r\n\r\n// Sustracción\r\nnumeroUno -= numeroDOs;\r\nconsole.log(\"--> El resultado de la resta de los dos valores es\", {numeroUno});\r\n\r\n// División\r\n/* numeroUno /= numeroDOs;\r\nconsole.log(\"--> El resultado de la división de los dos valores es\", {numeroUno});\r\n\r\n// Producto\r\nnumeroUno *= numeroDOs;\r\nconsole.log(\"--> El resultado de la multiplicación de los dos valores es\", {numeroUno}); */\r\n\r\n/* // Ejemplo 2: Uso del operador ternario (simplificación de la estructura IF-ELSE)\r\nlet tempt = 31;\r\nlet diaCaluroso;\r\n\r\ntempt > 30 ? (diaCaluroso = true) : (diaCaluroso = false);\r\n\r\nalert(\"--> La evalaución resulto \" + diaCaluroso); */\r\n\r\n/* // Ejemplo 4: Operador lógico AND\r\nlet carrito = [];\r\nlet carritox2 = [{id: 10, nombre: \"Play Station 5\"}];\r\n\r\n//(condición lógica) && (return si true);\r\n// El return por default en caso de false, es false.\r\n\r\ncarrito.length == 0 && console.log(\"--> El carrito está vacío\");\r\ncarritox2.length == 1 && console.log(\"--> El carritox2 está lleno\"); */\r\n\r\n/* // Ejemplo 5: Operador Lógico OR\r\n\r\n// Tabla que ejemplifica algunos de los valores que corresponden a Falsy\r\nconsole.log(\"Hola Mundo\" || \"Falsy\"); // Hola Mundo\r\nconsole.log(40 || \"Falsy\"); // 40\r\nconsole.log(true || \"Falsy\"); // true\r\nconsole.log(0 || \"Falsy\"); // Falsy\r\nconsole.log(\"\" || \"Falsy\"); // Falsy\r\nconsole.log(null || \"Falsy\"); // Falsy\r\nconsole.log(undefined || \"Falsy\"); // Falsy\r\nconsole.log(NaN || \"Falsy\"); // Falsy\r\nconsole.log(false || \"Falsy\"); // Falsy \r\n\r\nlet numero = 15;\r\nconst numerSelected = numero || 0 ;\r\nconsole.log(\"--> numerSelected\", {numerSelected}); */\r\n\r\n/* // Ejemplo 6: Nullish Coalescing\r\n// Tabla que ejemplifica algunos de los valores que corresponden a Falsy\r\n console.log(0 ?? \"Nullish\"); // 0\r\nconsole.log(40 ?? \"Nullish\"); // 40\r\nconsole.log(\"Hola Mundo\" ?? \"Nullish\"); // Hola Mundo\r\nconsole.log(\"\" ?? \"Nullish\"); // \"\"\r\nconsole.log(NaN ?? \"Nullish\"); // NaN\r\nconsole.log(true ?? \"Nullish\"); // true\r\nconsole.log(false ?? \"Nullish\"); // false\r\nconsole.log(null ?? \"Nullish\"); // Nullish\r\nconsole.log(undefined ?? \"Nullish\"); // Nullish */\r\n\r\n/* // Ejemplo 7: uso dep operador de acceso condicional ?\r\nconst usuarios = [];\r\nconst usuario = usuarios.find((u) => u.name == 100);\r\n\r\nconsole.log(usuario.nombre || \"El usuario no existe\"); //Error: \"No se pueden leer propiedades de NULL\"\r\nconsole.log(usuario?.nombre || \"El usuario no existe\"); //\"El usuario no existe\" */\r\n\r\n/* // Ejemplo 8: Uso del acceso condicional con más de un atributo (propiedad)\r\nconst days = [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"];\r\nconst openingHours = {\r\n        [days[3]]: {open: 12,close: 22,},\r\n        [days[4]]: {open: 11,close: 23,},\r\n        [days[5]]: {open: 0,close: 24,},\r\n    };\r\n\r\nconst restaurant = {\r\n    Name: 'Classico-Italiano',\r\n    location: 'Via Angelo Tavanti 23, Firenze, Italy',\r\n    categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],\r\n    starterMenu: ['Focaccia', 'Bruschetta', 'Garlic-Bread', 'Caprese-Salad'],\r\n    mainMenu: ['Pizza', 'Pasta', 'Risotto'],\r\n    info: [\r\n        {id: 1, nombre: \"german\"},\r\n        {id: 2, nombre: \"mancilla\"}\r\n    ],\r\n\r\n    openingHours, //openingHours: openingHours,    Ambas son lo mismo\r\n\r\n    order: function(starterIndex, mainIndex){\r\n        return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];\r\n    },\r\n};\r\n\r\nfor (const res of days) {\r\n    const open = restaurant?.openingHours[res]?.open ?? \"closed\";\r\n    console.log(`On ${res}, we open at ${open}`);\r\n}\r\n\r\nconsole.log(restaurant.order ?. (0,1) ?? \"Error\");\r\nconsole.log(restaurant.orderNew ?. (0,1) ?? \"Error\"); */\r\n\r\n/* // Ejemplo 9: Looping Objects: Object Keys, Values, and Entries\r\nconst days = [\"mon\", \"tue\", \"wed\", \"thu\", \"fri\", \"sat\", \"sun\"];\r\nconst openingHours = {\r\n        [days[3]]: {open: 12,close: 22,},\r\n        [days[4]]: {open: 11,close: 23,},\r\n        [days[5]]: {open: 0,close: 24,},\r\n    };\r\n\r\nconst restaurant = {\r\n    Name: 'Classico-Italiano',\r\n    location: 'Via Angelo Tavanti 23, Firenze, Italy',\r\n    categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],\r\n    starterMenu: ['Focaccia', 'Bruschetta', 'Garlic-Bread', 'Caprese-Salad'],\r\n    mainMenu: ['Pizza', 'Pasta', 'Risotto'],\r\n    info: [\r\n        {id: 1, nombre: \"german\"},\r\n        {id: 2, nombre: \"mancilla\"}\r\n    ],\r\n\r\n    openingHours, //openingHours: openingHours,    Ambas son lo mismo\r\n\r\n    order: function(starterIndex, mainIndex){\r\n        return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];\r\n    },\r\n};\r\n\r\nconst properties1 = openingHours; console.log(properties1);\r\nconst properties = Object.keys(openingHours); console.log(\"Object.keys()\", properties);\r\nconst values = Object.values(openingHours);  console.log(\"Object.values()\", values);\r\nconst entries = Object.entries(openingHours);  console.log(\"Object.entries()\", entries);\r\n\r\nlet openStr = `We are open on ${properties.length} days: `;\r\nfor (const day of properties) {\r\n    openStr = openStr + `${day}, `\r\n}\r\nconsole.log(openStr);\r\n\r\nfor (const [day, {open, close}] of entries) {\r\n    console.log(`On ${day} we open at ${open} and close at ${close}`);\r\n} */\r\n\r\n/* // Ejemplo 10: Desestructuración de arrays y objetos\r\nconst restaurant = {\r\n    Name: 'Classico-Italiano',\r\n    location: 'Via Angelo Tavanti 23, Firenze, Italy',\r\n    categories: ['Italian', 'Pizzeria', 'Vegetarian', 'Organic'],\r\n    starterMenu: ['Focaccia', 'Bruschetta', 'Garlic-Bread', 'Caprese-Salad'],\r\n    mainMenu: ['Pizza', 'Pasta', 'Risotto'],\r\n    info: [\r\n        {id: 1, nombre: \"german\"},\r\n        {id: 2, nombre: \"mancilla\"}\r\n    ],\r\n    fecharegistro: new Date(),\r\n    poseeTaarjetaCredito: false, \r\n    poseeVehiculo: true,\r\n\r\n    openingHours: {\r\n        thu: {open: 12,close: 22,},\r\n        fri: {open: 11,close: 23,},\r\n        sat: {open: 0,close: 24,},\r\n    },\r\n\r\n    order: function(starterIndex, mainIndex){\r\n        return [this.starterMenu[starterIndex], this.mainMenu[mainIndex]];\r\n    },\r\n\r\n    orderDelivery: function({time, address, mainIndex, starterIndex}){\r\n        return console.log(`Desestructuracion de un objecto usando funcion --> Order received! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`);\r\n    },\r\n\r\n    orderDeliveryX2: function({time=\"20:00\", address, mainIndex=0, starterIndex=1}){\r\n        return console.log(`Desestructuracion de un objecto usando funcion X2--> Order received! ${this.starterMenu[starterIndex]} and ${this.mainMenu[mainIndex]} will be delivered to ${address} at ${time}`);\r\n    }\r\n};\r\n\r\nconst [first, , second] = restaurant.categories; \r\nconsole.log(\"Desestructuracion de un array: \",first, second);\r\n\r\nconst [starter, main] = restaurant.order(2,0); \r\nconsole.log(\"Desestructuracion usando funcion: \",starter, main);\r\n\r\nconst nested = [2, 4, [5, 6]];\r\nconst [i, , [j, k]] = nested; \r\nconsole.log(\"Desestructuracion con Nested: \", i, j, k);\r\n\r\nconst [p=1, q=1, r=1] = [8, 9]; \r\nconsole.log(\"Desestructuracion con Default values: \", p, q, r);\r\n\r\nconst {Name, categories, openingHours, openingHours:{ sat }, info} = restaurant;\r\nconsole.log(\"Desestructuracion de un objeto: \", Name, categories, openingHours, sat, info, {info}); //Deconstruimos el objeto y se crean nuevas variables, las cuales son las que estan entre los corchetes. Se debe de igualar con el nombre del objeto.\r\n\r\n\r\nconst {Name: restaurantName, categories: tags, openingHours: hours} = restaurant;\r\nconsole.log(\"Desestructuracion de un objeto con uso del alias: \", restaurantName, tags, hours);\r\n\r\nconst { menu = [], starterMenu: starters = [] } = restaurant;\r\nconsole.log(\"Cambiando el nombre de la variable en objeto: \", menu, starters);\r\n\r\nlet a = 111, b = 999;\r\nconst obj = {\r\n    a: 23, b: 7, c: 14\r\n};\r\n\r\n({a, b} = obj);\r\nconsole.log(\"Desestructuracion de un objeto con mutating variables: \",a, b);\r\n\r\nconst { fri: {open: x, close: y} } = openingHours;\r\nconsole.log(\"Desestructuracion de un objeto con nested objects: \",x, y);\r\n\r\nfunction desestructurar(item){\r\n    const {Name, location} = item;\r\n    console.log(\"Desestructuracion en parámetros\", Name, location);\r\n}\r\ndesestructurar(restaurant);\r\n\r\nrestaurant.orderDelivery({\r\n    time: \"22:30\",\r\n    address: \"Tijuana, 22\",\r\n    mainIndex:\"2\", \r\n    starterIndex:\"2\"\r\n});\r\n\r\nrestaurant.orderDeliveryX2({\r\n    address: \"Tijuana, 22\",\r\n    starterIndex:\"1\"\r\n}); */\r\n\r\n/* // Ejemplo 11: Aplicación de la desestructuración para el evento del click\r\nwindow.addEventListener(\"click\", (event) => {\r\n    console.log(event.x, event.y);\r\n});\r\n\r\nwindow.addEventListener(\"click\", ({ x, y }) => {\r\n    console.log(x, y);\r\n}); */\r\n\r\n/* // Ejemplo 12: Operacion de spreading con Arrays\r\nconst nombres1 = [\"Juan\", \"Julieta\"], nombres2 = [\"Carlos\", \"Mariela\"];\r\nconst array = [...nombres1, ...nombres2]; // spread de los dos arrays dentro de otro\r\nconst nombresObjeto = {// spread del array en un objeto\r\n    ...array,\r\n};\r\n\r\nconsole.log(\"--> El nuevo array es: \" , array);\r\nconsole.log(\"--> El spread de un string se define como: \", [...nombres1[0]]);\r\nconsole.log(\"--> Si queremos agregar algo mas al array con spread, hacemos lo siguiente: \", [...array, \"German\"]);\r\nconsole.log(\"--> El resultado del spread del array en un objeto es\", nombresObjeto); // { '0': 'Juan', '1': 'Julieta', '2': 'Carlos', '3': 'Mariela' }\r\nconsole.log(\"--> Acceder a una propiedad especìfica es: \" + nombresObjeto[\"2\"]);\r\n\r\nconsole.log(\"\\n\");\r\n\r\nconst profile = {id_profile: 300, profile_name: \"Operador\", profile_created_date: new Date(), password: \"123\"};\r\nconst user = {id_name: 500, user_name: \"Chaman\", user_lastname: \"Coderhouse\", contact: {email: \"chaman.profe@gamail.com\", mobile: \"1111454545\"}};\r\nconst menus = {id_menus: 9, actions: [\"Ver operadores\", \"Editar nóminas\", \"Otorgar permisos\"]};\r\nconst userProfile = {...profile, id_profile: profile.id_profile, profile_name: profile.profile_name, password: undefined};\r\nconst allObjects = {...profile, ...user, ...menus};\r\nconsole.log(\"--> Los datos de los objetos Perfil y Usuario\", userProfile);\r\nconsole.log(\"--> Los datos del objeto con el spread de todos los objetos es: \", allObjects);\r\n\r\nconsole.log(\"\\n\");\r\n\r\nconst numeros = [4, 77, 92, 10, 3, -32, 54, 11];\r\nconsole.log(Math.max(numeros)); // NaN\r\nconsole.log(\"--> Spredading de Array: \", ...numeros, \"y el Math.max es: \", Math.max(...numeros));\r\nconsole.log(\"--> Equivalente a la anterior: \", Math.max(4, 77, 92, 10, 3, -32, 54, 11)); */\r\n\r\n/* // Ejemplo 13: Rest parameters\r\n\r\nsumar_1(10, 15, 30, 5, 13, 47, 98); // [10, 15, 30, 5, 13, 47, 98]\r\nconsole.log(\"Res 2: \", sumar_2(10, 15, 30, 5) ) // 60\r\n\r\nfunction sumar_1(...numeros) {\r\n    console.log(\"Res 1: \", numeros);\r\n}\r\n\r\nfunction sumar_2(...numeros) {\r\n    return numeros.reduce((acumulador, unProducto) => acumulador + unProducto, 0);\r\n} */\r\n\r\n/* // Ejemplo 14: Uso de Set\r\nconst orderSets = new Set([\"res\", \"german\", \"mancilla\", \"chavez\", \"res\", \"ss22\", \"res,\"])\r\nconsole.log(orderSets);\r\nconsole.log(orderSets.size);\r\nconsole.log(orderSets.has(\"pizza\"));\r\nconsole.log(orderSets.has(\"german\"));\r\norderSets.add(\"ps4\");\r\norderSets.add(\"ps8\")\r\norderSets.delete(\"res\")\r\nconsole.log(orderSets);\r\n\r\nfor (const order of orderSets) {\r\n    console.log(order);\r\n}\r\n\r\nconst staff = [\"waiter\", \"chef\", \"waiter\", \"manager\", \"chef\", \"waiter\"];\r\nconst staffUnique = [...new Set(staff)];\r\nconsole.log(staffUnique); */\r\n\r\n/* // Ejemplo 15: Uso de Map\r\nconst rest = new Map();\r\nrest.set('name', 'Classico Italiano');\r\nrest.set(1, 'Firenze, Italy');\r\nconsole.log(rest.set(2, 'Lisbon, Portugal'));\r\n\r\nrest.set('categories', ['Italian', 'Pizzeria', 'Vegetarian', 'Organic']).set('open', 11).set('close', 23).set(true, 'We are open :D').set(false, 'We are closed :(');\r\n\r\nconsole.log(rest.get('name'));\r\nconsole.log(rest.get(true));\r\nconsole.log(rest.get(1));\r\nconsole.log(rest.has('categories'));\r\nrest.delete(2);\r\n// rest.clear();\r\n\r\nconst time = 8;\r\nconsole.log(rest.get( time > (rest.get('open') && time < rest.get('close')) ));\r\n\r\nconst arr = [1, 2];\r\nrest.set(arr, 'Test');\r\nrest.set(document.querySelector('h1'), 'Heading');\r\nconsole.log(rest);\r\nconsole.log(rest.size);\r\nconsole.log(rest.get(arr)); */\r\n\r\n/* // Ejemplo 16: Uso de Map con iteration\r\n\r\n// Maps: Iteration\r\nconst question = new Map([\r\n    ['question', 'What is the best programming language in the world?'],\r\n    [1, 'C'],\r\n    [2, 'Java'],\r\n    [3, 'JavaScript'],\r\n    ['correct', 3],\r\n    [true, 'Correct 🎉'],\r\n    [false, 'Try again!'],\r\n]);         console.log(question);\r\n\r\n\r\nopeningHours = { thu: {open: 12,close: 22}, fri: {open: 11,close: 23}, sat: {open: 0,close: 24} }\r\nconsole.log(Object.entries(openingHours));\r\nconst hoursMap = new Map(Object.entries(openingHours));\r\nconsole.log(\"Convert object to map: \", hoursMap);\r\n\r\n// Quiz app\r\nconsole.log(question.get('question'));\r\nfor (const [key, value] of question) {\r\n    if (typeof key === 'number'){\r\n        console.log(`Answer ${key}: ${value}`);\r\n    }\r\n}\r\n\r\nconst answer = 3;\r\nconsole.log(question.get(question.get('correct') === answer));\r\n\r\n//Convert map to array\r\nconsole.log([...question]);\r\nconsole.log(question.entries());\r\n\r\nconsole.log([...question.keys()]);\r\nconsole.log([...question.values()]); */\r\n\r\n/* // Ejemplo 17: Split and join\r\nconsole.log('a+very+nice+string'.split('+'));\r\nconsole.log('Jonas Schmedtmann'.split(' '));\r\n\r\nconst [firstName, lastName] = 'Jonas Schmedtmann'.split(' ');\r\n\r\nconst newName = ['Mr.', firstName, lastName.toUpperCase()].join(' ');\r\nconsole.log(newName);\r\n\r\nconst capitalizeName = function (name) {\r\n    const names = name.split(' ');\r\n    const namesUpper = [];\r\n\r\n    for (const n of names) {\r\n        namesUpper.push(n[0].toUpperCase() + n.slice(1));\r\n        namesUpper.push(n.replace(n[0], n[0].toUpperCase()));\r\n    }\r\n    console.log(namesUpper.join(' '));\r\n};\r\n\r\ncapitalizeName('jessica ann smith davis');\r\ncapitalizeName('jonas schmedtmann'); */\r\n\r\n/* // Ejemplo 18: Padding\r\nconst message = 'Go to gate 23!';\r\nconsole.log(message.padStart(20, '+').padEnd(30, '+'));\r\nconsole.log('Jonas'.padStart(20, '+').padEnd(30, '+'));\r\n\r\nconst maskCreditCard = function (number) {\r\n    const str = number + \"\"; // Lo que esta a la derecha de number es para convertir el dato de tipo numero a string.\r\n    const last = str.slice(-4);\r\n    const res = last.padStart(str.length, '*');\r\n    return res;\r\n};\r\n\r\nconsole.log(maskCreditCard(64637836));\r\nconsole.log(maskCreditCard(43378463864647384));\r\nconsole.log(maskCreditCard('334859493847755774747')); */\r\n\r\n/* // Ejemplo 19: Repeat\r\nconst message2 = 'Bad waether... All Departues Delayed... ';\r\nconsole.log(message2.repeat(3));\r\n\r\nconst planesInLine = function (n) {\r\n    console.log(`There are ${n} planes in line ${'🛩'.repeat(n)}`);\r\n};\r\n\r\nplanesInLine(5);\r\nplanesInLine(3);\r\nplanesInLine(12); */\r\n\r\n/* // Ejemplo 20: Working With Strings - Part 1\r\nconst airline = 'TAP Air Portugal';\r\nconst plane = 'A320';\r\n\r\nconsole.log(plane[0]);\r\nconsole.log(plane[1]);\r\nconsole.log(plane[2]);\r\nconsole.log('B737'[0]);\r\n\r\nconsole.log(airline.length);\r\nconsole.log('B737'.length);\r\n\r\nconsole.log(airline.indexOf('r'));\r\nconsole.log(airline.lastIndexOf('r'));\r\nconsole.log(airline.indexOf('portugal'));\r\n\r\nconsole.log(airline.slice(4));\r\nconsole.log(airline.slice(4, 7));\r\n\r\nconsole.log(airline.slice(0, airline.indexOf(' ')));\r\nconsole.log(airline.slice(airline.lastIndexOf(' ') + 1));\r\n\r\nconsole.log(airline.slice(-2));\r\nconsole.log(airline.slice(1, -1));\r\n\r\nconst checkMiddleSeat = function (seat) {\r\n  // B and E are middle seats\r\n  const s = seat.slice(-1);\r\n  if (s === 'B' || s === 'E') console.log('You got the middle seat 😬');\r\n  else console.log('You got lucky 😎');\r\n};\r\n\r\ncheckMiddleSeat('11B');\r\ncheckMiddleSeat('23C');\r\ncheckMiddleSeat('3E');\r\n\r\nconsole.log(new String('jonas'));\r\nconsole.log(typeof new String('jonas'));\r\n\r\nconsole.log(typeof new String('jonas').slice(1)); */\r\n\r\n/* // Ejemplo 21: Working With Strings - Part 2\r\n\r\nconst airline = 'TAP Air Portugal';\r\n\r\nconsole.log(airline.toLowerCase());\r\nconsole.log(airline.toUpperCase());\r\n\r\n// Fix capitalization in name\r\nconst passenger = 'jOnAS'; // Jonas\r\nconst passengerLower = passenger.toLowerCase();\r\nconst passengerCorrect = passengerLower[0].toUpperCase() + passengerLower.slice(1);\r\nconsole.log(passengerCorrect);\r\n\r\n// Comparing emails\r\nconst email = 'hello@jonas.io';\r\nconst loginEmail = '  Hello@Jonas.Io \\n';\r\n\r\n// const lowerEmail = loginEmail.toLowerCase();\r\n// const trimmedEmail = lowerEmail.trim();\r\nconst normalizedEmail = loginEmail.toLowerCase().trim();\r\nconsole.log(normalizedEmail);\r\nconsole.log(email === normalizedEmail);\r\n\r\n// replacing\r\nconst priceGB = '288,97£';\r\nconst priceUS = priceGB.replace('£', '$').replace(',', '.');\r\nconsole.log(priceUS);\r\n\r\nconst announcement = 'All passengers come to boarding door 23. Boarding door 23!';\r\n\r\nconsole.log(announcement.replace('door', 'gate'));\r\n// console.log(announcement.replaceAll('door', 'gate'));\r\nconsole.log(announcement.replace(/door/g, 'gate'));\r\n\r\n// Booleans\r\nconst plane = 'Airbus A320neo';\r\nconsole.log(plane.includes('A320'));\r\nconsole.log(plane.includes('Boeing'));\r\nconsole.log(plane.startsWith('Airb'));\r\n\r\nif (plane.startsWith('Airbus') && plane.endsWith('neo')) {\r\n    console.log('Part of the NEW ARirbus family');\r\n}\r\n\r\n// Practice exercise\r\nconst checkBaggage = function (items) {\r\n    const baggage = items.toLowerCase();\r\n\r\n    if (baggage.includes('knife') || baggage.includes('gun')) {\r\n        console.log('You are NOT allowed on board');\r\n    } else {\r\n        console.log('Welcome aboard!');\r\n    }\r\n};\r\n\r\ncheckBaggage('I have a laptop, some Food and a pocket Knife');\r\ncheckBaggage('Socks and camera');\r\ncheckBaggage('Got some snacks and a gun for protection'); */\r\n\r\n/* // Ejemplo 22: Working With Strings - Part 3\r\n\r\n// 🔴 Delayed Departure from FAO to TXL (11h25)\r\n//              Arrival from BRU to FAO (11h45)\r\n//   🔴 Delayed Arrival from HEL to FAO (12h05)\r\n//            Departure from FAO to LIS (12h30)\r\n\r\nconst flights = '_Delayed_Departure;fao93766109;txl2133758440;11:25+_Arrival;bru0943384722;fao93766109;11:45+_Delayed_Arrival;hel7439299980;fao93766109;12:05+_Departure;fao93766109;lis2323639855;12:30';\r\n\r\n\r\n// console.log(flights.split(\"+\"));\r\nfor (const iter of flights.split(\"+\")) {\r\n    // console.log(iter.split(\";\"));\r\n    const [type, from, to, time] = iter.split(\";\");\r\n    const output = `${type.startsWith('_Delayed') ? '🔴' : \"\"} ${type.replaceAll(\"_\", \" \")} from ${getCode(from)} to ${getCode(to)} (${time.replace(\":\", \"h\")})`.padStart(45);\r\n    console.log(output);\r\n}\r\n\r\nfunction getCode(str){\r\n    return str.slice(0, 3).toUpperCase();\r\n} */\r\n\r\n/* // Ejemplo 23: Exercise for Data Structures, Modern Operators and Strings (1)\r\n// Suppose we get data from a web service about a certain game ('game' variable on next page). In this challenge we're gonna work with that data. Your tasks:\r\n\r\nconst game = {\r\n    team1: 'Bayern Munich',\r\n    team2: 'Borrussia Dortmund',\r\n    players: [\r\n        ['Neuer','Pavard','Martinez','Alaba','Davies','Kimmich','Goretzka','Coman','Muller','Gnarby','Lewandowski'],\r\n        ['Burki','Schulz','Hummels','Akanji','Hakimi','Weigl','Witsel','Hazard','Brandt','Sancho','Gotze']\r\n    ],\r\n    score: '4:0',\r\n    scored: ['Lewandowski', 'Gnarby', 'Lewandowski','Hummels'],\r\n    date: 'Nov 9th, 2017',\r\n    odds: {\r\n        team1: 1.33,\r\n        x: 3.25,\r\n        team2: 6.5,\r\n    }\r\n    \r\n};\r\n\r\n//1. Create one player array for each team (variables 'players1' and'players2')\r\nconst [players1,players2] = game.players;       //console.log(players1, players2);\r\n\r\n//2. The first player in any player array is the goalkeeper and the others are field players. For Bayern Munich (team 1) create one variable ('gk') with the goalkeeper's name, and one array ('fieldPlayers') with all the remaining 10 field players\r\nconst [gk, ...fieldPlayers] = players1;         //console.log(gk, fieldPlayers);\r\n\r\n//3. Create an array 'allPlayers' containing all players of both teams (22 players)\r\nconst allPlayers = [...players1, ...players1];  //console.log(allPlayers);\r\n\r\n//4. During the game, Bayern Munich (team 1) used 3 substitute players. So create a new array ('players1Final') containing all the original team1 players plus 'Thiago', 'Coutinho' and 'Perisic'\r\nconst players1Final = ['Thiago', 'Coutinho', 'Perisic', ...players1]; //console.log(players1Final);\r\n\r\n//5. Based on the game.odds object, create one variable for each odd (called 'team1', 'draw' and 'team2')\r\nconst {team1, x:draw, team2} = game.odds;   //console.log(team1, draw, team2);\r\n\r\n//6. Write a function ('printGoals') that receives an arbitrary number of player names (not an array) and prints each of them to the console, along with the number of goals that were scored in total (number of player names passed in)\r\nfunction printGoals(...players){ //Debemos desestructurar lo que mandamos a esta funcion tambien porque, al ser 4 elementos los que recibe, y si no hacemos eso, entonces unicamente se enviara el primer elemento y no los demas. \r\n    //console.log(players, \"and \"+ `${players.length}` + \" goals were scored\");\r\n}\r\nprintGoals(...game.scored);\r\n\r\n//7. The team with the lower odd is more likely to win. Print to the console which team is more likely to win, without using an if/else statement or the ternary operator. \r\nlet res = game.team2 > game.team1 && \"Team 2 is more likely to win!!\";  //console.log(res);\r\nlet res2 = game.team2 < game.team1 && \"Team 1 is more likely to win!!\";  //console.log(res2);\r\n\r\n//8. Loop over the game.scored array and print each player name to the console, along with the goal number (Example: \"Goal 1: Lewandowski\")\r\nfor (const [i, player] of game.scored.entries()) {\r\n    //console.log(`Goal ${i + 1}: ${player}`);\r\n}\r\n\r\n//9. Use a loop to calculate the average odd and log it to the console (We already studied how to calculate averages, you can go check if you don't remember)\r\nlet average = 0;\r\nfor (const odd of Object.values(game.odds)) {\r\n    average = average + odd/3;\r\n}\r\n//console.log(average);\r\n\r\n//10. Print the 3 odds to the console, but in a nice formatted way, exactly like this: Odd of victory Bayern Munich: 1.33, Odd of draw: 3.25, Odd of victory Borrussia Dortmund: 6.5\r\n//    Get the team names directly from the game object, don't hardcode them (except for \"draw\"). Hint: Note how the odds and the game objects have the same property names\r\nfor (const [team, odd] of Object.entries(game.odds)) {\r\n    let res = ( team === \"x\" ? \"draw\" : (\"victory \"+ game[team]) ); // team retorna un string, en este caso, sera team1 y team2. Pero, al ser ambos de tipo STRING, quiere decir que vienen de esta forma \"team1\" y \"team2\". Por eso al final queda game[team], si necesidad de poner los \"\".\r\n    //console.log(`Odd of ${res}: ${odd}`);\r\n}\r\n\r\n//11. Create an object called 'scorers' which contains the names of the players who scored as properties, and the number of goals as the value: { Gnarby: 1, Hummels: 1, Lewi: 2}\r\nconst scorers = {};\r\nfor (const player of game.scored) {\r\n    scorers[player] ? scorers[player]++ : (scorers[player] = 1);//En la primer y segunda iteracion no existe nada. No es hasta la tercera iteracion cuando ahi se repite \"Lewandowski\", por lo que ahora en este caso, se le suma 1.\r\n};      //console.log(scorers);\r\n\r\nconst gameEvents = new Map([\r\n    [17, '⚽ GOAL'],\r\n    [36, '↩️ Substitution'],\r\n    [47, '⚽ GOAL'],\r\n    [61, '↩️ Substitution'],\r\n    [64, '🟨 Yellow card'],\r\n    [69, '🟥 Red card'],\r\n    [70, '↩️ Substitution'],\r\n    [72, '↩️ Substitution'],\r\n    [76, '⚽ GOAL'],\r\n    [80, '⚽ GOAL'],\r\n    [92, '🟨 Yellow card'],\r\n]);\r\n\r\n\r\n// 12. Create an array 'events' of the different game events that happened (no duplicates)\r\nconst events = new Set((gameEvents.values()));   console.log(events);\r\n\r\n// 13. After the game has finished, is was found that the yellow card from minute 64 was unfair. So remove this event from the game events log.\r\ngameEvents.delete(64);   console.log(gameEvents.values());\r\n\r\n// 14. Compute and log the following string to the console: \"An event happened, on average, every 9 minutes\" (keep in mind that a game has 90 minutes)\r\nconsole.log(`An event happened, on average, every ${(90/gameEvents.size)} minutes`);\r\nconst des = [...gameEvents.keys()].pop();\r\n\r\n// 15. Loop over 'gameEvents' and log each element to the console, marking whether it's in the first half or second half (after 45 min) of the game: [FIRST HALF] 17: ⚽ GOAL\r\nfor (const [key, value] of gameEvents) {\r\n    console.log( key < 45 ? `[FIRST HALF] ${key + \": \" + value}` : `[SECOND HALF] ${key + \": \" + value}` );\r\n} */\r\n\r\n/* // Ejemplo 24: Exercise for Data Structures, Modern Operators and Strings (2)\r\n// Write a program that receives a list of variable (SEE BELOW) names written in underscore_case and convert them to camelCase.\r\n\r\n// underscore_case\r\n//  first_name\r\n// Some_Variable\r\n//   calculate_AGE\r\n// delayed_departure\r\n\r\n// Should produce this output (5 separate console.log outputs):\r\n// underscoreCase    ✅\r\n// firstName         ✅✅\r\n// someVariable      ✅✅✅\r\n// calculateAge      ✅✅✅✅\r\n// delayedDeparture  ✅✅✅✅✅\r\n\r\n// Hints:\r\n// § Remember which character defines a new line in the textarea\r\n// § The solution only needs to work for a variable made out of 2 words, like a_b\r\n// § Start without worrying about the ✅. Tackle that only after you have the variable name conversion working \r\n\r\n\r\ndocument.body.append(document.createElement('textarea'));\r\n\r\nlet btn = document.createElement(\"button\");\r\nbtn.innerHTML = \"Click Me\";\r\ndocument.body.append(btn);\r\n\r\ndocument.querySelector(\"button\").addEventListener(\"click\", function(){\r\n    const text = document.querySelector(\"textarea\").value;\r\n    const rows = text.split(\"\\n\");\r\n\r\n    for (const [i, iter] of rows.entries()) {\r\n        let [first, second] = iter.toLowerCase().trim().split(\"_\");\r\n        let output = `${first}${second.replace(second[0], second[0].toUpperCase())}`;\r\n        console.log(`${output.padEnd(20, \" \")}${\"✅\".repeat(i + 1)}`);\r\n    }\r\n}); */\r\n\r\n\r\n//         $$$$$$$$$$$$$$$ Numbers, dates, Intl and timers $$$$$$$$$$$$$$$\r\n\r\n\r\n/* //Ejemplo 1: Conversion, Parseo y verificar si es un numero, indefinido o infinito\r\n//Convertion\r\nconsole.log(Number(\"23\"));\r\nconsole.log(+\"23\");\r\nconsole.log(parseInt(\"23\"));\r\n\r\n//Parsing\r\nconsole.log(\"\\n\");\r\nconsole.log(Number.parseInt('30px', 10));\r\nconsole.log(Number.parseInt('e23', 10));\r\nconsole.log(Number.parseInt('  2.5rem  '));\r\nconsole.log(Number.parseFloat('  2.5rem  '));\r\n\r\n// Check if value is NaN\r\nconsole.log(\"\\n\");\r\nconsole.log(Number.isNaN(20));\r\nconsole.log(Number.isNaN('20'));\r\nconsole.log(Number.isNaN(+'20X'));\r\nconsole.log(Number.isNaN(23 / 0));\r\n\r\n// Checking if value is number\r\nconsole.log(\"\\n\");\r\nconsole.log(Number.isFinite(20));\r\nconsole.log(Number.isFinite('20'));\r\nconsole.log(Number.isFinite(+'20X'));\r\nconsole.log(Number.isFinite(23 / 0));\r\n\r\n// Checking if value is number\r\nconsole.log(\"\\n\");\r\nconsole.log(Number.isInteger(23));\r\nconsole.log(Number.isInteger(23.0));\r\nconsole.log(Number.isInteger(23 / 0)); */\r\n\r\n/* //Ejemplo 2: Acceso a propiedades del objeto Math, y metodo Min y Max. \r\nconsole.log(\"--> euler: \"+ Math.E);\r\nconsole.log(\"--> pi: \"+ Math.PI);\r\nconsole.log(\"--> sqrt: \"+ Math.sqrt(25));\r\nconsole.log(\"--> sqrt: \"+ 25**(1/2));\r\n\r\nconst numeros = [55, 13, -25, 93, 4]; \r\nconsole.log(\"Los numeros SIN spread son: \",numeros);\r\nconsole.log(\"Los numeros CON spread son: \",...numeros); //... pasan de un array a cada numero separado de manera individual\r\nconst minimo = Math.min(...numeros); \r\nconst maximo = Math.max(...numeros);\r\nconsole.log(\"El menor es: \", minimo);\r\nconsole.log(\"El mayor es: \", maximo); */\r\n\r\n/* //Ejemplo 3: Use of numeric separators\r\nconst diameter = 287_460_000_000;// 287,460,000,000\r\nconsole.log(diameter);\r\n\r\nconst price = 345_99;\r\nconsole.log(price);\r\n\r\nconst transferFee1 = 15_00;\r\nconst transferFee2 = 1_500;\r\n\r\nconst PI = 3.1415;\r\nconsole.log(PI);\r\n\r\nconsole.log(Number('230_000'));   //NaN\r\nconsole.log(parseInt('230_000')); //230000 */\r\n\r\n/* //Ejemplo 4: Aplicacion para metodo de redondeo con ceil, floor, round y Aplicacion para metodo de raiz cuadrada\r\nconsole.log(Math.ceil(.95));   // Expected output: 1\r\nconsole.log(Math.ceil(4));     // Expected output: 4\r\nconsole.log(Math.ceil(7.004)); // Expected output: 8\r\nconsole.log(Math.ceil(-7.004));// Expected output: -7\r\n\r\nconsole.log(\"\\n\");\r\n\r\nconsole.log(Math.trunc(20.49));  // Expected output: 20\r\nconsole.log(Math.trunc(20.50));  // Expected output: 20\r\nconsole.log(Math.trunc(-20.50)); // Expected output: -20\r\nconsole.log(Math.trunc(-20.51)); // Expected output: -20\r\n\r\nconsole.log(\"\\n\");\r\n\r\nconsole.log(Math.floor(.95));    // Expected output: 0\r\nconsole.log(Math.floor(4));      // Expected output: 4\r\nconsole.log(Math.floor(7.004));  // Expected output: 7\r\nconsole.log(Math.floor(-7.004)); // Expected output: -8\r\n\r\nconsole.log(\"\\n\");\r\n\r\nconsole.log(Math.round(20.49));   // Expected output: 20\r\nconsole.log(Math.round(20.50));   // Expected output: 21\r\nconsole.log(Math.round(-20.50));  // Expected output: -20\r\nconsole.log(Math.round(-20.51));  // Expected output: -21\r\n\r\nconsole.log(\"\\n\");\r\n\r\nconsole.log(+Math.sqrt(9).toFixed(4));\r\nconsole.log(+Math.sqrt(2).toFixed(6));\r\nconsole.log(+(2.7).toFixed(0));\r\nconsole.log(+(2.345).toFixed(2)); */\r\n\r\n/* //Ejemplo 5: Uso del metodo random para la generacion de numeros psudo-aleatorios, entre [0, 1), entre [0, limite) y entre [limiteInferior, limiteSuperior).\r\n\r\nfor (let i = 0; i < 5; i++) {\r\n    console.log(Math.random());\r\n}\r\n\r\nconsole.log(\"\\n\");\r\n\r\nfor (let i = 0; i < 5; i++) { \r\n    console.log(Math.random()*10);\r\n}\r\n\r\nconsole.log(\"\\n\");\r\n\r\nlet limiteInferior = parseInt(0); \r\nlet limiteSuperior = parseInt(10);\r\n\r\nfor (let i = 0; i < 5; i++) {\r\n    const x = generateRandomNumber(limiteInferior, limiteSuperior);\r\n    console.log(x);\r\n}\r\n\r\nfunction generateRandomNumber (limiteInferior, limiteSuperior){\r\n    return Math.trunc(Math.random()*(limiteSuperior-limiteInferior) + 1) + limiteInferior;  // De 1 a 10\r\n    //return Math.trunc(Math.random()*(limiteSuperior-limiteInferior) + limiteInferior);    // De 0 a 9\r\n} */\r\n\r\n/* //Ejemplo 6: Uso de BigInt\r\nconsole.log(2 ** 53 - 1); //The biggest number in JS\r\nconsole.log(Number.MAX_SAFE_INTEGER);\r\nconsole.log(2 ** 53 + 1); //This numbers and the next three are unstable ones and must not be used.\r\nconsole.log(2 ** 53 + 2);\r\nconsole.log(2 ** 53 + 3);\r\nconsole.log(2 ** 53 + 4);\r\n\r\nconsole.log(4838430248342043823408394839483204n);\r\nconsole.log(BigInt(48384302));\r\n\r\n// Operations\r\nconsole.log(10000n + 10000n);\r\nconsole.log(36286372637263726376237263726372632n * 10000000n);\r\n// console.log(Math.sqrt(16n));\r\n\r\nconst huge = 20289830237283728378237n;\r\nconst num = 23;\r\nconsole.log(huge * BigInt(num));\r\n\r\n// Exceptions\r\nconsole.log(20n > 15);\r\nconsole.log(20n === 20);\r\nconsole.log(typeof 20n);\r\nconsole.log(20n == '20');\r\n\r\n// Divisions\r\nconsole.log(11n / 3n); //It shows only the integer.\r\nconsole.log(11 / 3);   //It shows the number with decimals. */\r\n\r\n/* //Ejemplo 7: Obtener la fecha y hora actuales. Creacion de instancias de objetos Date con la clase date con fechas personalizadas. Y obtener datos de las fechas en formato STRING.\r\nlet fechaActual = new Date();  console.log(\"La fecha actual del sistema es: \", fechaActual);\r\nlet fecha1 = new Date(2023, 3, 22);  console.log(\"La fecha actual del sistema es: \", fecha1);\r\nlet fecha2 = new Date(2023, 11, 24, 23, 59, 59);  console.log(\"La fecha actual de navidad es: \", fecha2); \r\nlet fecha3 = new Date(\"Aug 02 2023 18:05:41\" );  console.log(\"La fecha actual de navidad es: \", fecha3); \r\nlet fecha4 = new Date(\"December 17, 2021\" ); console.log(\"La fecha actual de navidad es: \", fecha4); \r\n\r\nconsole.log(\"\\n\", \"Los valores singulares de la fecha de navidad son: \",{\r\n    year: fecha2.getFullYear(),\r\n    month: fecha2.getMonth(),\r\n    date: fecha2.getDate(), \r\n    week: fecha2.getDay(),\r\n    hour: fecha2.getHours(),\r\n    minute: fecha2.getMinutes(),\r\n    second: fecha2.getSeconds(),\r\n    isoString: fecha2.toISOString(),\r\n    time: fecha2.getTime()\r\n});\r\n\r\n//Obtener los datos de las fechas en cadenas de texto (STRING)\r\nconsole.log(\"\\n\"+ \"toDateString: \", fechaActual.toDateString());\r\nconsole.log(\"toLocalString: \", fechaActual.toLocaleString());\r\nconsole.log(\"toLocalDateString: \", fechaActual.toLocaleDateString());\r\nconsole.log(\"toTimeString: \", fechaActual.toTimeString());\r\nconsole.log(\"toLocaleTimeString: \", fechaActual.toLocaleTimeString());\r\n\r\n//Creamos una nueva fecha, y despues logeamos esa fecha sin necesidad de poner \"new\"\r\nconsole.log(\"\\n\"+ new Date(1690259566417));\r\nconsole.log(Date.now());\r\n\r\n//Convertir una fecha a numero\r\nconst future = new Date(2037, 10, 19, 15, 23);\r\nconsole.log(\"\\n\"+\"La fecha convertida en milisegundos es: \"+ (+future));\r\n\r\n//Calcular la diferencia entre 2 fechas (diferencia = fechaSuperior - fechaInferior)\r\nlet fechaMiCumple = new Date(2024, 3, 22);\r\nlet hoy = new Date();\r\nconst diferencia = fechaMiCumple - hoy; // Marca de timempo (milisegundos)\r\nconst milisegundosPorDia = 86400000;    // 86400000mS = 86400s = 1440min = 24h\r\nconsole.log(\"\\n\"+ \"--> La diferencia de fechas entre hoy y mi cumpleanos es: \" + Math.round((diferencia/milisegundosPorDia))); */\r\n\r\n/* //Ejemplo 8: Internationalizing Dates (Intl)\r\nconst now = new Date();\r\nconst options = {\r\n    hour:\"numeric\",\r\n    minute: \"numeric\",\r\n    day: \"numeric\",\r\n    month: \"long\",\r\n    year: \"numeric\",\r\n    weekday: \"long\"\r\n}\r\n\r\nconst locale = navigator.language;\r\nconst res = new Intl.DateTimeFormat(locale, options).format(now);\r\n// const res = new Intl.DateTimeFormat(\"pt-PT\", options).format(now);\r\nconsole.log(res); */\r\n\r\n/* //Ejemplo 9: Internationalizing Numbers (Intl)\r\nconst num = 3884764.23;\r\n\r\nconst options = {\r\n    style: 'currency',\r\n    unit: 'celsius',\r\n    currency: 'EUR',\r\n    // useGrouping: false,\r\n};\r\n\r\nconsole.log('US:      ', new Intl.NumberFormat('en-US', options).format(num));\r\nconsole.log('Germany: ', new Intl.NumberFormat('de-DE', options).format(num));\r\nconsole.log('Syria:   ', new Intl.NumberFormat('ar-SY', options).format(num));\r\nconsole.log(navigator.language,new Intl.NumberFormat(navigator.language, options).format(num)); */\r\n\r\n\r\n//         $$$$$$$$$$$$$$$ DOM & EVENTOS $$$$$$$$$$$$$$$\r\n\r\n\r\n/* //Ejemplo 1: Acceso a la variable global document y sus propiedades\r\nconsole.log(\"Cual es nuestro documento? \", document.documentElement);\r\nconsole.log(\"Cual es nuestro body? \", document.body);\r\nconsole.log(\"Cual es nuestro head? \", document.head); */\r\n\r\n/* //Ejemplo 2: Obtener un elemento del HTML a partir de su id, clase o etiqueta HTML. Y tambien acceder a un elemento con el querySelector y querySelectorAll\r\nconsole.log(\"Acceder a un elemento con el querySelector\", document.querySelector(\"#formulario_HTML .mb-3\"));\r\nconsole.log(\"Acceder a un elemento con el querySelectorAll\", document.querySelectorAll(\"#formulario_HTML .mb-3\"));\r\nconsole.log(\"Obtener un elemento del HTML a partir de su id: \", document.getElementById(\"bienvenida\"));\r\nconsole.log(\"Obtener un elemento del HTML a partir de su clase: \",document.getElementsByClassName(\"texto\"));\r\nconsole.log(\"Obtener un elemento del HTML a partir de su etiqueta HTML: \", document.getElementsByTagName(\"p\")); */\r\n\r\n/* //Ejemplo 3: Recorrer una coleccion de nodos devueltos por alguna query\r\nlet items = document.getElementsByTagName(\"h1\");\r\nconsole.log(\"Los elementos de nuestra pagina que estan fabricados a partir de la etiqueta h1 son: \",items);\r\n\r\nfor (const unItem of items) {\r\n    console.log(\"--> \", unItem);\r\n} */\r\n\r\n/* //Ejemplo 4: Como modificamos el contenido del texto de un nodo\r\nlet frase_obtenida = \"Hola, bienvenidos a la clase de Javascript 😈\";\r\nlet nodo = document.getElementById(\"titulo\");\r\nconsole.log(\"El texto original que modificaremos es: \", document.getElementById(\"titulo\").innerText);\r\nnodo.innerText = frase_obtenida;\r\n\r\ndocument.getElementById(\"subtitulo\").className = \"coloreado\";\r\ndocument.getElementById('frase').classList.add('coloreadoX2');\r\n\r\ndocument.getElementById(\"subtitulo\").innerHTML = \"<strong>Hola soy german!!</strong>\";\r\ndocument.getElementById(\"frase\").innerText = \"Hola\";\r\ndocument.getElementById(\"bienvenida\").textContent = \"Adios\"; */\r\n\r\n/* //Ejemplo 5: Crear una lista de elementos a partir del contenido de un array y luego eliminar nodos\r\nlet paises = [\"Argentina\", \"Brazil\", \"Mexico\", \"Peru\", \"Suecia\"];\r\n\r\nlet nodoPaises = document.getElementById(\"paises\"); //Obtenemos el elemento \"paises\" del HTML\r\nnodoPaises.innerHTML = \"\"; //Al dejar las comillas vacias, se borra el contenido del elemento \"paises\" en el HTML.\r\n\r\nfor (const unPais of paises) {\r\n    let nuevoItem = document.createElement(\"li\"); //Creamos un elemento \"li\" para el elemento \"ul\" del HTML\r\n    nuevoItem.innerText = unPais; //Le agregamos el nombre que se encuentra en la posicin \"unPais\". Que va desde \"Argentina\" hasta \"Suecia\".\r\n    nodoPaises.append(nuevoItem); //Una vez que creamos el nuevo elemento \"li\", es importante AGREGARLO, ya que unicamente lo creamos en la linea anterior.\r\n}\r\n\r\nlet paisesRecuperados = document.querySelector(\"li\");\r\nconsole.log(\"-->\", paisesRecuperados);\r\npaisesRecuperados[2].remove(); */\r\n\r\n/* //Ejemplo 6: Creacion de un elemento HTML en JS, añadicion de nodos en determinada posicion, y eliminacion de nodos.\r\nconst message = document.createElement('div');\r\nmessage.classList.add('cookie-message');\r\nmessage.innerHTML = 'We use cookied for improved functionality and analytics. <button class=\"res\">Got it!</button>';\r\nconst body = document.querySelector('body');\r\nbody.append(message);                 //Sirve para colocar el nodo al final\r\n// body.append(message.cloneNode(true)); //Sirve para duplicar el nodo y colocarlo debajo del principal\r\n// body.prepend(message);                //Sirve para colocar el nodo al inicio\r\n// body.after(message);                  //Cumple la misma funcion que body.append(message)\r\n// body.before(message);                 //Cumple la misma funcion que body.prepend(message)\r\n\r\ndocument.querySelector('.res').addEventListener('click', function () {\r\n    // message.remove();\r\n    message.parentElement.removeChild(message);\r\n}); */\r\n\r\n/* //Ejemplo 7: Escribir dentro de los inputs a travez del .value\r\ndocument.getElementById(\"nombres\").value = \"Cual es tu nombre?\";\r\ndocument.getElementById(\"apellidos\").value = \"Cual es tu apellido?\"; */\r\n\r\n/* //Ejemplo 8: Uso de plantillas\r\nconst producto = {id: 1001, nombre: \"Carne asada\", precio: 140};\r\n\r\n//Creamos un elemento div \r\nlet contenedor = document.createElement(\"div\");\r\n\r\n//Definimos el innerHTML del elemento con una plantilla de texto\r\ncontenedor.innerHTML = `<h3> ID: ${producto.id}</h3>\r\n                        <p> Producto: ${producto.nombre}</p>\r\n                        <b> $ ${producto.precio}</b>`;\r\n\r\n//Agregamos el contenedor creado al body\r\ndocument.body.appendChild(contenedor);\r\n\r\n//Formas de concatenar o mostrar en pantalla\r\nlet concatenado = \"id: \"+ producto.id+\" - Nombre: \"+ producto.nombre + \" - precio: $\"+ producto.precio;   console.log(\"Concatenado\", concatenado);\r\nlet plantilla = `id: ${producto.id} - Nombre: ${producto.nombre} - Precio: $${producto.precio}`;          console.log(\"Plantilla  \", plantilla);  */\r\n\r\n/* //Ejemplo 9: Agregar un elemento con estilizado\r\n//METODO 1\r\nconst producto1 = {id: 1001, nombre: \"Carne asada\", precio: 140};\r\nlet contenedor1 = document.createElement(\"div\");\r\ncontenedor1.style.marginTop = \"50px\";\r\ncontenedor1.style.marginBottom = \"50px\";\r\ncontenedor1.style.padding = \"40px\";\r\ncontenedor1.style.borderRadius = \"20px\";\r\ncontenedor1.style.background = \"rgb(1, 135, 108)\";\r\ncontenedor1.style.color = \"rgb(250, 255, 255)\";\r\ncontenedor1.style.opacity = \"0.8\";\r\ncontenedor1.innerHTML = `<h3> ID: ${producto1.id}</h3><p> Producto: ${producto1.nombre}</p><b> $ ${producto1.precio}</b>`;\r\ncontenedor1.className = 'border pad';\r\ndocument.getElementById(\"main\").append(contenedor1); //append coloca el hijo hasta el final, mientras que el prepend coloca el hijo hasta el inicio.\r\n// document.body.appendChild(contenedor1);\r\n\r\n\r\n//METODO 1.2\r\nconst producto2 = {id: 1001, nombre: \"Carne asada\", precio: 140};\r\nlet contenedor2 = document.createElement(\"div\");\r\ncontenedor2.classList.add(\"res\");\r\n// contenedor2.textContent = \"Hello world!\";\r\ncontenedor2.innerHTML = `<h3> ID: ${producto2.id}</h3><p> Producto: ${producto2.nombre}</p><b> $ ${producto2.precio}</b>`;\r\ncontenedor2.className = 'border pad';\r\ndocument.getElementById(\"main\").append(contenedor2); //append coloca el hijo hasta el final, mientras que el prepend coloca el hijo hasta el inicio.\r\n// document.body.appendChild(contenedor2);\r\n\r\n\r\n// METODO 2.1\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n    const producto3 = {id: 1001, nombre: \"Carne asada\", precio: 140};\r\n    let contenedor3 = document.createElement(\"div\");\r\n    contenedor3.style.marginTop = \"50px\";\r\n    contenedor3.style.marginBottom = \"50px\";\r\n    contenedor3.style.padding = \"40px\";\r\n    contenedor3.style.borderRadius = \"20px\";\r\n    contenedor3.style.background = \"rgb(1, 135, 108)\";\r\n    contenedor3.style.color = \"rgb(250, 255, 255)\";\r\n    contenedor3.style.opacity = \"0.8\";\r\n    contenedor3.innerHTML = `<h3> ID: ${producto3.id}</h3><p> Producto: ${producto3.nombre}</p><b> $ ${producto3.precio}</b>`;\r\n    contenedor3.className = 'border pad';\r\n    document.getElementById(\"main\").append(contenedor3); //append coloca el hijo hasta el final, mientras que el prepend coloca el hijo hasta el inicio.\r\n    // document.body.appendChild(contenedor3);\r\n}, true);\r\n\r\n\r\n// METODO 2.2\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n    const producto4 = {id: 1001, nombre: \"Carne asada\", precio: 140};\r\n    let contenedor4 = document.createElement(\"div\");\r\n    contenedor4.classList.add(\"res\");\r\n    // contenedor4.textContent = \"Hello world!\";\r\n    contenedor4.innerHTML = `<h3> ID: ${producto4.id}</h3><p> Producto: ${producto4.nombre}</p><b> $ ${producto4.precio}</b>`;\r\n    contenedor4.className = 'border pad';\r\n    document.getElementById(\"main\").append(contenedor4); //append coloca el hijo hasta el final, mientras que el prepend coloca el hijo hasta el inicio.\r\n    // document.body.appendChild(contenedor4);\r\n}, true); */\r\n\r\n/* //Ejemplo 10: Agregar eventos a un nodo mediante el addEventListener y mediante la propiedad con el evento necesario\r\n\r\n// METODO 1.1\r\nconst btnInscribir = document.getElementById(\"btnInscribir\");\r\nbtnInscribir.addEventListener(\"click\", function() {\r\n    console.log(\"Hola\");\r\n});\r\n\r\n//METODO 1.2\r\nfunction saludar() {\r\n    console.log(\"Hola, bienvenido!\")\r\n}\r\nconst btnInscribir = document.getElementById(\"btnInscribir\");\r\nbtnInscribir.addEventListener(\"click\", saludar);\r\n\r\n//METODO 2.1\r\nconst btnInscribir = document.getElementById(\"btnInscribir\");\r\nbtnInscribir.onclick = function() {\r\n    console.log(\"Hola, bienvenido!\")\r\n};\r\n\r\n// METODO 2.2\r\nfunction saludar() {\r\n    console.log(\"Hola!\")\r\n}\r\nconst btnInscribir = document.getElementById(\"btnInscribir\");\r\nbtnInscribir.onclick = function(){\r\n    saludar();\r\n} */\r\n\r\n/* //Ejemplo 11: Agregar eventos a un nodo mediante el atributo de evento de la etiqueta (No es recomendable usar en proyectos de produccion)\r\n//Esto va en el HTML, dentro del form (Esto va en el HTML, NO en el documento .js)\r\n//<button type=\"button\" class=\"btn btn-primary\" id=\"btnInscribir\" onclick=\"alert('Hola Mundo!');\">Inscribir</button> */\r\n\r\n/* //Ejemplo 12: Agregar a un nodo el evento del movimiento del mouse, los eventos de keydown y keyup para un input, el evento change y el evento input.\r\n\r\n//Uso del mousemove\r\nconst title = document.getElementsByTagName(\"h1\")[0]; //[0] representa el numero de los h1 que se encuentran en el HTML. Como en este caso solo hay uno, entonces inicializa en 0 y asi sucesivamente, dependiendo del tipo de etiqueta que estemos utilizando.\r\nconsole.log(\"--> H1\", title);\r\ntitle.addEventListener(\"mousemove\",() => {\r\n    console.log(\"--> El mouse se esta moviendo sobre el titulo de la pagina <--\")\r\n});\r\n\r\n//Uso del mouseenter\r\nconst title2 = document.querySelector(\"h1\");\r\nconst res = function(evento){\r\n    alert(\"--> El mouse se esta moviendo solo una vez <--\");\r\n}\r\n\r\ntitle2.addEventListener(\"mouseenter\", res);\r\nsetTimeout(() => title2.removeEventListener(\"mouseenter\", res), 3000);\r\n\r\n//Uso del keydown\r\nconst input1 = document.getElementById(\"apellidos\");  //Agregar a un nodo los eventos de keydown y keyup para un input.\r\ninput1.addEventListener(\"keydown\",() => {\r\n    console.log(\"--> La tecla bajo <--\")\r\n})\r\n\r\n//Uso del keyup\r\ninput1.addEventListener(\"keyup\",() => {\r\n    console.log(\"--> La tecla subio <--\")\r\n})\r\n\r\n//Uso del change\r\nconst input2 = document.getElementById(\"nombres\"); //Agregar a un nodo el evento change.\r\ninput2.addEventListener(\"change\",() => {\r\n    console.log(\"--> El valor del input cambio <--\", input2.value);\r\n    input2.value = input2.value.trim();\r\n});\r\n\r\n//Uso del input\r\nconst input3 = document.getElementById(\"correo\"); //Agregar a un nodo el evento change (Simulando un keylogger).\r\ninput3.addEventListener(\"input\",() => {\r\n    console.log(\"--> Ejecutaste el evento INPUT <--\");\r\n}); */\r\n\r\n/* //Ejemplo 13: uso del evento submit para validar los inputs de un formulario.\r\n\r\n//Para agregar opciones al select HTML del HTML cuando presionemos el recuadro.\r\nclass Ocupacion {\r\n    constructor(numero, name) {\r\n        this.numero = numero;\r\n        this.nombre = name;\r\n    }\r\n}\r\n\r\nconst ocupaciones = [\r\n    new Ocupacion(1, \"Estudiante\"),\r\n    new Ocupacion(2, \"Docente\"),\r\n    new Ocupacion(3, \"Desarrollador\"),\r\n    new Ocupacion(4, \"Administrador de proyectos\"),\r\n];\r\n\r\nlet ocupacionList = document.getElementById(\"ocupacion\");\r\n\r\nocupaciones.forEach((unaOcupacion) => {\r\n    let item = document.createElement(\"option\");\r\n    item.value = unaOcupacion.numero.toString();\r\n    item.innerText = unaOcupacion.nombre;\r\n    ocupacionList.append(item);\r\n});\r\n\r\nclass Participante { //Uso de eventos para rellenar los espacios en blanco y desplegar la informacion\r\n    constructor(numero, apellido, nombre, ocupacion, correo, quiereBoucher = false) {\r\n        this.numero = numero;\r\n        this.apellido = apellido;\r\n        this.nombre = nombre;\r\n        this.ocupacion = ocupacion;\r\n        this.correo = correo;\r\n        this.quiereBoucher = quiereBoucher;\r\n    }\r\n}\r\n\r\nlet participantes = [];\r\n\r\nconst formulario = document.getElementById(\"formulario_HTML\");      console.log(formulario);\r\nformulario.addEventListener(\"submit\", function(evento) {\r\n    evento.preventDefault();          //Cancelamos el comportamiento del evento\r\n    validarFormulario(evento.target); //.target sirve para pasar el conjunto de items, elementos, componentes, inputs que tenga nuestro formulario dentro que contenga info\r\n});                                   //Es decir, se accede a los elementos del formulario a donde pertenete submit y NO a informacion del submit. O sea, el objeto que \"disparo\" o \"activo el evento.\"\r\n\r\nfunction validarFormulario(data) {\r\n    // console.log(\"--> Validando formulario\", data); //Recivimos el conjunto de elementos, items, etc. recividos de la linea 1331 y despues los imprimimos.\r\n    // const hijos = data.children; //Asignamos los elementos del formulario a una nueva variable. En ella se encuentran 4 divs, el form-check y el btnInscribir\r\n    // console.log(\"--> Que hay dentro de children\", hijos);\r\n\r\n    // for (let i = 0; i < 4; i++) {\r\n    //     const unHijo = hijos[i]; //Asignamos individualmente los elementos del formulario a una nueva variable para despues acceder a sus hijos. (En este caso, solo queremos tomar en cuenta los primros 4 elementos, que son 4 divs)\r\n    //     const valor = unHijo.children[1].value; //Colocamos [1].value porque es donde se encuentra el label que queremos mostrar de los 4 divs del formulario, y despues guardamos ese elemento (hijo) en una nueva variable. En este caso. Son puros input's y el contenido que escribimos en ellos.\r\n    //     console.log(\"--> El valor almacenado en el input \" + unHijo.children[0].innerText + \" es: \" ,{valor}); //unHijo.children[0].innerText muestra la primer posicion que pertenece al label en cada div, y entonces al poner innerText, mostamos el nombre que le asignamos a cada uno entre los > <.\r\n    // }\r\n\r\n    // Recuperaremos de cada uno de los inputs, el valor que ingreso/selecciono el usaurio\r\n    const apellidos = document.getElementById(\"apellidos\").value;     console.log(\"Apellidos: \"+ apellidos);\r\n    const nombres = document.getElementById(\"nombres\").value;         console.log(\"Nombres: \"+ nombres);\r\n    const ocupacion = document.getElementById(\"ocupacion\").value;     console.log(\"Ocupacion: \"+ ocupacion);\r\n    const correo = document.getElementById(\"correo\").value;           console.log(\"Correo: \"+ correo);\r\n    const participar = document.getElementById(\"participar\").checked; console.log(\"Participar: \"+ participar);// Mediante la propiedad checked accedemos al valor booleano true/false que representa si el radiobutton o el checkbox fue \"tildado/seleccionado\"\r\n\r\n    // Instanciamos la creacion de un objeto con la forma de un Participante\r\n    const unaOcupacion = ocupaciones.find((evento) => evento.numero.toString() === ocupacion);                         console.log(\"unaOcupacion\", unaOcupacion);\r\n    const unParticipante = new Participante(participantes.length+1,apellidos,nombres,unaOcupacion,correo,participar);  console.log(\"--> Un participante a ser anadido\", unParticipante);\r\n\r\n    // Anadimos un elemento a la lista de aprticipantes (aun no incorporamos un control sobre existentes o similar)\r\n    participantes.push(unParticipante);           console.log(\"--> Que elementos posee mi array de participantes\",participantes);\r\n\r\n    // Pintar la lista en la interfaz de usuario (solo para demostrar en la interfaz el cambio anadido -- profundizaremos este tema a medida que avanzamos con las clases.)\r\n    let lista = document.getElementById(\"listaParticipantes\");\r\n    lista.innerHTML = \"\"; //Borramos el innerHTML de 'lista' colocando las comillas vacias para limpiar su contenido.\r\n    participantes.forEach((individual) => {\r\n        let item = document.createElement(\"p\");\r\n        item.innerText = individual.apellido + \", \" + individual.nombre;\r\n        lista.append(item);\r\n    });\r\n\r\n    // Limpiar todos y cada uno de los inputs\r\n    document.getElementById(\"apellidos\").value = \"\";\r\n    document.getElementById(\"nombres\").value = \"\";\r\n    document.getElementById(\"ocupacion\").value = \"0\";// el valor de este por default es 0 porque es la primera opciOn del combo de selecciOn\r\n    document.getElementById(\"correo\").value = \"\";\r\n    document.getElementById(\"participar\").value = \"off\";// para bootstrap --> on: true y off: false \r\n} */\r\n\r\n\r\n/* //Ejemplo 14: Finding coordenates and position, and use of scroll\r\nbtnScrollTo.addEventListener(\"click\", function(evento){\r\n    const s1coords = section1.getBoundingClientRect(); \r\n    console.log(\"Section position: \", s1coords);                              //Representa la posicion de la seccion\r\n    console.log(\"Learn more botton position: \", evento.target.getBoundingClientRect()); //Representa la posicion del boton \"learn more\"\r\n    console.log(\"Current scroll (X/Y): \", window.scrollX, window.scrollY);\r\n    console.log(\"Height/width viewport: \", document.documentElement.clientHeight, document.documentElement.clientWidth);\r\n    \r\n    //Scrolling (method 1)\r\n    // window.scrollTo(s1coords.left + window.scrollX, s1coords.top + window.scrollY);\r\n\r\n    //Scrolling (method 2)\r\n    // window.scrollTo({\r\n    //     left: s1coords.left + window.scrollX, \r\n    //     top: s1coords.top + window.scrollY,\r\n    //     behavior: \"smooth\"\r\n    // });\r\n\r\n    //Scrolling (method 3)\r\n    section1.scrollIntoView({behavior: \"smooth\"});\r\n}); */\r\n\r\n/* //Ejemplo 15: Creating and inserting elements, use of styles atributes, non-standard and classes\r\n// Creating and inserting elements\r\nconst header = document.querySelector('.header');\r\nconst message = document.createElement('div');\r\nmessage.classList.add('cookie-message');\r\nmessage.innerHTML = 'We use cookied for improved functionality and analytics. <button class=\"btn btn--close-cookie\">Got it!</button>';\r\nheader.append(message);\r\ndocument.querySelector('.btn--close-cookie').addEventListener('click', function () {\r\n    message.parentElement.removeChild(message);\r\n});\r\n\r\n\r\n// Styles\r\nmessage.style.backgroundColor = '#37383d';\r\nmessage.style.width = '120%';\r\nmessage.style.height = Number.parseInt(getComputedStyle(message).height, 10) + 50 + 'px'; //El segundo elemento en parseInt representa el radix (base del sistema numerico, en este caso 10 es decimal)\r\nconsole.log(message.style.color);\r\nconsole.log(message.style.backgroundColor);\r\nconsole.log(getComputedStyle(message).color);\r\nconsole.log(getComputedStyle(message).height);\r\n\r\ndocument.documentElement.style.setProperty(\"--color-primary\", \"orange\");\r\n\r\n\r\n// Attributes\r\nconst logo = document.querySelector('.nav__logo');\r\nconsole.log(logo.alt);\r\nconsole.log(logo.className);\r\nlogo.alt = 'Beautiful minimalist logo';\r\n\r\n// Non-standard\r\nconsole.log(logo.designer);\r\nconsole.log(logo.getAttribute('designer'));\r\nlogo.setAttribute('company', 'Bankist');\r\n\r\nconsole.log(logo.src);\r\nconsole.log(logo.getAttribute('src'));\r\n\r\nconst link = document.querySelector('.nav__link--btn');\r\nconsole.log(link.href);\r\nconsole.log(link.getAttribute('href'));\r\n\r\n// Data attributes\r\nconsole.log(logo.dataset.versionNumber);\r\n\r\n// Classes\r\nlogo.classList.add('c', 'j');\r\nlogo.classList.remove('c', 'j');\r\nlogo.classList.toggle('c');\r\nlogo.classList.contains('c'); // not includes\r\nlogo.clasName = 'jonas'; // Don't use because this will override all the existing classes and it will allow us only put one class on any element.*/\r\n\r\n/* //Ejemplo 16: Use and difference between target and currentTarget\r\nfunction randomInt(min, max){\r\n    return Math.floor(Math.random() * (max - min + 1) + min);\r\n}\r\n\r\nfunction randomColor(){\r\n    return `rgb(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`\r\n}\r\n\r\n//En el HTML, estos tres querySelector que tiene el nav, nav__links y nav__link, esan agrupados en ese orden de arriba hacia abajo (O sea, un arbol). Si presiono el elemento padre (nav), unicamente se ejecutara ese evento, pero si ejecuto el ultimo (nav__link), se ejecutaran los 3 eventos ya que debe pasar por sus elementos anteriores para llegar hasta ese ultimo evento.\r\n//Recordar que en un EventListener el this siempre apunta al elemento en el cual se adjunta ese EventListener.\r\n//Para el caso de los target y currentTarget, se puede apreciar la diferencia cuando se hace click en los elementos hijos. Por ejemeplo. Si presiono el nav, no habra ninguna diferencia ya que es el elemento padre. Pero si presionamos nav__links, los target y currentTarget de este hijo seran los mismos, mientras que, en cuando ahora se ejecute el nav, el target seguira siendo el mismo ejecutado en el nav__links, pero en el currentTarget ahi si tomara el target actual, o sea, el del nav.\r\ndocument.querySelector('.nav').addEventListener('click', function (e) {\r\n    this.style.backgroundColor = randomColor();\r\n    console.log('NAV e.target: ', e.target);\r\n    console.log('NAV e.currentTarget: ', e.currentTarget);\r\n});\r\n\r\ndocument.querySelector('.nav__links').addEventListener('click', function (e) {\r\n    this.style.backgroundColor = randomColor(); \r\n    console.log('CONTAINER e.target: ', e.target, );\r\n    console.log('CONTAINER e.currentTarget:', e.currentTarget);\r\n});\r\n\r\ndocument.querySelector('.nav__link').addEventListener('click', function (e) {\r\n    this.style.backgroundColor = randomColor(); \r\n    console.log('LINK e.target: ', e.target);\r\n    console.log('LINK e.currentTarget: ', e.currentTarget);\r\n\r\n    // console.log(e.currentTarget === this);\r\n    // e.stopPropagation();\r\n}); */\r\n\r\n/* //Ejemplo 17: Page navigation, uso de scrollIntoView y diferencia entre usar this y target en addEventListener.\r\n//Metodo 1 (Esto es una mala practica cuando existen muchos elementos, porque tenemos muchas copias de la misma callback function, lo cual hara que la pagina sea mas lenta)\r\n// document.querySelectorAll(\".nav__link\").forEach(function(evento){\r\n//     evento.addEventListener(\"click\", function(iter){\r\n//         iter.preventDefault();\r\n\r\n//         //Aqui usamos this en este addEventListener porque, estamos trabajando directamente con cada link (nav__link) por medio del foreach, por lo que, el this representa el elemento actual en el que se esta trabajando al precionar el boton\r\n//         const id = this.getAttribute(\"href\"); //Retorna unicamente el nombre del atriuto contenido en esa etiqueta. Si usamos const id = this.href, entonces tendremos el link completo que aparece en la barra de navegacion\r\n//         document.querySelector(id).scrollIntoView({behavior: \"smooth\"});\r\n//     })\r\n// })\r\n\r\n//Metodo 2\r\ndocument.querySelector(\".nav__links\").addEventListener(\"click\", function(evento){\r\n    evento.preventDefault();\r\n\r\n    //Aqui usamos evento.target porque en este caso estamos utilizando el <ul> como elemento padre, y sus hijos son <li> y <a>. Ahora, con el addEventListener podemos hacer click en el elemento padre o incluso sus hijos y JS ejecutara la tarea deseada. Si usamos this como en el metodo 1, este solo funcionara para elelemento actual o el padre, es decir <ul>.\r\n    if (evento.target.classList.contains(\"nav__link\")) {\r\n        const id = evento.target.getAttribute(\"href\"); //Retorna unicamente el nombre del atriuto contenido en esa etiqueta. Si usamos const id = this.href, entonces tendremos el link completo que aparece en la barra de navegacion\r\n        document.querySelector(id).scrollIntoView({behavior: \"smooth\"});\r\n    }\r\n}); */\r\n\r\n/* //Ejemplo 18: Use of childNodes, children, firstElementChild, lastElementChild, parentNode, parentElement and closest.\r\nconst h1 = document.querySelector(\"h1\");\r\n\r\n// Going downwards: child\r\nconsole.log(\"h1.querySelectorAll('.highlight')\", h1.querySelectorAll(\".highlight\")); //Muestra todos los hijos de h1 con el nombre highlight\r\nconsole.log(\"h1.childNodes\", h1.childNodes); // Retorna una lista de nodos de los nodos hijos de un elemento. En este caso, los hijos de h1. (Casi no se usa)\r\nconsole.log(\"h1.children\", h1.children); //Retorna una coleccion HTML de los elementos hijos de un elemento y solo funciona para hijos directos. En este caso, los elementos de h1. (Se usa mucho)\r\nh1.firstElementChild.style.color = 'white'; //Este se usa para recuperar (y/o modificar) el primer elemento hijo.\r\nh1.lastElementChild.style.color = 'orangered'; //Este se usa para recuperar (y/o modificar) el ultimo elemento hijo.\r\n\r\n// Going upwards: parents (parentNode y parentElement nos permiten acceder al elemento del elemento que estamos usando. En este caso, <div class=\"header__title\"> es padre de h1.)\r\nconsole.log(\"h1.parentNode\", h1.parentNode);  \r\nconsole.log(\"h1.parentElement\", h1.parentElement);\r\n\r\nh1.closest('.header').style.background = 'var(--gradient-secondary)'; //closese() se usa para seleccionar el elemento mas cercano a h1, por lo general es lo inverso al querySelector, ya que en lugar de buscar los elementos hijos, este busca los elementos padres.\r\nconsole.log(h1.closest('.header'));\r\n\r\nh1.closest('h1').style.background = 'var(--gradient-primary)';\r\nconsole.log(h1.closest('h1'));\r\n\r\n// Going sideways: siblings\r\nconsole.log(h1.previousElementSibling); //Returns the previous element at the same node tree level\r\nconsole.log(h1.nextElementSibling); //Returns the next element at the same node tree level\r\nconsole.log(h1.previousSibling); //Returns the previous node at the same node tree level\r\nconsole.log(h1.nextSibling); //Returns the next node at the same node tree level\r\nconsole.log(h1.parentElement.children); //This allows access to the h1's parent and then it allows us to access to all its children, which are h1, h4, button and img.\r\n\r\n[...h1.parentElement.children].forEach(function (evento) {\r\n    if (evento !== h1) evento.style.transform = 'scale(0.5)';\r\n}); */\r\n\r\n/* //Ejemplo 19: Building a Tabbed Component\r\nconst tabsContainer = document.querySelector('.operations__tab-container');\r\nconst tabs = document.querySelectorAll('.operations__tab');\r\nconst tabsContent = document.querySelectorAll('.operations__content');\r\n\r\ntabsContainer.addEventListener('click', function (evento) {\r\n    const clicked = evento.target.closest('.operations__tab');  console.log(clicked);\r\n    \r\n    // Guard clause\r\n    if (!clicked) return;\r\n\r\n    //Realizamos un barrido en cada uno de los 3 botones y en cada uno de los 3 contenidos de texto. Dependiendo del boton seleccionado, a este se le eliminaran sus \"active\"\r\n    tabs.forEach(evento => evento.classList.remove('operations__tab--active'));\r\n    tabsContent.forEach(evento => evento.classList.remove('operations__content--active'));\r\n\r\n    //Una vez eliminado los \"active\" en el boton y el contenido seleccinado, ahora se procede a \"activar\" el boton y su contenido seleccionado.\r\n    clicked.classList.add('operations__tab--active');\r\n\r\n    //Dependiendo del boton que se haya presionado, este realizara la animacion en el boton, y tambien se desplegara el contenido de texto del boton seleccionado.\r\n    document.querySelector(`.operations__content--${clicked.dataset.tab}`).classList.add('operations__content--active'); \r\n});\r\n\r\n//Debemos añadir el closest(), ya que operations__tab-container tiene de hijos tres elementos botones con un span cada uno. Por lo que al presionar el boton, especificamente\r\n//el texto (span), no funcionara correctamente el boton. Es por eso que agregamos el closest(), para que al presionar el boton, considere unicamente el elemento mas cercano\r\n//con el nombre operations__tab (incluyendo su hijo <span>). \r\n//Cabe mencionar que, si precionamos donde esta el <div class=\"operations__tab-container\"> entonces tendremos un null en consola, ya que no existe ningun elemento padre con el \r\n//class \".operations__tab\". Para eso usamos el Guard clause, para que al no haber un click en el botton, simplemente salga de la funcion y no ejecute las lineas siguientes. */\r\n\r\n/* // Ejemplo 20.1: Passing Arguments to Event Handlers (Method 1)\r\n\r\n// Menu fade animation \r\nfunction handleHover(evento) {\r\n    \r\n    //Recordar que cuando utilizamos bind(), la keyword \"this\" representa los parametros que le enviamos a la funcion, en este caso, 0.5 y 1.\r\n    console.log(this, evento.currentTarget);\r\n\r\n    if (evento.target.classList.contains('nav__link')) {\r\n        const link = evento.target;\r\n        const siblings = link.closest('.nav').querySelectorAll('.nav__link');\r\n        const logo = link.closest('.nav').querySelector('img');\r\n\r\n        siblings.forEach(function(iter) {\r\n            if (iter !== link) iter.style.opacity = this;\r\n        });\r\n\r\n        logo.style.opacity = this;\r\n    }\r\n};\r\n\r\n// Usamos bind para retornar una nueva funcion de esa funcion handleHover, y de esa forma, no tener que usar una funcion que llame a otra funcion.\r\nnav.addEventListener('mouseover', handleHover.bind(0.5));\r\nnav.addEventListener('mouseout', handleHover.bind(1)); */\r\n\r\n/* // Ejemplo 20.2: Passing Arguments to Event Handlers (Method 2) \r\n// Menu fade animation\r\nfunction handleHover(evento, opacity) {\r\n\r\n    console.log(evento.currentTarget);\r\n\r\n    if (evento.target.classList.contains('nav__link')) {\r\n        const link = evento.target;\r\n        const siblings = link.closest('.nav').querySelectorAll('.nav__link');\r\n        const logo = link.closest('.nav').querySelector('img');\r\n\r\n        siblings.forEach(function(iter){\r\n            if (iter !== link) iter.style.opacity = opacity;\r\n        });\r\n\r\n        logo.style.opacity = opacity;\r\n    }\r\n};\r\n\r\n//Debido a que addEventListener requiere una funcion como parametro, no podemos simplemente usar la funcion de handleHover directamente ahi porque esta al final del dia retorna un valor, lo cual es incorrecto cuando usamos addEventListener.\r\nnav.addEventListener('mouseover', function(evento){\r\n    handleHover(evento, 0.5);\r\n    console.log(this);\r\n});\r\n\r\nnav.addEventListener('mouseout', function(evento){\r\n    handleHover(evento, 1);\r\n    console.log(this);\r\n}); */\r\n\r\n/* //Ejemplo 21: Sticky navigation\r\n\r\nconst initialCoords = section1.getBoundingClientRect();\r\nconsole.log(initialCoords);\r\n\r\nwindow.addEventListener('scroll', function () {\r\n    console.log(window.scrollY);\r\n    window.scrollY > initialCoords.top ? nav.classList.add('sticky') : nav.classList.remove('sticky');\r\n}); */\r\n\r\n/* //Ejemplo 22.1: The Intersection Observer API\r\n\r\nconst obsCallback = function(entries, observer){ //Whenever the first section (our target) is intersecting the viewport at 10%, the function will get called and that's no matter if we're scrolling up or down.\r\n    entries.forEach(evento => console.log(evento));\r\n} \r\n\r\nconst obsOptions = { \r\n    root: null,     //root is the element that the target is intersecting. We write null and we'll be able to observe our target element intersecting the entire wiewport (the entire rectangle which shows the current portion of the page)\r\n    // threshold: 0.1,  //This is the percent of intersection at which the obersver callback will be called\r\n    threshold: [0, 0.2] //0 means that our callback will trigger each time that the target element moves complitelly out of the view. and 1 when the 100% of the target is actually visible in the viewport.\r\n}\r\n\r\n//             new IntersectionObserver(callback,    options);\r\nconst IO_API = new IntersectionObserver(obsCallback, obsOptions); // Our \"callback\" and \"options\" will be pased into our so called IntersectionObserver object.\r\nIO_API.observe(section1); //This is the target element that will intersect in root. */\r\n\r\n/* //Ejemplo 22.2: The Intersection Observer API\r\nconst stickyNav = function(entries){\r\n    const [entry] = entries; //entries is always an array because the options in IntersectionObserver can have multiple thresholds, and for each threshold, there will be an entry in the array, even if there is only one threshold.\r\n    console.log(entry);\r\n\r\n    if (!entry.isIntersecting) { //When the target isn't intersecting the root, then we want the sticky class to be applied.\r\n        nav.classList.add(\"sticky\");\r\n    }else{\r\n        nav.classList.remove(\"sticky\");\r\n    }\r\n}\r\n\r\nconst options = {\r\n    root: null, //We select null because we are interested in the entire viewport\r\n    threshold: 0, //A value of 0 means that even a single visible pixel counts as the target being visible. That's to say, when the header shows a 0% of itself, then the function will get called .\r\n\r\n    //We use getBoundingClientRect().height to calculate dynamically the height (for responsive webpages) of the nav without the needed of hard coding and tupe an specific height. It'll be 90px.\r\n    rootMargin: `-${nav.getBoundingClientRect().height}px` //This value is in pixels and will be applied outside of the target element\r\n};\r\n\r\nconst headerObserver = new IntersectionObserver(stickyNav, options);\r\nheaderObserver.observe(header); */\r\n\r\n/* //Ejemplo 23: Revealing Elements on Scroll\r\nconst allSections = document.querySelectorAll(\".section\");\r\n\r\nconst revealSection = function(entries, observer){\r\n    const [entry] = entries;     console.log(entry)\r\n\r\n    if(entry.isIntersecting === false) return;\r\n    entry.target.classList.remove(\"section--hidden\");\r\n\r\n    observer.unobserve(entry.target);\r\n};\r\nconst opciones = {\r\n    root: null,\r\n    threshold: 0.15, //We use something greater than zero because we don't want to show the section right as it enters the viewport, but a litte latter.\r\n}\r\n\r\nconst sectionObserver = new IntersectionObserver(revealSection, opciones)\r\n\r\nallSections.forEach(function(section){\r\n    sectionObserver.observe(section);\r\n    section.classList.add(\"section--hidden\");\r\n}); */\r\n\r\n/* //Ejemplo 24: Lazy Loading Images\r\nconst imgTarget = document.querySelectorAll(\"img[data-src]\");  // console.log(imgTarget);\r\n\r\nconst loadImg = function(entries, observer){\r\n    const [entry] = entries;   //console.log(entry);\r\n\r\n    if(entry.isIntersecting === false) return;\r\n\r\n    //Replace the src (\"imgs/grow-lazy.jpg\") with data-src (\"imgs/grow.jpg\"). That's to say, src is the blur image and the data-src is the high-quality image.\r\n    entry.target.src = entry.target.dataset.src;\r\n\r\n    entry.target.addEventListener(\"load\", function(){\r\n        entry.target.classList.remove(\"lazy-img\");\r\n    })\r\n\r\n    observer.unobserve(entry.target)\r\n}\r\n\r\nconst Opciones = {\r\n    root: null,\r\n    threshold: 0,\r\n    rootMargin: \"200px\"\r\n}\r\n\r\nconst imgObserver = new IntersectionObserver(loadImg, Opciones);\r\nimgTarget.forEach(evento => imgObserver.observe(evento)); */\r\n\r\n/* //Ejemplo 24: Slider\r\nconst slides = document.querySelectorAll('.slide');\r\nconst btnLeft = document.querySelector('.slider__btn--left');\r\nconst btnRight = document.querySelector('.slider__btn--right');\r\nconst dotContainer = document.querySelector(\".dots\");\r\nlet curSlide = 0;\r\nconst maxSlide = slides.length;\r\n\r\n\r\nfunction goToSlide(slide) {\r\n    slides.forEach(function(evento, iter){\r\n        evento.style.transform = `translateX(${100 * (iter - slide)}%)`; //0%, 100%, 200%\r\n        // console.log(`${iter} , ${evento.style.transform}`);\r\n    })\r\n};\r\n\r\nfunction nextSlide() {\r\n    curSlide === maxSlide - 1 ? curSlide = 0 : curSlide++;\r\n    goToSlide(curSlide);\r\n    activateDot(curSlide)\r\n};\r\n\r\nfunction prevSlide() {\r\n    curSlide === 0 ? curSlide = maxSlide - 1 : curSlide--;\r\n    goToSlide(curSlide);\r\n    activateDot(curSlide)\r\n};\r\n\r\nfunction createDots() {\r\n    slides.forEach(function (_, i) {\r\n        dotContainer.insertAdjacentHTML('beforeend',\r\n            `<button class=\"dots__dot\" data-slide=\"${i}\"></button>`\r\n        );\r\n    });\r\n};\r\n\r\nfunction activateDot(slide){\r\n    document.querySelectorAll('.dots__dot').forEach(dot => dot.classList.remove('dots__dot--active'));\r\n    document.querySelector(`.dots__dot[data-slide=\"${slide}\"]`).classList.add('dots__dot--active');\r\n};\r\n\r\nfunction init(){\r\n    createDots();\r\n    goToSlide(0);\r\n    activateDot(0);\r\n}\r\n\r\ninit();\r\nbtnRight.addEventListener('click', nextSlide);\r\nbtnLeft.addEventListener('click', prevSlide);\r\n\r\ndocument.addEventListener('keydown', function (evento) {\r\n    console.log(evento)\r\n    if (evento.key === 'ArrowLeft') prevSlide();\r\n    if (evento.key === 'ArrowRight') nextSlide();\r\n});\r\n\r\ndotContainer.addEventListener('click', function (evento) {\r\n    if (evento.target.classList.contains('dots__dot')) {\r\n        const slide = evento.target.dataset.slide;  //const { slide } = e.target.dataset;\r\n        goToSlide(slide);\r\n        activateDot(slide);\r\n    }\r\n}); */\r\n\r\n/* //Ejemplo 25: Lifecycle DOM Events\r\ndocument.addEventListener('DOMContentLoaded', function (evento) {\r\n    console.log('HTML parsed and DOM tree built!', evento);\r\n});\r\n\r\nwindow.addEventListener('load', function (evento) {\r\n    console.log('Page fully loaded', evento);\r\n});\r\n\r\nwindow.addEventListener('beforeunload', function (evento) {\r\n    evento.preventDefault();\r\n    console.log(evento);\r\n    evento.returnValue = '';\r\n}); */\r\n\r\n\r\n//         $$$$$$$$$$$$$$$ JSON & storage $$$$$$$$$$$$$$$\r\n\r\n\r\n/* // Ejemplo 1: setItem en localStorage para crear datos en el local storage. getItem para recuperar informacion almacenada. Y buscar si existe algo o no.\r\nlocalStorage.setItem(\"saludar\", \"Hola mundo\");\r\nlocalStorage.setItem(\"existe\", true);\r\nlocalStorage.setItem(\"cantidad\", parseInt(155)); \r\n\r\nconst mensaje = localStorage.getItem(\"saludar\");\r\nconst isExistente = localStorage.getItem(\"existe\");\r\nconst cantidad = localStorage.getItem(\"cantidad\");\r\nconst res = localStorage.getItem(\"nombreUsuario\"); // \"nombreUsuario\" no existe\r\n\r\nconsole.log(\"Mensaje: \", {mensaje});\r\nconsole.log(\"Existe el elemento almacenado? \", {isExistente});\r\nconsole.log(\"Cuantos pedidos hiciste? \", {cantidad});\r\nres ? console.log(\"Informacion recuperada\", {res}) : console.log(\"Informacion NO recuperada\", {res}); */\r\n\r\n/* // Ejemplo 2: Crear informacion dentro del sessionStorage con el metodo setItem(), y recuperar info almacenada en el mismo con getItem().\r\nsessionStorage.setItem(\"Bienvenida\", \"Hola mundo\");\r\nsessionStorage.setItem(\"EsValido\", true);\r\nsessionStorage.setItem(\"unNumero\", 155);\r\n\r\nconst isValido = sessionStorage.getItem(\"unNumero\") == 155 ? true : false;\r\nconsole.log(\"Existe el producto buscado?\", {isValido});\r\nconsole.log(\"Que tipo de dato persiste sin convertirlo?\", {resultado: typeof sessionStorage.getItem(\"EsValido\")});\r\nconsole.log(\"Que tipo de dato persiste convertiendolo?\", {resultado: typeof isValido}); */\r\n\r\n/* // Ejemplo 3: Como guardar elementos de un array y como recuperarlos\r\nconst MY_ARRAY = [100, 500, 963];\r\n//console.log(\"Que tipo de dato mi array?\", {resultado: typeof MY_ARRAY, MY_ARRAY});\r\n\r\nlocalStorage.setItem(\"myArray\", MY_ARRAY);\r\n\r\nconst valorRecuperado = localStorage.getItem(\"myArray\"); //console.log(typeof valorRecuperado, valorRecuperado);\r\nconsole.log(\"Que tipo de dato es recuperado?\", {resultado: typeof valorRecuperado, valorRecuperado});\r\n\r\n//COMO CONVERTIR CADA ELEMENTO DEL ARRAY (SABIENDO QUE SON NUMEROS) A NUMEROS NUEVAMENTE (METODO MANUAL)\r\nconst valorCambiado = localStorage.getItem(\"myArray\").split(\",\"); //console.log(typeof valorCambiado, valorCambiado);\r\nconsole.log( \"Que tipo de dato es valorCambiado?\", {resultado: typeof valorCambiado, myArray: valorCambiado.filter((evento)=>parseInt(evento))} ); */\r\n\r\n/* // Ejemplo 4: Como recorrer todos y cada uno de los elementos almacenados dentro de nuestro local storage o session storage\r\nconsole.log(\"Recuperar todos los elementos de la local storage\");\r\nfor (let i = 0; i < localStorage.length; i++) {\r\n    const clave = localStorage.key(i);\r\n    console.log(\"En la clave <\"+ clave+ \"> esta este dato\", {valor: localStorage.getItem(clave)});\r\n}\r\n\r\nconsole.log(\"\\nRecuperar todos los elementos de la session storage\");\r\nfor (let i = 0; i < sessionStorage.length; i++) {\r\n    const clave = sessionStorage.key(i);\r\n    console.log(\"En la clave <\"+clave + \"> esta este dato \",{valor: sessionStorage.getItem(clave)});\r\n} */\r\n\r\n/* // Ejemplo 5: eliminar elementos concretos, y tambien eliminar todos los elementos en local storage y el session storage.\r\n// localStorage.removeItem(\"nombre\"); \r\nlocalStorage.clear();\r\n// sessionStorage.removeItem(\"Bienvenida\")\r\n// sessionStorage.clear(); */\r\n\r\n/* // Ejemplo 6: Editar informacion ya existente dentro de nuestro local storage o session storage\r\nconst nombre = \"german\";\r\nlocalStorage.setItem(\"saludar\", nombre);\r\nsessionStorage.setItem(\"unNumero\", 8); */\r\n\r\n/* // Ejemplo 7: Recibir los datos JSON\r\nconst cars = `[\r\n    {\r\n        \"modelo\": \"Ford mustang\",\r\n        \"production\": \"2010\",\r\n        \"millaje\": \"12000\"\r\n    },\r\n    {\r\n        \"modelo\": \"Honda accord\",\r\n        \"production\": \"2021\",\r\n        \"millaje\": \"4560\"\r\n    },\r\n    {\r\n        \"modelo\": \"Nissan Sentra\",\r\n        \"production\": \"2016\",\r\n        \"millaje\": \"58200\"\r\n    }\r\n]`;\r\n\r\n//console.log(typeof cars);\r\n\r\nconst jsonData = JSON.parse(cars); //Convertimos a un object con parse \r\nconst carrosNuevos = jsonData.filter((evento) => evento.production > 2010 && evento.millaje < 30000); //console.log(carrosNuevos);\r\nconst newCars = JSON.stringify(carrosNuevos); //Convertimos a un string con stringify\r\n\r\nconst fs = require('fs');\r\nconst carroNuevo = {\r\n    modelo: \"Mini Cooper\",\r\n    produccion: \"2022\",\r\n    millaje: \"500\"\r\n};\r\nconst newCar = JSON.stringify(carroNuevo);\r\nfs.writeFileSync('cars.json', newCar, (error) => {\r\n    if (error) throw error;\r\n    console.log(\"Informacion recivida\");\r\n}); */\r\n\r\n/* // Ejemplo 8: Almacenar informacion de un objeto con JSON, despues recuperaramos los objetos en forma de string (stringify) y luego en forma de object (parse)\r\nclass Carrera {\r\n    constructor(id, nombre) {\r\n        this.id = id;\r\n        this.nombre = nombre.trim();\r\n    }\r\n}\r\n\r\nconst unaCarrera = new Carrera(100, \"Analista de sistemas\")\r\nconsole.log(\"Los datos de la carrera antes de almacenarse son: \",{unaCarrera}); //Intancia de una clase que esta tipificada fuertemente\r\n\r\nlocalStorage.setItem(\"carrera\", JSON.stringify(unaCarrera));\r\nconst unaCarreraRecuperada = localStorage.getItem(\"carrera\");\r\nconsole.log(\"La carrera recuperada con stringify es: \", {unaCarreraRecuperada});\r\n\r\nconst recuperada = JSON.parse(localStorage.getItem(\"carrera\"));\r\nconsole.log(\"La carrera recuperada con parse es: \", {recuperada}); */\r\n\r\n/* // Ejemplo 9: Almacenar un array de objetos en el local storage o session storage\r\nclass Carrera {\r\n    constructor(id, nombre) {\r\n        this.id = id;\r\n        this.nombre = nombre.trim();\r\n    }\r\n}\r\n\r\nconst carreras = [\r\n    new Carrera(1, \"Analista en Sistemas de Computacion\"),\r\n    new Carrera(2, \"Tec. Universitaria en celulosa y Papel\"),\r\n    new Carrera(3, \"Tec. Universitaria en Tecnologias de la Informacion\"),\r\n];\r\nconsole.log(\"Mi array sin convertir es: \", {carreras});\r\n\r\nlocalStorage.setItem(\"carreras\", JSON.stringify(carreras));\r\nlet res = localStorage.getItem(\"carreras\");\r\n\r\nconsole.log(\"Las carreras recuperadas en formato string (stringify) son: \", {res});\r\n\r\n//objeto recuperado de un JSON, en el cual no vamos a tener metodos. Ya que el JSON solo perciste atributos y valores, no metodos ni mucho menos los recupera. \r\nconst convertido = JSON.parse(res);\r\nconsole.log(\"Las carreras recuperadas en formato object (parse) son: \", {convertido}); */\r\n\r\n\r\n//         $$$$$$$$$$$$$$$ Asincronia, promesas, AJAX & FETCH $$$$$$$$$$$$$$$\r\n\r\n\r\n/* // Ejemplo 1: Creacion de una funcionalidad asincriona con setTimeout \r\n\r\nconst ingredients = ['olives', 'spinach', 'pepperoni'];\r\nconst pizzaTimer = setTimeout(function (ing1, ing2, ing3){\r\n    return console.log(`Here is your pizza with ${ing1}, ${ing2} and ${ing3} 🍕`);\r\n},1500, ...ingredients); //Tod0s los argumentos que pasemos despues del delay, seran argumentos de la funcion\r\n\r\nconsole.log('Waiting...');\r\n\r\nif (ingredients.includes('res')) clearTimeout(pizzaTimer);\r\n\r\n// setInterval(function () {\r\n//     const now = new Date();\r\n//     console.log(now);\r\n// }, 1000); */\r\n\r\n/* // Ejemplo 2: Creacion de un countdown hacia abajo\r\n\r\nconst SEGUNDOS = 3;\r\nfor (let LEFT = 1; LEFT <= SEGUNDOS; LEFT++) {\r\n    setTimeout(() => {\r\n        console.log(((SEGUNDOS+1-LEFT).toString() + \" segundos left\"));\r\n    }, LEFT*1000);\r\n}  */\r\n\r\n/* // Ejemplo 3: Aplicacion del modelo asincrono para momstrar a una de las letras de dos palabras\r\n\r\n// for (let letra of \"hola\") {\r\n//     setTimeout (() => {\r\n//     console.log(letra)\r\n//     }, 1000)\r\n// }\r\n\r\n// for (let letra of \"mundo\") {\r\n//     setTimeout (() => {\r\n//     console.log(letra)\r\n//     }, 1500)\r\n// }\r\n\r\nfor (let index = 0; index < \"hola\".length; index++) {\r\n    setTimeout (() => {\r\n    console.log(\"hola\"[index])\r\n    }, (index+1)*500)\r\n} */\r\n\r\n/* // Ejemplo 4: Uso del setInterval para ejecutar continuamente funcionalidades cada x cantidad de segundos.\r\nsetInterval(() => {\r\n    console.log(\"Tic-Toc\")\r\n}, 1000) */\r\n\r\n/* // Ejemplo 5: Ejemplo de como suspender un setInterval y clearTimeout\r\nconsole.log(\"Inicio\");\r\n\r\nlet counter = 0\r\nconst interval = setInterval(() => {\r\n    counter++;\r\n    console.log(\"Counter: \", counter);\r\n    if (counter >= 5) {\r\n    clearInterval(interval);\r\n    console.log(\"Se removió el intervalo\");\r\n    }\r\n}, 1000);\r\n\r\nconst fin = setTimeout(() => {//Esta nunca se llega a ejecutar\r\n    console.log(\"fin\");\r\n}, 2000);\r\nclearTimeout(fin); */\r\n\r\n/* // Ejemplo 6: Como conocer los estados de una promesa\r\nfunction eventoFuturo (){\r\n    return new Promise( (resolve, reject) => {\r\n\r\n    });\r\n}\r\nconsole.log( eventoFuturo() ) // Promise { <pending> } */\r\n\r\n/* // Ejemplo 7: Uso de los resultados de una Promesa para cambiar sus estados\r\nfunction eventoFuturo1(res){\r\n    return new Promise( (resolve, reject) => {\r\n        setTimeout( () => {\r\n            res ? resolve('Promesa resuelta') : reject('Promesa rechazada');\r\n        }, 1000)\r\n    })\r\n}\r\n//Devuelve pending porque la funcion se ejecutara y esperara 1500mS por el setTimeout, pero como no hay nada que haga que \"espere\" a que esto se resuelva, entonces no se mostrara nada.\r\nconsole.log( eventoFuturo1(true) ) // Promise { <pending> }\r\nconsole.log( eventoFuturo1(false) ) // Promise { <pending> } */\r\n\r\n/* // Ejemplo 8: Uso del Then y Catch para catpturar los resultados y aprovechamiento de las posibilidades de respuestas de una promesa\r\nfunction eventoFuturo (res) {\r\n    return new Promise( (resolve, reject) => {\r\n        setTimeout( () => {\r\n            res ? resolve('Promesa resuelta') : reject('Promesa rechazada')\r\n        }, 1000)\r\n    });\r\n}\r\n\r\nconsole.log(\"1. Primer proseso\");\r\n\r\neventoFuturo(true)\r\n//eventoFuturo(false)\r\n.then( (response) => {\r\n    console.log(response) // Promesa resuelta\r\n})\r\n.catch( (error) => {\r\n    console.log(error)\r\n})\r\n.finally( () => {\r\n    console.log(\"Fin del proceso con true\")\r\n    //console.log(\"Fin del proceso con false\")\r\n}); */\r\n\r\n/* // Ejemplo 9: Ejercicio con un array, usando then/catch/finally y tambien ASYNC/AWAIT\r\nconst productos = [\r\n    {marca: \"Nissan\", modelo: 'Sentra', precio: 1500},\r\n    {marca: \"Toyota\", modelo: 'Camry', precio: 2500},\r\n    {marca: \"Honda\", modelo: 'Accord', precio: 3500}\r\n];\r\n// const BD = [];\r\n\r\n\r\nfunction getDatos(){\r\n    return new Promise( (resolve, reject) => {\r\n        setTimeout(() => {\r\n            productos[0].precio === 15200 ? resolve(productos) : reject(new Error (\"No existe\")) ;\r\n        }, 1500);\r\n    });\r\n}\r\n\r\n// //Ejercicio usando then/catch/finally\r\n// getDatos()\r\n// .then( (response) => {\r\n//     console.log(response) // Promesa resuelta\r\n// })\r\n// .catch( (error) => {\r\n//     console.log(error)\r\n// })\r\n// .finally( () => {\r\n//     console.log(\"Fin del proceso :)\")\r\n// });\r\n\r\n//Ejercicio usando ASYNC/AWAIT\r\npedirPosts();\r\nasync function pedirPosts(){\r\n    try{\r\n        const datosFetched = await getDatos();\r\n        console.log(datosFetched);\r\n    }catch(error){\r\n        console.log(error.message);\r\n    }finally{\r\n        console.log(\"Proceso terminado :)\");\r\n    }\r\n}; */\r\n\r\n/* // Ejemplo 10: Ejemplo del uso de Promesa para recuperar informacion de una base de datos\r\n\r\nconst BD_X = [\r\n    {id: 1, nombre: 'Producto 1', precio: 1500},\r\n    {id: 2, nombre: 'Producto 2', precio: 3500}\r\n];\r\nconst BD_Y = [\r\n    {id: 3, nombre: 'Producto 3', precio: 2000},\r\n    {id: 4, nombre: 'Producto 4', precio: 3000}\r\n];\r\n//const BD = [];\r\n\r\nfunction obtenerUsuarios(id){\r\n    return new Promise( (resolve, reject) => {\r\n        if (BD_X.find(evento => evento.id === id)) {\r\n            console.log(\"El usuario existe\");\r\n            resolve(obtenerNombres(id))\r\n        }else{\r\n            reject(\"El usuario no existe\")\r\n        }\r\n    });\r\n}\r\n\r\nfunction obtenerNombres(id){\r\n    return new Promise( (resolve, reject) => {\r\n        if (BD_Y.find(evento => evento.id === id)) {\r\n            resolve(\"El nombre existe\")\r\n        }else{\r\n            reject(\"El nombre no existe\")\r\n        }\r\n    });\r\n}\r\n\r\nobtenerUsuarios(1)\r\n.then((res) => {\r\n    return res;\r\n})\r\n.then((data) => {\r\n    console.log(data);\r\n})\r\n.catch((error) => {\r\n    console.error(error);\r\n}); */\r\n\r\n/* // Ejemplo 11: fetch (método) sin aplicar los el then() y el catch(), y despues la plicación del método then() para ver que estructura posee una respuesta.\r\nconsole.log( fetch('https://jsonplaceholder.typicode.com/posts') );\r\n\r\nfetch('https://jsonplaceholder.typicode.com/posts')\r\n.then((resp) =>\r\n  console.log(resp)\r\n); */\r\n\r\n/* // Ejemplo 12: Obtener la información que se encuentra dentro del BODY de la RESPONSE, y recuperar un único objeto de la API\r\nfetch(\"https://jsonplaceholder.typicode.com/posts\")\r\n  .then((resp) => resp.json())\r\n  .then((data) => {\r\n    console.log(data);\r\n  });\r\n\r\nfetch(\"https://jsonplaceholder.typicode.com/posts/1\")\r\n  .then((response) => response.json())\r\n  .then((json) => {\r\n    console.log(json)\r\n  }); */\r\n\r\n/* // Ejemplo 13: Cómo recuperar datos de una localizacion externa (http://) e una interna (.json) con rutas relativas\r\n\r\nrecuperarPosteos();\r\n\r\nfunction recuperarPosteos() {\r\n    let bodyTable = document.getElementById(\"tableBody\"); // Pintar la tabla de carreras en la UI\r\n    bodyTable.innerHTML = \"\";\r\n    toggleLoadingContainer(true);\r\n    setTimeout(() => {\r\n        fetch(\"https://jsonplaceholder.typicode.com/posts\")  //Localizacion externa\r\n    // fetch(\"/ApuntesDeClase/data/posts.json\")                //Localizacion interna\r\n        .then((resultado) => resultado.json()) // Obtuvimos la respuesta --> Tomar los datos del body (.json())\r\n        .then((data) => {                      // Obtenemos la colección de posteos\r\n            data.forEach((post) => {\r\n            let record = document.createElement(\"tr\");\r\n            record.innerHTML = \r\n            `<tr>\r\n            <td scope=\"row\">${post.id}</td>\r\n            <td scope=\"row\">${post.title}</td>\r\n            <td scope=\"row\">${post.body}</td>\r\n            </tr>`;\r\n            bodyTable.append(record);\r\n        });\r\n    })\r\n        .catch((error) => {\r\n            let record = document.createElement(\"tr\");\r\n            record.innerHTML = \r\n            `<tr>\r\n                <td colspan=\"3\" scope=\"row\">Ocurrio un error al recuperar los datos</td>\r\n            </tr>`;\r\n            bodyTable.append(record);\r\n        })\r\n        \r\n        .finally(() => {\r\n            toggleLoadingContainer(false);\r\n        });\r\n    }, 2000);\r\n}\r\n\r\nfunction toggleLoadingContainer(isLoading = false) {\r\n    const loadingContainer = document.getElementById(\"loadingMessage\");\r\n    if (isLoading) {\r\n        loadingContainer.classList.remove(\"visually-hidden\");\r\n    } else {\r\n        loadingContainer.classList.add(\"visually-hidden\");\r\n    }\r\n} */\r\n\r\n/* // Ejemplo 14: Uso de ASYNC/AWAIT para crear funciones asincrónas que se comportan como si fueran sincronas\r\nconsole.log(\"Previo a hacer la solicitud\");\r\nasync function pedirPosts(){\r\n    const respuesta = await fetch(\"./data/posts.json\");  \r\n    console.log(\"respuesta: \",respuesta);\r\n    const data = await respuesta.json();  \r\n    console.log(\"Data: \",data);\r\n};\r\n\r\npedirPosts(); */\r\n\r\n/* // Ejemplo 15: Uso de los parámetros de configuración para el método fetch (CREACIÓN DE UN RECURSO)\r\nconst CONFIGURACION = {\r\n    method: \"POST\",\r\n    body: JSON.stringify({\r\n        title: \"Nuestro posteo personal\",\r\n        body: \"Lorem Ipsum es simplemente el texto de relleno de las imprentas y archivos de texto. Lorem Ipsum ha sido el texto de relleno estándar de las industrias desde el año 1500, cuando un impresor (N. del T. persona que se dedica a la imprenta) desconocido usó una galería de textos y los mezcló de tal manera que logró hacer un libro de textos especimen. No sólo sobrevivió 500 años, sino que tambien ingresó como texto de relleno en documentos electrónicos, quedando esencialmente igual al original. Fue popularizado en los 60s con la creación de las hojas 'Letraset', las cuales contenian pasajes de Lorem Ipsum, y más recientemente con software de autoedición, como por ejemplo Aldus PageMaker, el cual incluye versiones de Lorem Ipsum.\",\r\n        userId: 1,\r\n    }),\r\n    headers: {\r\n        \"Content-type\": \"application/json; charset=UTF-8\",\r\n    },\r\n};\r\n\r\nfetch(\"https://jsonplaceholder.typicode.com/posts\", CONFIGURACION)\r\n.then((response) => response.json())\r\n.then((data) => console.log(data)); */\r\n\r\n/* // Ejemplo 16: Uso de los parámetros de configuración para el método fetch (MODIFICACIÓN DE UN RECURSO)\r\nconst CONFIGURACION = {\r\n  method: \"PUT\",// PUT/GETCH\r\n  body: JSON.stringify({\r\n    title: \"Le cambio el título\",\r\n    body: \"Un nuevo contenido para el body de este post\",\r\n    userId: 1,\r\n  }),\r\n  headers: {\r\n    \"Content-type\": \"application/json; charset=UTF-8\",\r\n  },\r\n};\r\n//fetch(\"https://jsonplaceholder.typicode.com/posts/{id}\", CONFIGURACION)\r\nfetch(\"https://jsonplaceholder.typicode.com/posts/10\", CONFIGURACION)\r\n  .then((response) => response.json())\r\n  .then((data) => console.log(data)); */\r\n\r\n/* // Ejemplo 17: Uso de los parámetros de configuración para el método fetch (ELIMINACIÓN DE UN RECURSO)\r\nconst CONFIGURACION = {\r\n  method: \"DELETE\",\r\n};\r\n//fetch(\"https://jsonplaceholder.typicode.com/posts/{id}\", CONFIGURACION)\r\nfetch(\"https://jsonplaceholder.typicode.com/posts/10\", CONFIGURACION)\r\n  .then((response) => response.json())\r\n  .then((data) => console.log(data)); */\r\n\r\n/* // Ejemplo 18: Asynchronous JS, promises and ajax (old way)\r\nconst btn = document.querySelector('.btn-country');\r\nconst countriesContainer = document.querySelector('.countries');\r\n\r\nfunction getCountryDataAndNeighbour(country) {\r\n\r\n    //AJAX call country 1\r\n    const request = new XMLHttpRequest();\r\n    request.open('GET', `https://restcountries.com/v3.1/name/${country}`);\r\n    request.send();\r\n\r\n    request.addEventListener('load', function () {\r\n    const [data] = JSON.parse(this.responseText);\r\n    console.log(data);\r\n\r\n    //Render country 1\r\n    renderCountry(data);\r\n\r\n    //Get neighbour country\r\n    const [neighbour] = data.borders;\r\n\r\n    if(!neighbour) return;\r\n\r\n    //AJAX call country 2\r\n    const request2 = new XMLHttpRequest();\r\n    request2.open('GET', `https://restcountries.com/v3.1/alpha/${neighbour}`);\r\n    request2.send();\r\n\r\n    request2.addEventListener('load', function (){\r\n        const [data2] = JSON.parse(this.responseText);\r\n        console.log(data2);\r\n\r\n        renderCountry(data2, \"neighbour\")\r\n    })\r\n\r\n    });\r\n};\r\n\r\nfunction renderCountry(data, className = ''){\r\n    //Metodo 1\r\n    const html = `\r\n    <article class=\"country ${className}\">\r\n        <img class=\"country__img\" src=\"${data.flags.svg}\" />\r\n        <div class=\"country__data\">\r\n            <h3 class=\"country__name\">${data.name.common}</h3>\r\n            <h4 class=\"country__region\">${data.region}</h4>\r\n            <p class=\"country__row\"><span>👫</span>${Number(data.population / 1000000).toFixed(1)} people</p>\r\n\r\n            <p class=\"country__row\"><span>🗣️</span>${data.languages[Object.keys(data.languages)[0]]}</p>\r\n            <p class=\"country__row\"><span>💰</span>${data.currencies[Object.keys(data.currencies)[0]].name}</p>\r\n        </div>\r\n    </article>`;\r\n\r\n    //Metodo 2\r\n    // <p class=\"country__row\"><span>🗣️</span>${Object.values(Object.values(data.currencies)[0])[0]}</p>\r\n    // <p class=\"country__row\"><span>💰</span>${Object.values(data.languages)[0]}</p>\r\n\r\n    countriesContainer.insertAdjacentHTML('beforeend', html);\r\n    countriesContainer.style.opacity = 1;\r\n}\r\n\r\ngetCountryDataAndNeighbour(\"russia\");\r\n\r\n// setTimeout(() => {\r\n//     console.log('1 second passed');\r\n//     setTimeout(() => {\r\n//         console.log('2 seconds passed');\r\n//         setTimeout(() => {\r\n//             console.log('3 second passed');\r\n//             setTimeout(() => {\r\n//                 console.log('4 second passed');\r\n//             }, 1000);\r\n//         }, 1000);\r\n//     }, 1000);\r\n// }, 1000); */\r\n\r\n/* // Ejemplo 19: Asynchronous JS, promises and ajax (new way);\r\nconst btn = document.querySelector('.btn-country');\r\nconst countriesContainer = document.querySelector('.countries');\r\n\r\nconst request = fetch(\"https://restcountries.com/v3.1/name/russia\");\r\nconsole.log(request);\r\n\r\nfunction getCountryData(country){\r\n    //Country 1\r\n    getJSON(`https://restcountries.com/v3.1/name/${country}`, \"Country not found\")\r\n    .then(function(data){\r\n        console.log(data);\r\n        renderCountry(data[0]);\r\n        const neighbour = data[0]?.borders?.[0]; //If we chose austrlia, then there won't be any key with the name \"border\" in the object, so we'll get an \"undefined\". That's why we use the Optional chaining (?.)\r\n        // const neighbour = \"frfsag\"; //Line to execute an error\r\n        console.log(neighbour);\r\n\r\n        if (!neighbour) throw new Error(\"No neighbour found!\");\r\n        \r\n        //Country 2\r\n        return getJSON(`https://restcountries.com/v3.1/alpha/${neighbour}`, \"Country not found\")\r\n        .then(function(data){\r\n            return renderCountry(data[0], \"neighbour\");\r\n        })\r\n    })\r\n    .catch(function(err){\r\n        console.log(`${err} 😡😡😡`);\r\n        renderError(`Something went wrong 😡😡😡 ${err.message}. Try again!`); //$ {err} = TypeError: Failed to fetch    {err.message} = Failed to fetch\r\n    })\r\n    .finally(function(){\r\n        countriesContainer.style.opacity = 1;\r\n    })\r\n}\r\n\r\nfunction getJSON(url, errorMsc = \"Something went wrong\"){\r\n    return fetch(url)\r\n    .then(function(response){\r\n        console.log(response);\r\n\r\n        if(!response.ok) throw new Error(`${errorMsc} (${response.status})`); //When we use \"throw\" in any of our methods, means that it will terminate the currecnt function, and the promise will immediately reject. So, the proimse returned by this first \".then\" will be a rejected promise. And that rejection will then propagate all the way down to the catch handler, which we already have set up right down. \r\n        return response.json(); //json is a function that is available on all responses of the fetch method. json is an asyncronous function and it'll also return a new promise.\r\n    })\r\n}\r\n\r\nfunction renderCountry(data, className = ''){\r\n    //Metodo 1\r\n    const html = `\r\n    <article class=\"country ${className}\">\r\n        <img class=\"country__img\" src=\"${data.flags.svg}\" />\r\n        <div class=\"country__data\">\r\n            <h3 class=\"country__name\">${data.name.common}</h3>\r\n            <h4 class=\"country__region\">${data.region}</h4>\r\n            <p class=\"country__row\"><span>👫</span>${Number(data.population / 1000000).toFixed(1)} people</p>\r\n\r\n            <p class=\"country__row\"><span>🗣️</span>${data.languages[Object.keys(data.languages)[0]]}</p>\r\n            <p class=\"country__row\"><span>💰</span>${data.currencies[Object.keys(data.currencies)[0]].name}</p>\r\n        </div>\r\n    </article>`;\r\n\r\n    //Metodo 2\r\n    // <p class=\"country__row\"><span>🗣️</span>${Object.values(Object.values(data.currencies)[0])[0]}</p>\r\n    // <p class=\"country__row\"><span>💰</span>${Object.values(data.languages)[0]}</p>\r\n\r\n    countriesContainer.insertAdjacentHTML('beforeend', html);\r\n    // countriesContainer.style.opacity = 1;\r\n}\r\n\r\nfunction renderError(msg){\r\n    countriesContainer.insertAdjacentText(\"beforeend\", msg);\r\n    // countriesContainer.style.opacity = 1;\r\n}\r\n\r\nbtn.addEventListener(\"click\", function(){\r\n    getCountryData(\"russia\");\r\n    // getCountryData(\"australia\"); \r\n    // getCountryData(\"gtrgt\"); //Line to execute an error\r\n}); */\r\n\r\n/* //Ejemplo 20: Excercise no. 1\r\n\r\n// In this challenge you will build a function 'whereAmI' which renders a country only based on GPS coordinates. For that, you will use a second API to geocode coordinates. \r\n// So in this challenge, you’ll use an API on your own for the first time. Your tasks:\r\n// 1. Create a function 'whereAmI' which takes as inputs a latitude value ('lat') and a longitude value ('lng') (these are GPS coordinates, examples are in test data below).\r\n// 2. Do “reverse geocoding” of the provided coordinates. Reverse geocoding means to convert coordinates to a meaningful location, like a city and country name. Use this API \r\n//    to do reverse geocoding: https://geocode.xyz/api. The AJAX call will be done to a URL with this format: https://geocode.xyz/52.508,13.381?geoit=json. Use the fetch API and\r\n//    promises to get the data. Do not use the 'getJSON' function we created, that is cheating \r\n// 3. Once you have the data, take a look at it in the console to see all the attributes that you received about the provided location. Then, using this data, log a message \r\n//    like this to the console: “You are in Berlin, Germany”\r\n// 4. Chain a .catch method to the end of the promise chain and log errors to the console\r\n// 5. This API allows you to make only 3 requests per second. If you reload fast, you will get this error with code 403. This is an error with the request. Remember, fetch() \r\n//    does not reject the promise in this case. So create an error to reject the promise yourself, with a meaningful error message\r\n// 6. Now it's time to use the received data to render a country. So take the relevant attribute from the geocoding API result, and plug it into the countries API that we have been using.\r\n// 7. Render the country and catch any errors, just like we have done in the last lecture (you can even copy this code, no need to type the same code)\r\n\r\nconst countriesContainer = document.querySelector('.countries');\r\n\r\nfunction whereAmI(lat, lng){\r\n    fetch(`https://geocode.xyz/${lat},${lng}?geoit=json`)\r\n    .then(function(res){\r\n        if(!res.ok) throw new Error(`Problem with geocoding (${res.status})`)\r\n        return res.json();\r\n    })\r\n    .then(function(data){\r\n        console.log(data);\r\n        console.log(`You are in ${data.city}, ${data.country}`);\r\n        return fetch(`https://restcountries.com/v3.1/name/${data.country}`)\r\n    })\r\n    .then(function(res){\r\n        if(!res.ok) throw new Error(`Country not found (${res.status})`)\r\n        return res.json();\r\n    })\r\n    .then(function(data){\r\n        return renderCountry(data[0])\r\n    })\r\n    .catch(function(err){\r\n        console.log(`${err.message} 😈`);\r\n    })\r\n}\r\n\r\nfunction renderCountry(data){\r\n    //Metodo 1\r\n    const html = `\r\n    <article class=\"country\">\r\n        <img class=\"country__img\" src=\"${data.flags.svg}\" />\r\n        <div class=\"country__data\">\r\n            <h3 class=\"country__name\">${data.name.common}</h3>\r\n            <h4 class=\"country__region\">${data.region}</h4>\r\n            <p class=\"country__row\"><span>👫</span>${Number(data.population / 1000000).toFixed(1)} people</p>\r\n\r\n            <p class=\"country__row\"><span>🗣️</span>${data.languages[Object.keys(data.languages)[0]]}</p>\r\n            <p class=\"country__row\"><span>💰</span>${data.currencies[Object.keys(data.currencies)[0]].name}</p>\r\n        </div>\r\n    </article>`;\r\n\r\n    countriesContainer.insertAdjacentHTML('beforeend', html);\r\n    countriesContainer.style.opacity = 1;\r\n}\r\n\r\nwhereAmI(52.508, 13.381); // (Latitude, Longitude)\r\n// whereAmI(19.037, 72.873);\r\n// whereAmI(\"ukrj\", \"brths\"); */\r\n\r\n/* //Ejemplo 21: The Event Loop\r\nconsole.log(\"Test start\");\r\n\r\nsetTimeout(function(){ //This and the Promise.resolve() will be executed at the end. So, coat outside of any callback, will run first\r\n    console.log(\"0 sec timer\");\r\n}, 0);\r\n\r\n//This allow us to build a promise, so to create a promise that is immediately resolved.\r\nPromise.resolve(\"Resolved promise 1\")\r\n.then(function(res){\r\n    console.log(res);   \r\n});\r\n\r\nPromise.resolve(\"Resolved promise 2\")\r\n.then(function(res){\r\n    for (let i = 0; i < 10000000; i++) {};\r\n    console.log(res);\r\n})\r\n\r\nconsole.log(\"Test end\"); */\r\n\r\n/* //Ejemplo 22: Building a Simple Promise\r\n\r\nconst lotteryPromise = new Promise(function(resolve, reject){ //All of this will create new promise. As soon as the promise constructor runs, it will automatically execute this executor function that we pass in. And as it executes this function here, it will do so by passing in two other arguments. And those arguments are the resolve and reject functions.\r\n    console.log(\"Lottery dray is happening...\")\r\n    setTimeout(function(){\r\n        Math.random() >= 0.5 ? resolve(\"You win 💰\") : reject(new Error (\"You lost 💰\"));\r\n    }, 2000)\r\n});\r\n\r\nlotteryPromise.then(function(res){console.log(res)}).catch(function(err){console.error(err)}); */\r\n\r\n/* //Ejemplo 23: Promisifying setTimeout\r\nfunction wait(seconds){\r\n    return new Promise(function(resolve){ //This doesn't need the reject function because it's impossible for the timer to fail. \r\n        setTimeout(resolve, seconds);\r\n    })\r\n} \r\n\r\nwait(1000)//This will create a promise that wait for one second at first, and after that second it will resolve.\r\n.then(function() {\r\n    console.log('1 second passed');\r\n    return wait(1000); //Now we have to return a new promise\r\n})\r\n.then(function() {\r\n    console.log('2 second passed');\r\n    return wait(1000);\r\n})\r\n.then(function() {\r\n    console.log('3 second passed');\r\n    return wait(1000);\r\n})\r\n.then(function(){\r\n    console.log('4 second passed');\r\n}); */\r\n\r\n/* //Ejemplo 24: Promisifying the Geolocation API\r\nconst btn = document.querySelector('.btn-country');\r\nconst countriesContainer = document.querySelector('.countries');\r\n\r\nfunction getPosition(){\r\n    return new Promise(function(resolve, reject){\r\n        // navigator.geolocation.getCurrentPosition( //If getCurrentPosition automatically calls the pos function, and if it also automatically passes in the position, then we can simply do the next line.\r\n        //     pos => resolve(pos), \r\n        //     err => reject(err)); \r\n        navigator.geolocation.getCurrentPosition(resolve, reject);\r\n    });\r\n};\r\n\r\nfunction whereAmI(){\r\n    getPosition()\r\n    .then(function(pos){\r\n        console.log(pos)\r\n        const {latitude: lat, longitude: lng} = pos.coords;\r\n        return fetch(`https://geocode.xyz/${lat},${lng}?geoit=json`); //We return a new promise\r\n    })\r\n    .then(function(res){\r\n        if(!res.ok) throw new Error(`Problem with geocoding (${res.status})`)\r\n        return res.json(); //We return a new promise\r\n    })\r\n    .then(function(data){\r\n        console.log(data);\r\n        console.log(`You are in ${data.city}, ${data.country}`);\r\n        return fetch(`https://restcountries.com/v3.1/name/${data.country}`); //We return a new promise\r\n    })\r\n    .then(function(res){\r\n        if(!res.ok) throw new Error(`Country not found (${res.status})`)\r\n        return res.json(); //We return a new promise\r\n    })\r\n    .then(function(data){\r\n        return renderCountry(data[0]); //We return a new promise\r\n    })\r\n    .catch(function(err){\r\n        console.log(`${err.message} 😈`);\r\n    });\r\n};\r\n\r\nfunction renderCountry(data){\r\n    const html = `\r\n    <article class=\"country\">\r\n        <img class=\"country__img\" src=\"${data.flags.svg}\" />\r\n        <div class=\"country__data\">\r\n            <h3 class=\"country__name\">${data.name.common}</h3>\r\n            <h4 class=\"country__region\">${data.region}</h4>\r\n            <p class=\"country__row\"><span>👫</span>${Number(data.population / 1000000).toFixed(1)} people</p>\r\n\r\n            <p class=\"country__row\"><span>🗣️</span>${data.languages[Object.keys(data.languages)[0]]}</p>\r\n            <p class=\"country__row\"><span>💰</span>${data.currencies[Object.keys(data.currencies)[0]].name}</p>\r\n        </div>\r\n    </article>`;\r\n\r\n    countriesContainer.insertAdjacentHTML('beforeend', html);\r\n    countriesContainer.style.opacity = 1;\r\n}\r\n\r\nbtn.addEventListener(\"click\", whereAmI); */\r\n\r\n/* //Ejemplo 25: Excercise no. 2\r\n// 1. Create a function 'createImage' which receives 'imgPath' as an input. This function returns a promise which creates a new image (use document.createElement('img')) and \r\n//    sets the .src attribute to the provided image path. When the image is done loading, append it to the DOM element with the 'images' class, and resolve the promise. \r\n//    The fulfilled value should be the image element itself. In case there is an error loading the image (listen for the'error' event), reject the promise\r\n// 2. Consume the promise using .then and also add an error handler\r\n// 3. After the image has loaded, pause execution for 2 seconds using the 'wait' function we created earlier\r\n// 4. After the 2 seconds have passed, hide the current image (set display CSS property to 'none'), and load a second image (Hint: Use the image element returned by the \r\n//    'createImage' promise to hide the current image. You will need a global variable for that)\r\n// 5. After the second image has loaded, pause execution for 2 seconds again\r\n// 6. After the 2 seconds have passed, hide the current image\r\n\r\n// Test data: Images in the img folder. Test the error handler by passing a wrong image path. Set the network speed to “Fast 3G” in the dev tools Network tab, otherwise images load too fast\r\nconst imgCountainer = document.querySelector(\".images\");\r\n\r\nfunction createImage(imgPath){\r\n    return new Promise(function(resolve, reject){\r\n        const img = document.createElement('img');\r\n        img.src = imgPath;\r\n\r\n        img.addEventListener(\"load\", function(){\r\n            imgCountainer.append(img);\r\n            resolve(img);\r\n        });\r\n\r\n        img.addEventListener(\"error\", function(){\r\n            reject(new Error(\"Image not found\"));\r\n        });\r\n    })\r\n}\r\n\r\nfunction wait(seconds){\r\n    return new Promise(function(resolve){ //This doesn't need the reject function because it's impossible for the timer to fail. \r\n        setTimeout(resolve, seconds);\r\n    })\r\n} \r\n\r\nlet currentImg;\r\ncreateImage(\"imgs/img-1.jpg\")\r\n.then(function(res){\r\n    currentImg = res;\r\n    console.log(\"Image 1 loaded\");\r\n    return wait(2000);\r\n})\r\n.then(function(){\r\n    currentImg.style.display = \"none\";\r\n    return createImage(\"imgs/img-2.jpg\");\r\n})\r\n.then(function(img){\r\n    currentImg = img;\r\n    console.log(\"Image 2 loaded\");\r\n    return wait(2000);\r\n})\r\n.then(function(){\r\n    currentImg.style.display = \"none\";\r\n})\r\n.catch(function(err){\r\n    console.error(err);\r\n}); */\r\n\r\n/* //Ejemplo 26: Consuming Promises with Async/Await\r\n//Running Promises in Parallel Consuming Promises with Async/Await\r\nconst countriesContainer = document.querySelector('.countries');\r\n\r\nasync function whereAmI(country){\r\n    try{\r\n        //Geolocation\r\n        const pos = await getPosition();\r\n        const {latitude: lat, longitude: lng} = pos.coords;\r\n        \r\n        //Revers geocoding\r\n        const resGeo = await fetch(`https://geocode.xyz/${lat},${lng}?geoit=json`);\r\n        if(!resGeo.ok) throw new Error(\"Problem getting location data\");\r\n        const dataGeo = await resGeo.json(); //This returns a new promise\r\n        // console.log(resGeo);\r\n        // console.log(dataGeo);\r\n    \r\n        //Country data\r\n        const res = await fetch(`https://restcountries.com/v3.1/name/${dataGeo.country}`); //This will return a promise. So, await will stop decode execution at this point of the function until the promise is fulfull, and so until the data has been fetched. This isn't blocking the main threat of execution. So, it isn't blocking the call stack.\r\n        if(!res.ok) throw new Error(\"Problem getting location country\");\r\n        const data = await res.json(); //This returns a new promise\r\n        // console.log(res);\r\n        // console.log(data);\r\n    \r\n        renderCountry(data[0]);\r\n\r\n        return `You are in ${dataGeo.city}, ${dataGeo.country}`;\r\n    }\r\n    catch(err){\r\n        console.error(`${err} 😈`);\r\n        renderError(`😈 ${err.message}`);\r\n\r\n        //Reject promise returned from async function \r\n        throw error;\r\n    }\r\n};\r\n\r\nfunction getPosition(){\r\n    return new Promise(function(resolve, reject){\r\n        navigator.geolocation.getCurrentPosition(resolve, reject);\r\n    });\r\n};\r\n\r\nfunction renderCountry(data){\r\n    const html = `\r\n    <article class=\"country\">\r\n        <img class=\"country__img\" src=\"${data.flags.svg}\" />\r\n        <div class=\"country__data\">\r\n            <h3 class=\"country__name\">${data.name.common}</h3>\r\n            <h4 class=\"country__region\">${data.region}</h4>\r\n            <p class=\"country__row\"><span>👫</span>${Number(data.population / 1000000).toFixed(1)} people</p>\r\n\r\n            <p class=\"country__row\"><span>🗣️</span>${data.languages[Object.keys(data.languages)[0]]}</p>\r\n            <p class=\"country__row\"><span>💰</span>${data.currencies[Object.keys(data.currencies)[0]].name}</p>\r\n        </div>\r\n    </article>`;\r\n\r\n    countriesContainer.insertAdjacentHTML('beforeend', html);\r\n    countriesContainer.style.opacity = 1;\r\n};\r\n\r\nfunction renderError(msg){\r\n    countriesContainer.insertAdjacentText(\"beforeend\", msg);\r\n};\r\n\r\n//Metodo 1 con async await, usando IIEF (Immediately Invoked Function Expressions)\r\nconsole.log(\"1: Will get location\");\r\n(async function () {\r\n    try {\r\n        const city = await whereAmI();\r\n        console.log(`2: ${city}`);\r\n    } catch (err) {\r\n        console.error(`2: ${err.message} 💥`);\r\n    }\r\n    console.log('3: Finished getting location');\r\n})();\r\n\r\n//Metodo 2 con then y catch\r\n// whereAmI()\r\n//   .then(city => console.log(`2: ${city}`))\r\n//   .catch(err => console.error(`2: ${err.message} 💥`))\r\n//   .finally(() => console.log('3: Finished getting location')); */\r\n\r\n/* //Ejemplo 27: Running Promises in Parallel\r\nasync function get3Countries(c1, c2, c3){\r\n    try {\r\n        //If we use this method, then the 3 functions will run one after the other. So, if we use the second method, then the 3 functions wll run at the same time.\r\n        const [data1] = await getJSON(`https://restcountries.com/v2/name/${c1}`);\r\n        const [data2] = await getJSON(`https://restcountries.com/v2/name/${c2}`);\r\n        const [data3] = await getJSON(`https://restcountries.com/v2/name/${c3}`);\r\n        console.log([data1.capital, data2.capital, data3.capital]);\r\n\r\n        //This is a helper function on this promise constructor. So it's a static method. Now, this function takes in an array of promises and it will return a new promise (or also an array), which will then run all the promises in the array at the same time.\r\n        const data = await Promise.all([\r\n            getJSON(`https://restcountries.com/v2/name/${c1}`), \r\n            getJSON(`https://restcountries.com/v2/name/${c2}`), \r\n            getJSON(`https://restcountries.com/v2/name/${c3}`)\r\n        ]);\r\n        console.log(data.map(event => event[0].capital))\r\n\r\n    } catch (err) {\r\n        console.log(err);\r\n    }    \r\n}\r\n\r\nfunction getJSON(url, errorMsc = \"Something went wrong\"){\r\n    return fetch(url)\r\n    .then(function(response){\r\n        // console.log(response);\r\n\r\n        if(!response.ok) throw new Error(`${errorMsc} (${response.status})`); //When we use \"throw\" in any of our methods, means that it will terminate the currecnt function, and the promise will immediately reject. So, the proimse returned by this first \".then\" will be a rejected promise. And that rejection will then propagate all the way down to the catch handler, which we already have set up right down. \r\n        return response.json(); //json is a function that is available on all responses of the fetch method. json is an asyncronous function and it'll also return a new promise.\r\n    })\r\n}\r\n\r\nget3Countries(\"russia\", \"germany\", \"japan\"); */\r\n\r\n/* //Ejemplo 28: Other Promise Combinators: race, all, allSettled and any\r\n//It recives an array of promises and it also return a promise. Now, this promise returned by race is settled as asoon as one of the input promises settle. (settled means that a value is available and it doesn't matter if the promise gor rejecetd or fulfilled). So, in Promise.race(), basically the first settled promise wins the race.\r\n(async function(){\r\n    const res = await Promise.race([\r\n        getJSON(`https://restcountries.com/v2/name/russia`),\r\n        getJSON(`https://restcountries.com/v2/name/germany`),\r\n        getJSON(`https://restcountries.com/v2/name/japan`)\r\n    ]);\r\n\r\n    console.log(res[0]);\r\n})();\r\n\r\nfunction getJSON(url, errorMsc = \"Something went wrong\"){\r\n    return fetch(url)\r\n    .then(function(response){\r\n        // console.log(response);\r\n\r\n        if(!response.ok) throw new Error(`${errorMsc} (${response.status})`); //When we use \"throw\" in any of our methods, means that it will terminate the currecnt function, and the promise will immediately reject. So, the proimse returned by this first \".then\" will be a rejected promise. And that rejection will then propagate all the way down to the catch handler, which we already have set up right down. \r\n        return response.json(); //json is a function that is available on all responses of the fetch method. json is an asyncronous function and it'll also return a new promise.\r\n    });\r\n}\r\n\r\nfunction timeout(sec){\r\n    return new Promise(function(_, reject){\r\n        setTimeout(function(){\r\n            reject(new Error(\"Request took long time!!\"));\r\n        }, sec*1000)\r\n    })\r\n}\r\n\r\n//Promise.race() takes an iterable of promises as input and returns a single Promise. This returned promise settles with the eventual state of the first promise that settles. So, it will run the method that first happens, and then the rest of the methods will be rejected. So, that basically will then abort the fetch that is happening\r\nPromise.race([\r\n    getJSON(`https://restcountries.com/v2/name/mexico`),\r\n    timeout(10),\r\n])\r\n.then(res => console.log(res[0])).catch(err => console.error(err));\r\n\r\n//It takes in an array of promises again, and it will simply return an array pf all the settled promises, no matter if the promises got rejected or not. The difference with between each other, is that Promise.all() will short circuit as soon as one promises rejects, but Promse.allSettled simply never short circuits. It will only return all the results of all the promises.\r\nPromise.allSettled([\r\n    Promise.resolve('Success'),\r\n    Promise.reject('ERROR'),\r\n    Promise.resolve('Another success'),\r\n])\r\n.then(res => console.log(res));\r\n\r\n//It's a static method. Now, this function takes in an array of promises and it will return a new promise (or also an array), which will then run all the promises in the array at the same time.\r\nPromise.all([\r\n    Promise.resolve('Success'),\r\n    Promise.reject('ERROR'),\r\n    Promise.resolve('Another success'),\r\n])\r\n.then(res => console.log(res)).catch(err => console.error(err));\r\n\r\n// Promise.any() takes in an array of multiple promises and this one will then return the first fulfilled promise and it will simply ignore rejected promises. It's similar to Promise.race() with the difference that rejected promises are ignored, and so therefore the results of Promise.any() is always gonna be a fulfilled promise, unless of course all of them reject. \r\nPromise.any([\r\n    Promise.resolve('Success'),\r\n    Promise.reject('ERROR'),\r\n    Promise.resolve('Another success'),\r\n])\r\n.then(res => console.log(res)).catch(err => console.error(err)); */\r\n\r\n/* //Ejemplo 29: Excercise no. 3\r\n// Your tasks:\r\n// 1. Write an async function 'loadNPause' that recreates Challenge #2, this time using async/await (only the part where the promise is consumed, reuse the 'createImage' \r\n//    function from before). Compare the two versions, think about the big differences, and see which one you like more\r\n\r\n// 2. Create an async function 'loadAll' that receives an array of image paths 'imgArr'\r\n// 3. Use .map to loop over the array, to load all the images with the 'createImage' function (call the resulting array 'imgs')\r\n// 4. Check out the 'imgs' array in the console! Is it like you expected?\r\n// 5. Use a promise combinator function to actually get the images from the array \r\n// 6. Add the 'parallel' class to all the images (it has some CSS styles)\r\n\r\n// Test data Part 2: ['img/img-1.jpg', 'img/img-2.jpg', 'img/img3.jpg']. To test, turn off the 'loadNPause' function\r\n\r\nconst imgCountainer = document.querySelector(\".images\");\r\n\r\nfunction createImage(imgPath){\r\n    return new Promise(function(resolve, reject){\r\n        const img = document.createElement('img');\r\n        img.src = imgPath;\r\n\r\n        img.addEventListener(\"load\", function(){\r\n            imgCountainer.append(img);\r\n            resolve(img);\r\n        });\r\n\r\n        img.addEventListener(\"error\", function(){\r\n            reject(new Error(\"Image not found\"));\r\n        });\r\n    })\r\n}\r\n\r\nfunction wait(seconds){\r\n    return new Promise(function(resolve){ //This doesn't need the reject function because it's impossible for the timer to fail. \r\n        setTimeout(resolve, seconds);\r\n    })\r\n} \r\n\r\nasync function loadNPause(){\r\n    try {\r\n        let img; \r\n\r\n        //Load image 1\r\n        img = await createImage(\"imgs/img-1.jpg\");\r\n        console.log(\"Image 1 loaded\");\r\n        await wait(2000);\r\n        img.style.display = \"none\";\r\n\r\n        //Load image 2\r\n        img = await createImage(\"imgs/img-2.jpg\");\r\n        console.log(\"Image 2 loaded\");\r\n        await wait(2000);\r\n        img.style.display = \"none\";\r\n\r\n        //Load image 3\r\n        img = await createImage(\"imgs/img-3.jpg\");\r\n        console.log(\"Image 3 loaded\");\r\n        await wait(2000);\r\n        img.style.display = \"none\";\r\n\r\n    } catch (err) {\r\n        console.log(err);\r\n    }\r\n}\r\n\r\nasync function loadAll(imgArr){\r\n    try {\r\n        const imgs = imgArr.map(async function(event){\r\n            return await createImage(event)\r\n        });\r\n        console.log(imgs);\r\n\r\n        const imgsEl = await Promise.all(imgs); //When we map the array of imgs by using async-await, we get a promise (fulfilled) and not the three images of each one. So, if we'd want to get the three images we'd have to use the Promise.all(imgs), because all the promises are stored in imgs.\r\n        console.log(imgsEl);\r\n\r\n        imgsEl.forEach(event => event.classList.add(\"parallel\"));\r\n\r\n    } catch (err) {\r\n        console.log(err);\r\n    }\r\n}\r\n\r\n// loadNPause();\r\nloadAll(['imgs/img-1.jpg', 'imgs/img-2.jpg', 'imgs/img-3.jpg']); */\r\n\r\n\r\n//         $$$$$$$$$$$$$$$ MODERN JAVASCRIPT DEVELOPMENT: MODULES AND TOOLING $$$$$$$$$$$$$$$\r\n\r\n\r\n/* //Ejemplo 1: Importing and exporting modules\r\nconsole.log(\"Importing modile\");  //Variables that are declared inside of a module, are actually sculpt to the module. So basically inside a module, the module itself is like the top level scope. And so by default, this means that all top level variables are private inside of this variable.\r\nimport \"./shoppingCart.js\";       //All the modules are first executed before the rest of the code. */\r\n\r\n/* //Ejemplo 2: Named exports\r\nimport { addToCart, totalPrice as price, tq } from './shoppingCart.js'; //When we use named exports, we must use curly braces.\r\naddToCart('bread', 5);\r\nconsole.log(price, tq); */\r\n\r\n/* //Ejemplo 3: Getting an arror by not exporting a module\r\nconsole.log(shippingCost); //This will give us an error because we haven't exported the shippingCost variable from shoppingCart.js */\r\n\r\n/* //Ejemplo 4: Import all the exports of a module at the same time into an object\r\nimport * as ShoppingCart from './shoppingCart.js'; //This will create an object containing everything that is exported from the module that we will specify here.\r\nShoppingCart.addToCart('bread', 5);\r\nconsole.log(ShoppingCart.totalPrice); */\r\n\r\n/* //Ejemplo 5: Default exports\r\n// import add, { addToCart, totalPrice as price, tq } from './shoppingCart.js'; //We must avoid using named and default exports at the same time because this is a bad practice.\r\n// import add from './shoppingCart.js'; //When we use named exports, we must not use curly braces.\r\nimport add, { cart } from './shoppingCart.js';\r\nadd('pizza', 2);\r\nadd('bread', 5);\r\nadd('apples', 4);\r\n\r\n//We do not see that empty object, that we export, but instead we have the array with the objects that we just added to the cart, by calling the add function. And so that proves\r\n//that this import here, is in fact, not simply a copy of the value, that we exported here. Because if it was, then here we would simply get the empty array.\r\n//Imports are not copies of the exports. They are instead like a live connection, and what this means is that I point to the same place of memory\r\nconsole.log(cart); */\r\n\r\n/* //Ejemplo 6: Top-Level await\r\n//it's very important to remember that using top-level await, so await outside of any async function will block the entire module in a way that we really couldn't block code execution before.\r\nconst res = await fetch('https://jsonplaceholder.typicode.com/posts'); // this await keyword here, which is now outside of an async function, is blocking the entire execution of this module.\r\nconst data = await res.json();\r\nconsole.log(\"data\", data);\r\n\r\nasync function getLastPost() { //calling an async is not necessary because it returns a new promise ( Promise {<pending>} )\r\n    const res = await fetch('https://jsonplaceholder.typicode.com/posts');\r\n    const data = await res.json();\r\n\r\n    return { \r\n        title: data.at(-1).title, \r\n        text: data.at(-1).body \r\n    };\r\n};\r\n\r\nconst lastPost = getLastPost();\r\nconsole.log(\"lastPost\", lastPost);\r\n\r\nconst lastPost2 = await getLastPost();\r\nconsole.log(\"lastPost2\", lastPost2); */\r\n\r\n/* //Ejemplo 7: The Module Pattern (old way)\r\n\r\n// All of this data here is private because it is inside of the scope of the function. And so now all we have to do is to return some of this stuff in order to basically return a public API.\r\nconst ShoppingCart2 = (function(){\r\n    const cart = [];\r\n    const shippingCost = 10;\r\n    const totalPrice = 237;\r\n    const totalQuantity = 23;\r\n\r\n    function addToCart (product, quantity) {\r\n        cart.push({\r\n            product: product, \r\n            quantity: product\r\n        });\r\n        console.log(`${quantity} ${product} added to cart (sipping cost is ${shippingCost})`);\r\n    };\r\n\r\n    function orderStock (product, quantity) {\r\n        console.log(`${quantity} ${product} ordered from suplier`);\r\n    };\r\n\r\n    //we simply return an object, which contains the stuff that we want to make public here.\r\n    return {\r\n        addToCart,\r\n        orderStock,\r\n        cart,\r\n        totalPrice,\r\n        totalQuantity,\r\n    };\r\n\r\n}) ();\r\n\r\nShoppingCart2.addToCart('apple', 4);\r\nShoppingCart2.orderStock('pizza', 2);\r\nconsole.log(ShoppingCart2);\r\nconsole.log(ShoppingCart2.shippingCost); */\r\n\r\n/* //Ejemplo 8: CommonJS Modules\r\n\r\n// Export\r\nexports.addTocart = function (product, quantity) {\r\n    cart.push({ product, quantity });\r\n    console.log(\r\n        `${quantity} ${product} added to cart (sipping cost is ${shippingCost})`\r\n    );\r\n};\r\n\r\n// Import\r\nconst { addTocart } = require('./shoppingCart.js'); */\r\n\r\n/* //Ejemplo 9: Introduction to NPM\r\nimport add, { cart } from './shoppingCart';\r\nadd('pizza', 2);\r\nadd('bread', 5);\r\nconsole.log(cart);\r\n\r\n\r\nimport cloneDeep from '../node_modules/lodash-es/cloneDeep.js';\r\n// import cloneDeep from 'lodash-es';\r\n\r\nconst state = {\r\n    cart: [\r\n        { product: 'bread', quantity: 5 },\r\n        { product: 'pizza', quantity: 5 },\r\n    ],\r\n    user: { loggedIn: true },\r\n};\r\n\r\nconst stateClone = Object.assign({}, state);\r\nconst stateDeepClone = cloneDeep(state);\r\n\r\nstate.user.loggedIn = false;\r\nconsole.log(stateClone);\r\n\r\nconsole.log(stateDeepClone);\r\n\r\n//The goal of using Parcel is to bunddle the three modules together, which are script.js, shoppingCart.js and cloneDeep.js\r\n\r\n\r\nif (module.hot) {\r\n    module.hot.accept();\r\n} */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"version":3,"file":"index.71eb84b3.js.map","sourceRoot":"/__parcel_source_root/"}