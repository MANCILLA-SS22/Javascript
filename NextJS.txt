                                                                                                                   NextJS

- Definition: https://nextjs.org/docs

- Next.js Project Structure: This page provides an overview of the project structure of a Next.js application. It covers top-level files and folders, configuration files, and routing conventions within the app and pages directories.

- app Routing Convention: The following file conventions are used to define routes and handle metadata in the app router. These filenames are only reserved when creating them inside of the app/ folder (or any subfolder). Outside of the app/ 
  folder, these filenames are not treated in any special way.
   > page.js:  Create a new page (e.g., app/about/page.js creates a <your-domain>/about page)
   > layout.js: Create a new layout that wraps sibling and nested pages
   > not-found.js: Fallback page for "Not Found" errors (thrown by sibling or nested pages or layouts)
   > error.js: Fallback page for other errors (thrown by sibling pages or nested pages or layouts)
   > loading.js: Fallback page which is shown whilst sibling or nested pages (or layouts) are fetching data
   > route.js: Allows you to create an API route (i.e., a page which does NOT return JSX code but instea

- Hydration: It's how React attaches to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the cli
  It refers to the process of taking a server-rendered HTML markup and making it interactive by attaching event handlers or event listeners to the DOM, and converting it into a fully functional React application on the client side 
  to make the static HTML interactive. This is particularly important in scenarios involving server-side rendering (SSR), where the initial HTML is generated and sent by the server to ensure faster load times and better SEO. Here's a step-by-
  step breakdown of the hydration process:
    1. Server-Side Rendering (SSR): The React application is rendered to HTML on the server. This HTML is sent to the client as the initial response.
    2. Initial Load: The client receives the server-rendered HTML, which can be displayed immediately. This helps with performance as users can see the content faster, and it improves SEO since search engines can crawl the HTML content.
    3. Hydration: Once the HTML is loaded, React takes over and "hydrates" the application. This involves:
       > React loading the JavaScript bundle.
       > React attaching event listeners and making the HTML interactive.
       > React reconciling the initial HTML markup with the current state of the React components.
    4. Interactive Application: After hydration, the application becomes fully interactive, and React takes control of the DOM updates as usual.
  Hydration is crucial for combining the benefits of SSR and client-side rendering (CSR). It allows for faster initial page loads with server-rendered HTML while still enabling the rich, interactive user experiences provided by a client-side 
  React application.

  Put another way, It's like watering the “dry” HTML with the “water” of interactivity and event handlers. The server sends the client HTML along with a link to the JS to download. The JS gets downloaded and then “hydrates” the page taking it 
  from a plain page to one with interactivity meaning adding handlers to buttons, events to elements on the page like onClick and so forth.

- Client components: They allow you to write interactive UI that is prerendered on the server and can use client JavaScript to run in the browser. Here are a couple of benefits to doing the rendering work on the client, including:
   > Interactivity: Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the user and update the UI.
   > Browser APIs: Client Components have access to browser APIs, like geolocation or localStorage.

  Put another way, it typically refers to components that are rendered and managed on the client-side, as opposed to being rendered on the server-side. Here's a breakdown of what client components involve:
   1. Client-Side Rendering (CSR):
      > Client components are rendered in the browser.
      > The initial HTML content is minimal and serves as a placeholder.
      > React code (JavaScript) is sent to the browser, which then takes over and dynamically generates and manages the content.
      > The rendering happens entirely on the client side after the initial page load.
   2. Advantages of Client Components:
      > Interactivity: They allow for rich interactivity and dynamic updates without requiring a full page reload.
      > Performance: For highly interactive applications, rendering on the client can reduce the load on the server and improve perceived performance for users.
      > User Experience: They enable smooth transitions and animations, contributing to a better user experience.
   3. Lifecycle Management:
      > Client components have a full React lifecycle, meaning they go through phases like mounting, updating, and unmounting.
      > This allows for complex state management and side effects handling directly in the browser.
   4. Client-Side State:
      > They can manage local state using hooks like useState, useEffect, and others.
      > State changes trigger re-renders only on the client side, which can lead to more responsive and interactive applications.
   5. Examples and Usage:
      > Client components are typical in Single Page Applications (SPAs) where most of the application logic and UI updates are handled on the client side.
      > They are commonly used in scenarios where real-time updates, such as chat applications, live dashboards, or interactive forms, are required.
   
- 'use client': To use Client Components, you can add the React "use client" directive at the top of a file, above your imports. It is used to declare a boundary between a Server and Client Component modules. This means that by defining a 
  this in a file, all other modules imported into it, including child components, are considered part of the client bundle. 
  Put another way, It is used to explicitly specify that a file or module should be treated as client-side code. This is part of Next.js's approach to server-side rendering (SSR) and client-side rendering (CSR), helping developers manage 
  where and how their code runs. Here’s what it does:
    1. Explicit Client-Side Execution: By adding 'use client' at the top of a file, you're indicating that this component should only run on the client side. This can be important for components that rely on browser-specific APIs (like window 
       or document) or need to handle client-side state and effects.
    2. Optimized Performance: Using this directive can help optimize performance by preventing certain parts of your application from being unnecessarily processed on the server. This separation allows the server to focus on rendering server-
       specific code while offloading client-specific logic to the browser.
    3. Clarity in Code: It provides clarity in your codebase, making it clear which components are meant for client-side rendering. This can improve maintainability and reduce bugs related to rendering context (server vs. client).

- Server Actions: Server Actions are asynchronous functions that are executed on the server. They can be used in Server and Client Components to handle form submissions and data mutations in Next.js applications. A Server Action can be 
  defined with the React "use server" directive. You can place the directive at the top of an async function to mark the function as a Server Action, or at the top of a separate file to mark all exports of that file as Server Actions.
  We've got to always use "async" whenever we use 'use server'.

- Server Components: They can use the inline function level or module level "use server" directive. To inline a Server Action, add "use server" to the top of the function body. 
  server components are a feature introduced to improve the performance and flexibility of React applications. They allow you to render components on the server, sending the pre-rendered HTML to the client, which can then be hydrated with 
  client-side interactivity as needed. Here’s a more detailed breakdown. Here's a breakdown of what server components involve:
    1. Rendering on the Server: 
       > Server components are rendered on the server, meaning the HTML is generated there and sent to the client.
       > This can improve performance, as the client receives fully rendered HTML and can display it immediately, even before JavaScript loads.
    2. Improved Performance:
       > Server components can reduce the amount of JavaScript that needs to be sent to the client.
       > They allow for better use of server-side resources, reducing the load on the client and improving overall performance, especially for slower devices or connections.
    3. Data Fetching:
       > Server components can fetch data directly from the server, which can simplify the data-fetching logic.
       > They can leverage server-side APIs and databases directly without exposing sensitive data to the client.
    4. Hydration:
       > Once the HTML is rendered and sent to the client, it can be hydrated to add interactivity where needed.
       > Only the necessary JavaScript for interactive parts of the page is sent, rather than the entire application.
    5. Seamless Integration with Client Components:
       > Server components can be used alongside client components, allowing for a mix of server-rendered and client-rendered content.
       > This enables developers to choose the best rendering strategy for each part of their application. 

- 'use server': It is needed only if you’re using React Server Components or building a library compatible with them, and marks server-side functions that can be called from client-side code. This directive explicitly tells Next.js that the 
  component or function should be executed on the server side rather than the client side. This is particularly useful for optimizing performance and controlling where specific logic is executed in your application.

  To use it, you must add 'use server' at the top of an async function body to mark the function as callable by the client. We call these functions Server Actions.
  When calling a Server Action on the client, it'll make a network request to the server that includes a serialized copy of any arguments passed. If the Server Action returns a value, that value will be serialized and returned to the client.
  Instead of individually marking functions with 'use server', you can add the directive to the top of a file to mark all exports within that file as Server Actions that can be used anywhere, including imported in client code.
    > It must be at the very beginning of their function or module; above any other code including imports (comments above directives are OK). They must be written with single or double quotes, not backticks.
    > It can only be used in server-side files. The resulting Server Actions can be passed to Client Components through props. See supported types for serialization.
    > To import a Server Action from client code, the directive must be used on a module level.
    > Because the underlying network calls are always asynchronous, 'use server' can only be used on async functions.
    > Always treat arguments to Server Actions as untrusted input and authorize any mutations. See security considerations.
    > Server Actions should be called in a Transition. Server Actions passed to <form action> or formAction will automatically be called in a transition.
    > Server Actions are designed for mutations that update server-side state; they are not recommended for data fetching. Accordingly, frameworks implementing Server Actions typically process one action at a time and do not have a way to 
      cache the return value.

- React Server Component Payload: refers to the data sent from the server to the client when using Server Components. React Server Components allow developers to render parts of their React applications on the server, which can improve 
  performance by reducing the amount of JavaScript that needs to be sent to the client. 
  When a React Server Component is rendered on the server, the output is serialized into a payload. This payload contains the necessary data and instructions for the client to understand and render the component on the client side. The 
  payload is then sent to the client, where it is deserialized and used to rehydrate the component in the browser.
  The benefits of using React Server Components include improved initial load times, better SEO, and the ability to use server-side data fetching more seamlessly within the component logic. The payload is a crucial part of this process as it 
  ensures that the client receives the necessary information to correctly render the server-rendered components. Here are the key aspects of React Server Component Payload:
    > Serialization: The server renders the components and serializes the output into a payload format.
    > Data Transfer: This payload is transferred from the server to the client.
    > Deserialization: On the client side, the payload is deserialized to reconstruct the component state and render it in the browser.
    > Rehydration: The client uses the payload to rehydrate the server-rendered components, making them interactive.  
    
- Client-side rendering (CSR): It means rendering all pages directly in the browser using JavaScript. When all the data fetching is done by the browser instead of a server then it is pretty obvious that the page loading will be slow leading 
  to a bad user experience. It is faster after the first load since there are no server requests to change pages, which makes it insanely fast, and provides a better UX (user experience) because it gives a native-app feel to the page.
  It always loads a blank page and the markup only gets displayed after the JS has completely loaded. Keep in mind that this is only for the first render i.e. the first time React tree gets rendered from the DOM
  
- Server-side Rendering (SSR): Server-side rendering uses servers' request-response process to render the pages using JavaScript. Data fetching is done by the servers and hence it has good user experience.  
  The reason is that in SSR the server first loads the HTML content for the user to at least have some content on the web page while the JavaScript is being loaded in the background. 
  Put another way, it is the process of rendering web pages on the client using JavaScript. In this approach, the server sends the initial HTML file, but the client then uses JavaScript to dynamically update the page as needed. This allows 
  for more interactive and responsive web pages, as the client can update specific parts of the page without needing to reload the entire page. One example of a popular CSR framework is React. With React, you can write JavaScript code that 
  updates the DOM as needed, providing a more interactive and dynamic web application. But, how SSR Works in ReactJS:
    1. Request: The client (browser) makes a request to the server for a specific URL.
    2. Server Processing: The server runs the React code to generate the HTML for the requested URL.
    3. HTML Response: The server sends the fully rendered HTML back to the client.
    4. Hydration: The client-side JavaScript bundle is downloaded and executed. React "hydrates" the server-rendered HTML, making it interactive by attaching event handlers.

  Here are some of the most important beneffits: 
   > SSR is better for slow connections because the HTML is immediately provided, whereas in CSR the user sees a blank page until the Javascript is loaded and renders the page's content.
   > It allows better SEO (Search Engine Optimization) because the content doesn't have to be loaded by Javascript like in CSR, so the search engine's web crawlers can directly parse the information.
   > SSR first load is usually faster because it doesn't need to fetch the whole website in a Javascript bundle as CSR does (some performance optimizations can be made in CSR to reduce this payload, like dynamic imports).
   > More dynamic and interactive web applications
   > Can provide a smoother and more seamless user experience
   > Can reduce the need for additional server requests

- Static site generator (SSG): SSG has similarities with SSR. The page is also generated in the server, however, the page is rendered at build time. So, instead of rendering the page on the server upon the receival of a request, the page is 
  already rendered in the server, waiting to be served to the client. I’ll discuss the advantages and disadvantages of this approach, and compare it with SSR further below.

- Difference between SSR and SSG: The difference between these two is that in SSR the server needs to render the page before sending it to the user (render at runtime), and with SSG this is not necessary, because it's done at build time. You 
  may feel like "why on earth should I use SSR then?". It's simple: most websites usually have dynamic, stateful data (e.g.: user email/logo on the navbar when a user is logged in). This means we can't pre-render at build time templates with 
  this data, so the only way to have this data with SSG would be to import it via Javascript (which would defeat SSG's core purpose).
  
- Loader in image: A loader is a function that generates the URLs for your image. It modifies the provided src, and generates multiple URLs to request the image at different sizes. These multiple URLs are used in the automatic srcset 
  generation, so that visitors to your site will be served an image that is the right size for their viewport.
  The default loader for Next.js applications uses the built-in Image Optimization API, which optimizes images from anywhere on the web, and then serves them directly from the Next.js web server. If you would like to serve your images 
  directly from a CDN or image server, you can write your own loader function with a few lines of JavaScript.

- Layout shift: refers to unexpected movement of web page elements while the page is still loading or when dynamic content is being added to the page. This can be a frustrating experience for users as it may cause them to lose track of what 
  they were reading or accidentally click on something they didn't intend to. In the context of Next.js (and web development in general), layout shifts can occur due to several reasons, such as:
    > Late Loading Images: When images don't have specified dimensions, the browser doesn't know how much space to allocate for them, leading to a shift in layout once the image loads.
    > Dynamic Content Injection: Content loaded dynamically via JavaScript can cause elements to move around.
    > Fonts: Custom fonts that are not initially loaded can cause text to re-render with a different size once the font is available.
    > Ads and Embeds: Ads or third-party embeds can load and push content around.

- blur-up placeholders: It refer to a technique used to enhance the user experience when loading images. This method involves displaying a low-resolution, blurred version of an image while the high-resolution version is being loaded. 
  Here's how it works and why it's used:
    > Low-Resolution Placeholder: A small, low-resolution version of the image is initially loaded. This image is quick to download because of its small size.
    > Blur Effect: This low-resolution image is displayed with a blur effect. The blur makes the low quality less noticeable and provides a smooth visual transition to the high-resolution image.
    > High-Resolution Image: As the high-resolution image finishes loading, it replaces the blurred placeholder.
  The benefits of using blur-up placeholders include:
  > Improved Perceived Performance: Users see something related to the final content quickly, reducing the perception of waiting.
  > Smooth Transition: The gradual transition from a blurred placeholder to a sharp image is visually pleasing and less jarring than loading the image in chunks or displaying a blank space.
  
- Largest Contentful Paint (LCP): LCP reports the render time of the largest image or text block visible in the viewport, relative to when the user first navigated to the page.
  


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$                                                                                                       

- <Link>: It's a React component that extends the HTML <a> element to provide prefetching and client-side navigation between routes. It is the primary way to navigate between routes in Next.js.

- <Image>: This API reference will help you understand how to use props and configuration options available for the Image Component. For features and usage, please see the Image Component page.
   > fill: A boolean that causes the image to fill the parent element, which is useful when the width and height are unknown.
     The parent element must assign position: "relative", position: "fixed", or position: "absolute" style.
     By default, the img element will automatically be assigned the position: "absolute" style.
     If no styles are applied to the image, the image will stretch to fit the container. You may prefer to set object-fit: "contain" for an image which is letterboxed to fit the container and preserve aspect ratio.
     Alternatively, object-fit: "cover" will cause the image to fill the entire container and be cropped to preserve aspect ratio. For this to look correct, the overflow: "hidden" style should be assigned to the parent element.

- usePathname: It is a Client Component hook that lets you read the current URL's pathname.

- notFound(): The notFound function allows you to render the not-found file within a route segment as well as inject a <meta name="robots" content="noindex" /> tag. Invoking the notFound() function throws a NEXT_NOT_FOUND error and terminates 
  rendering of the route segment in which it was thrown. Specifying a not-found file allows you to gracefully handle such errors by rendering a Not Found UI within the segment.  
  Put another way, calling this function will stop this component from executing and will show the closest not-found or error page.

- metadata: It's only supported in Server Components

- generateMetadata(): It's only supported in Server Components

- redirect

- revalidatePath




