$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$                                                                                                       

                                                                                                                   React

- Componentes (components): Es un conjunto de elementos que cumplen una función específica en la interfaz de usuario. Se utilizan para construir la jerarquía de todos esos elementos. Cada componente puede contener otros componentes como 
  hijos. básicamente, las aplicaciones en React básicamente se construyen mediante los mismos. permiten separar la interfaz de usuario en piezas independientes, reutilizables y pensar en cada pieza de forma aislada.
  
- Propiedades (props): Son la forma que tiene React para pasar parámetros de un componente superior a sus hijos. Se utilizan para pasar datos de un componente padre a un componente hijo, manteniendo el flujo unidireccional 
  de los datos. Las props son objetos que contienen datos específicos que un componente necesita para renderizarse correctamente. Esto permite la reutilización de componentes en diferentes partes de la aplicación con diferentes datos.
  Si alguna prop es una función (callback), el componente hijo puede llamarla para provocar efectos secundarios en el componente padre.
  
- prop.childern: Children es una manera que tiene react de permitirnos proyectar/transcluir uno o más componentes dentro otro. Es ideal cuando necesitamos que un elemento quede dentro de otro, sin que sepan el uno del otro, y cuando   
  necesitamos implementar patrones más complejos. La prop children es una prop especial que se pasa a los componentes. Es un objeto que contiene los elementos que envuelve un componente.
  El concepto de children es la forma en que React nos permite incluir un componente dentro de otro sin que al padre le importe exactamente qué componente o componentes hijos están siendo incluidos. Los elementos hijos son aquellos que se 
  colocan dentro de la etiqueta de apertura y cierre del componente y la prop “children” se utiliza para acceder y manipular estos elementos hijos desde dentro del componente padre. 
  De esta manera, podemos crear componentes más flexibles y reutilizables que acepten contenido personalizado y que puedan renderizarlo de manera dinámica.        

- return: The return method in React is a way to return data from a component. It returns the data that was passed into the component, which the parent component can then use. The return method is generally used when you want to return a 
  single value from a component. For example, if you want to return the text of a button from a Component, you would use the return method.
   
    > When To Use The Return Method In React Js? The return method can be used in a few different situations. One example would be when you want to return a default value from a function. Another instance would be when you wish to return a 
      value from a component used as a stateless functional component. You can also use the return method to return values from higher-order components.
    > When To Not Use The Return Method In React Js? The return method should not be used when you need to return multiple values from a function. In this case, the render method should be used instead. Additionally, the return method should 
      not be used when you need to call a function that is not in the same component. 
    > 1) The return method can return any value. 2) The return method returns a value. 3) The return method is used when you want to reuse an existing component. 4) The return method is less commonly used.
  
- Componentes basados en funciones: Hoy en día todos los componentes de React se crean a partir de funciones, lo que hace que sea mucho más fácil de escribir el código y entenderlo. Antes aquellos componentes que se encargaban del 
  funcionamiento de la app, se creaban a partir de la clase Components para poder implementar las características de los componentes de React. Lo que hacía más complejo el modelo mental.
  Pueden recibir propiedades (props). Tienen la capacidad de hacer render de un único elemento. Aunque este elemento puede tener muchos elementos dentro. Pueden tener estados.
    
- Controlled vs Uncontrolled Components & Stateless vs Stateful Components: 
    
- Render de un único elemento: Los componentes deben retornar un solo elemento o componente, pero este elemento o componente sí puede tener más de un elemento o componente hijo. En caso de no necesitar que el elemento padre forme parte del 
  árbol del DOM, se puede utilizar React.Fragment, o lo que es lo mismo utilizar un tag sin tipo <></>.
  
- map(): Creates a new array with the result of calling a function for each array element. El método map() crea un nuevo array con todos los elementos del original transformados según las operaciones de la función enviada por parámetro. 
  Tiene la misma cantidad de elementos pero los almacenados son el return de la función. En el ejemplo, la función retorna la propiedad nombre de cada elemento y eso es lo que se almacena en el nuevo array nombres. Map() se utiliza 
  mucho para transformación de arrays.
  En REACT, debemos incluir en cada elemento la propiedad key, que marque la identidad del elemento. Es decir, debemos poner algo que se encuentre en el array u objeto pero que estemos seguros de que NO SE REPETIRA (lo mas 
  recomendable seria el id, ya que este empieza desde 1 hasta un numero indefinido pero que siempre estara cambiando). Esto ayudará a react a optimizar el rendering ante cambios en el array. De no tenerla podemos auto-generarla con el 
  index provisto por el segundo parámetro de map, pero sólo optimizará si hay adiciones al final del array.
  Whenever the key changes on a component, even if that component is not part of a list, whenever it changes, REACT will destroy the old component instance and create a new one.  
  
- Key: En REACT, debemos incluir en cada elemento la propiedad key, que marque la identidad del elemento. Es decir, debemos poner algo que se encuentre en el array u objeto pero que estemos seguros de que NO SE REPETIRA (lo mas recomendable    
  seria el id, ya que este empieza desde 1 hasta un numero indefinido pero que siempre estara cambiando). Esto ayudará a react a optimizar el rendering ante cambios en el array. De no tenerla podemos auto-generarla con el index provisto por 
  el segundo parámetro de map, pero sólo optimizará si hay adiciones al final del array. Whenever the key changes on a component, even if that component is not part of a list, whenever it changes, REACT will destroy the old component 
  instance and create a new one.
    
- States: Los estados de un componente en React se utilizan para representar la información que puede cambiar durante la vida útil del componente y afectar su representación en la interfaz de usuario. Todo cambio de estado va inicializar el 
  proceso de render a partir del nodo donde se produjo el cambio de estado y así se generará el nuevo Virtual DOM que luego será reconciliado. Los estados son un concepto de React, no de JavaScript, por lo que para implementarlo vamos a 
  necesitar de los Hooks de React.
  
  Es una de las maneras en las que se procesan datos. El estado es un objeto que contiene datos que pueden cambiar en el tiempo y se usa para controlar los cambios en la interfaz. El objeto props nos permite insertar datos estáticos. Con 
  esto nos referimos a que pasamos propiedades a un componente o elemento que luego se renderiza o visualiza de una determinada manera, con base a los datos que le pasamos. Entonces, si necesitamos darle dinamismo a un elemento, es decir, 
  datos que se modifiquen a lo largo del tiempo, necesitaremos utilizar el estado en React.
  
  Mientras que las props son los datos que podemos pasarle a un componente o elemento React desde afuera, un estado se conforma por los datos internos que un componente puede manejar. A medida que estos datos son modificados, ya sea por una 
  interacción del usuario o por una recepción de datos de la API, el estado será modificado. Entonces, cada cambio de ese estado provocará que el elemento o componente se renderice de nuevo con una nueva representación en pantalla.
  Ten presente que podemos utilizar un estado en cualquier tipo de componente o elemento, sea del nivel más bajo o el nivel más alto. Allá donde necesitemos datos que cambian a lo largo del tiempo, podemos utilizar un estado.
  
- side effects: Side effects can be fetching data from a remote server, reading or writing to local storage, setting up event listeners, or setting up a subscription. These side effects can occur when a button is clicked, a form is submitted 
  or when a component is mounted and unmounted. React’s useEffecthook allows functional components to do things when a component is mounted or when some properties or states change. 
  
  Put another way, it refers to any operations or behaviors that occur in a component after rendering, and that don’t directly impact the current component render cycle. These side effects can include tasks such as data fetching, 
  subscriptions, manually changing the DOM, or other interactions with the outside world. One common use case for handling a side effect is making an asynchronous data request, such as fetching data from an API.
  
- Render y efectos: El funcionamiento de React está estrechamente ligado al cambio de estados. Cuando se produce un cambio de estado, React ejecuta un nuevo proceso de renderizado para ese componente y, de manera recursiva, para todos sus 
  componentes hijos. Durante este proceso React ejecuta de nuevo las funciones de los componentes para generar el nuevo árbol de elementos de la interfaz de usuario.  Dentro de los componentes podemos tener funciones para realizar diferentes 
  tareas, como, por ejemplo, una llamada a una api para obtener datos. Si en cada render se ejecuta esta llamada a la API, quiere decir que un cambio de estado está provocando efectos secundarios y no controlarlos puede traernos problemas.   
  
- Hydration: It's how React attaches to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the 
  cli It refers to the process of taking a server-rendered HTML markup and making it interactive by attaching event handlers or event listeners to the DOM, and converting it into a fully functional React application on the client side 
  to make the static HTML interactive. This is particularly important in scenarios involving server-side rendering (SSR), where the initial HTML is generated and sent by the server to ensure faster load times and better SEO. Here's a step-
  by-step breakdown of the hydration process:
    1. Server-Side Rendering (SSR): The React application is rendered to HTML on the server. This HTML is sent to the client as the initial response.
    2. Initial Load: The client receives the server-rendered HTML, which can be displayed immediately. This helps with performance as users can see the content faster, and it improves SEO since search engines can crawl the HTML content.
    3. Hydration: Once the HTML is loaded, React takes over and "hydrates" the application. This involves:
       > React loading the JavaScript bundle.
       > React attaching event listeners and making the HTML interactive.
       > React reconciling the initial HTML markup with the current state of the React components.
    4. Interactive Application: After hydration, the application becomes fully interactive, and React takes control of the DOM updates as usual.
  Hydration is crucial for combining the benefits of SSR and client-side rendering (CSR). It allows for faster initial page loads with server-rendered HTML while still enabling the rich, interactive user experiences provided by a client-side 
  React application.
  Put another way, It's like watering the “dry” HTML with the “water” of interactivity and event handlers. The server sends the client HTML along with a link to the JS to download. The JS gets downloaded and then “hydrates” the page taking 
  it from a plain page to one with interactivity meaning adding handlers to buttons, events to elements on the page like onClick and so forth.

- Optimistic updates: Optimistic updates mean updating the state immediately as if an action has succeeded, before confirmation from the server. This gives users instant feedback and makes the application feel more responsive. Later, the 
  actual outcome is handled, and the state is adjusted accordingly. If the operation fails, the changes are reverted. This can be a useful pattern for when you want to give the user the impression that their changes are immediate, even while 
  the mutation request is still in flight. Put another way, it's used when we wish to perform an update to cache data immediately after a mutation is triggered (assuming that the server operation will succeed).
  We should use optimistic updates when: 
   > Enhanced User Experience: When you want the application to feel more responsive and immediate, providing feedback to the user without waiting for server confirmation.
   > Low Failure Rate: When server operations have a high success rate and errors are rare.
   > Non-Critical Data: When the data being updated is not critical or when temporary inconsistencies can be tolerated.
   > Undo Functionality: When you provide an option to undo actions, allowing users to revert changes if something goes wrong.  
  The core concepts for an optimistic update are:
   > when you start a query or mutation, onQueryStarted will be executed
   > you manually update the cached data by dispatching api.util.updateQueryData within onQueryStarted
   > then,in the case that queryFulfilled rejects: you roll it back via the .undo property of the obj you got back from the earlier dispatch, or, you invalidate the cache data via api.util.invalidateTags to trigger a full re-fetch of the 
     dataWhere many mutations are potentially triggered in short succession causing overlapping requests, you may encounter race conditions if attempting to roll back patches using the .undo property on failures. For these scenarios, it is 
     often simplest and safest to invalidate the tags on error instead, and re-fetch truly up-to-date data from the server.
   
- Pessimistic updates: It's used when we wish to perform an update to cache data based on the response received from the server after a mutation is triggered. It waits for the server operation to complete before updating the UI. The UI is 
  only updated if the operation succeeds. The distinction between a pessimistic update and an optimistic update is that the pessimistic update will instead wait for the response from the server prior to updating the cached data. Basically, 
  it wait for the server operation to complete before updating the UI. The UI is only updated if the operation succeeds. We should use pessimistic updates when: 
    > High Failure Rate: When server operations frequently fail, and it’s crucial to ensure data consistency.
    > Critical Data: When updating critical data where consistency and accuracy are paramount.
    > Complex Error Handling: When the failure of the operation requires complex error handling or user intervention.
    > Real-Time Synchronization: When you need to ensure the client state is always synchronized with the server state.
  The core concepts for a pessimistic update are:
    > when you start a query or mutation, onQueryStarted will be executed
    > you await queryFulfilled to resolve to an object containing the transformed response from the server in the data property
    > you manually update the cached data by dispatching api.util.updateQueryData within onQueryStarted, using the data in the response from the server for your draft updates
    > you manually create a new cache entry by dispatching api.util.upsertQueryData within onQueryStarted, using the complete Post object returned by backend.


- Single-Page Application (SPA): 

- Search Engine Optimization (SEO): 
    
                                                                                               $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$  
    
    
- Hooks: Es una función especial que permite a los desarrolladores utilizar el estado y otras características de React en componentes de función, y utilizar las características de React en los componentes funcionales, en lugar de tener que 
  usar la clase Component. Los hooks son funciones que se pueden usar dentro de los componentes funcionales para agregar funcionalidad adicional de React. Las caracteristicas de los Hooks son:
    1) Comienzan con el prefijo “use” para que React pueda identificarlos y realizar validaciones.
    2) Solamente pueden utilizarse dentro de componentes funcionales.
    3) Deben ejecutarse siempre, es decir, en cada renderizado y el orden de ejecución debe ser siempre el mismo. No puede estar dentro de if, for, etc.
    4) Deben ejecutarse siempre en el cuerpo de la función del componente, por lo que normalmente se los ejecuta al inicio.
    5) Cuando los parametros del hook se quieran recuperar en una funcion a la que fueron mandados, se deben desestructurar. Es decir, poner como el siguiente ejemplo:  function Counter( {conteo, setConteo} ){
    
  Cualquier función que se declare con el prefijo “use”, React la tratará como un hook realizando las validaciones correspondientes y llamará a otros hooks dentro de esta función sin ser esta un componente, ya que si este hook padre cumple 
  las validaciones y, dentro de él, los hooks cumplen los requisitos correspondientes, pasarán todas las validaciones y podrá ejecutarse sin problemas. A estos hooks declarados por el desarrollador para encapsular una lógica de componente 
  específica se les llama custom hooks. Mientras el valor dentro del parentesis de useState no cambie (o se actualice), quiere decir que no se volvera a ejecutar la funcion, no hasta que haya un cambio.
  
  Lo más importante es que los hooks deben ser llamados únicamente en el nivel superior del componente funcional, nunca dentro de bucles, condiciones o funciones anidadas. 
  Esto asegura que los hooks siempre sean llamados en el mismo orden en cada renderizado y mantener la relación con cada una de las fibras de React. 
  También es importante tener en cuenta que los hooks no deben ser llamados desde funciones regulares. Si se llama a un hook desde una función regular, se producirá un error en tiempo de ejecución. 
  React detecta que una función es un componente gracias a la convención PascalCase utilizada para nombrarlos.
      
    > Hooks de estado: El estado permite que un componente «recuerde» información como la entrada de un usuario. Por ejemplo, un componente de formulario puede utilizar un estado para guardar la entrada del valor mientras que un componente 
      de galería de imágenes puede utilizar un estado para guardar el índice de la imagen seleccionada.
      
    > Hooks de contexto: El contexto permite a un componente recibir información de padres lejanos sin pasarlas como props. Por ejemplo, el componente en el nivel superior de tu aplicación puede pasar el actual tema de la UI a todos los 
      componentes dentro, sin importar la profundidad dentro del componente.
    
    > Hooks de refs: Las refs le permiten a un componente mantener alguna información que no es utilizada para el renderizado como un nodo del DOM o el ID de un timeout. A diferencia del estado, actualizar una ref no vuelve a renderizar tu 
      componente. Las refs son una «puerta de escape» del paradigma de React. Son útiles cuando necesitas trabajar con sistemas distintos de React, como las APIs integradas del navegador.

    > Hooks de Efecto: El Hook de Efecto permite a un componente conectarse y sincronizarse con sistemas externos. Esto incluye lidiar con la red, el DOM del navegador, animaciones, widgets escritos utilizando una biblioteca de UI diferente 
      y otro código que no es de React.

    > Hooks de rendimiento: Una forma común de optimizar el rendimiento del rerenderizado es evitar trabajo innecesario. Por ejemplo, puedes decirle a React que reutilice un cálculo guardado en caché o que se salte un rerenderizado si los 
      datos no han cambiado desde el renderizado anterior. Para evitar cálculos y renderizados innecesarios, usa uno de estos Hooks:

    > Otros: Algunas veces no podrás evitar un rerenderizado porque la pantalla realmente necesita una actualización. En ese caso, puedes mejorar el rendimiento separando las actualizaciones bloqueantes que deben ser síncronas (como al
      escribir dentro de una entrada de texto) de las actualizaciones no bloqueantes, que no necesitan bloquear la interfaz de usuario (como actualizar un gráfico). Para priorizar el renderizado, puedes usar: useTransition y useDeferredValue
    
    > Custom hooks: Los custom hooks en React son un tipo de función JavaScript que simula el funcionamiento de los hooks en React. Los custom hooks en React son muy útiles siempre que tengamos una lógica que se repite entre varios componen
      En estos casos, podemos sacar esta lógica y aplicarla a un custom hook, es decir, una función que ejecute los pasos que necesitamos de manera automática.
      Al no ser funciones cualquiera, los custom hooks en React deben seguir una serie de reglas para ser considerados hooks y no funciones. A continuación, te explicamos cuáles son.
       ~ El nombre empieza por «use»: La primera regla de los custom hooks en React es que su nombre debe empezar con la palabra use. Esta convención se crea siguiendo los hooks originales de React (useEffect, useState, useRef) y los 
         posteriores hooks en React Router (useParams, useLocation, useNavigate). Se considera que esto es una regla porque la comunidad ha decidido que es más sencillo reconocer un custom hook cuando sigue esta norma. Sin embargo, en teoría 
         podrías crear uno con otro nombre.
       ~ Puede llamar a otros hooks: Lo que realmente tienen de particular los custom hooks en React es que pueden llamar a otros hooks. En este orden de ideas, React considera como custom hook a aquella función que dentro llama a un hook 
         original o a otro custom hook.
       ~ Los custom hooks en React son muy útiles para extraer funcionalidades, hacer refactors y mantener nuestros componentes más simplificados. Esto es especialmente común cuando tenemos componentes que llaman a una API para obtener un 
         dato, lo meten en un estado y ejecutan una acción determinada con él. Todos estos pasos, que al final son muy repetitivos, se simplifican con el uso de custom hooks.
       ~ Cuando creamos un custom hook, este puede ser utilizado en diferentes components. Y si este custom hook tiene un useState, al momento de utilizar dicho hook en 2 o mas diferentes components, los estados de cada componente no se 
         relacionaran los unos con los otros. Es decir, si cambia el estado en un custom hook utilizado en un componente, los estados del otro componente no se veran afectados aunque se utilice el mismo custom hook.

- forwardRef: Lets your component expose a DOM node to parent component with a ref.

- createPortal: En React, createPortal se utiliza para renderizar un componente o elementos hijos fuera de la jerarquía del DOM del componente padre. Esto es útil en situaciones donde necesitas que un componente se renderice en una parte 
  diferente del DOM, como para modales, tooltips, y popovers, que suelen necesitar estar en un nivel superior del DOM para evitar problemas de estilos y posicionamiento. 

- <Suspense>: It's a component provided by React that allow us to handle loading states and show fallback content until some data or resource has been loadad.
  This component can be used in situations to show a fallback whilst we're waiting from other data to arrive.
  When working with NextJS, it makes sure that whenever you have a component, which performs some data fetching and returns such a promise up there, that such  components will trigger suspense to show the fallback until they're done. So you 
  don't need to do anything else.

- useState: useState es un hook de React que permite a los componentes funcionales tener estado. El estado permite que un componente «recuerde» información como la entrada de un usuario. Por ejemplo, un componente de formulario puede 
  utilizar un estado para guardar la entrada del valor mientras que un componente de galería de imágenes puede utilizar un estado para guardar el índice de la imagen seleccionada.
  La ejecución de la función Hook useState retorna un array con dos elementos:
    ● El primer elemento es el valor actual del estado. (estado actual)
    ● El segundo es una función que se utiliza para actualizar el estado, al llamar esta función con un nuevo valor pasado como argumento. 
    ● El use useState(0) representa el valor inicial

                                                       const [count, setCount] = useState(0);
                                                               
  Es importante destacar que esta función no actualiza el valor del estado de manera síncrona, sino que React lo actualiza cuando inicia el próximo ciclo de renderizado.
  Para inicializar el estado, se debe proporcionar un valor inicial como argumento a useState. Como esta función retorna un array de dos elementos podemos desestructurarlo para darle un nombre más apropiado a nuestro estado y a su 
  función de actualización. El nombre debe ser representativo del contenido y la función debe ser el mismo nombre con el prefijo “set”.
  Ahora, cuando queremos agregar algo mas a la variable y NO pisar ese valor contenido, lo que tenemos que hacer es usar el operador spread (...). Por ejemplo, si tengo el siguiente hook y quisiera pisar (cambiar) un dato contenio en 
  useState, simplemente hacemos lo de la segunda linea. Ahora, si se desea mantener el valor contenido en "cats" pero tener ahora un valor diferente, lo que debemos usar es usar el spread (...), y quedara como la tercer linea.
                                               
                                                       const [myThings, changeMyThings] = useState({cats: 'yes', strings: 'yellow', pizza: true });
                                                       changeMyThings({ cats: 'no' })               //Cambiando el valor iniciar
                                                       changeMyThings({ ...myThings, cats: 'no' })  //Agregar un valor diferente al que ya se encuentra, sin pisar o modificar el anterior.  

- useEffect: Sirve para sincronizar componentes con sistemas externos. Va a ser el hook que nos permita controlar efectos secundarios provocados por cambios de estados, es decir, se ejecuta cada que el estado ha cambiado. Utilizado 
  normalmente para sincronizar un componente con un sistema externo. Este hook recibe dos argumentos:
    ● El primero es una función de callback con acciones a ejecutar.
    ● El segundo es un array de dependencias, donde se indicará qué estados (pueden venir por props) deben cambiar para que se vuelva a ejecutar la función del primer argumento. 
   
  Para completar este array de dependencias la pregunta que debo hacerme es: ¿Con que estados debo sincronizar este efecto?
     useEffect(fn) // Con todos los estados
     useEffect(fn, []) // Con ningún estado (Se ejecutara solo una vez sin importar que los estados cambien simultaneamente)
     useEffect(fn, [esos, estados]) //Se recomienda generalmente usar props o estados dentro de la variable de de penedencia
         
  1) useEffect hook without mentioning any dependency array like.. useEffect(someCallbackFuction); runs for every render of the functional component in which its included..
  2) useEffect hook with an empty dependency array like this..  useEffect(callbackFunc , [] ) is executed only for the the initial render of the the functional component. And then it will not run in the further renders of the same
     functional Component.
  3) useEffect hook with some dependencies inside the dependency array like this.. useEffect(callbackFunc , [dependency] ); will run for the initial render as well as when the render happen due to change in dependencies mentioned in 
     the dependency array.
             
  Hay que tener en cuenta que useEffect se ejecuta siempre después del renderizado y por lo menos una vez al montar el componente.
  En la función de callback escribiremos el bloque de código que deseamos sincronizar en el cuerpo y retornaremos una función, llamada función de limpieza, que se ejecutará tantas veces como se haya ejecutado la función que la retorna. 
  Es decir, que el proceso es simétrico.
  Dado que la función se ejecutará por lo menos una vez al montar el componente, la función que se retorna se ejecutará una vez al desmontar el componente. En caso de tener dependencias de estados, la limpieza se ejecutará antes de 
  volver a ejecutar el efecto frente a un cambio en una de sus dependencias. ESTE HOOK SE EJECUTA SIEMPRE AL FINAL (cuando el componente se monte).
  Como podemos utilizar todos los useEffect que deseemos, es conveniente separar responsabilidades. Cada useEffect encargándose de un solo efecto y limpieza.
  Actualmente el modo estricto de React ejecuta dos veces la función del primer argumento. Por eso puede ser que veas dos veces un mismo console.log que se ejecutó dentro de esta función.
       
   ~ Cleanup: It is a function of the useEffect hook that allows us to stop side effects that no longer need to be executed before our component is unmounted. This cleanup function is executed after the first render, that's to say, our 
     first render won't take it into account, but after that, it'll execute the cleanup function and then the next useEffect, and so on. useEffectis built in such a way that we can return a function inside it and this return function is 
     where the cleanup happens. I.e, Component A requests the API to get a list of products, but while making that asynchronous request, Component A is removed from the DOM (it’s unmounted). There is no need to complete that asynchronous 
     request. So as a cleanup method to improve your application, you can clean up (cancel) the asynchronous request so that it’s not completed.
      
     React’s useEffect cleanup function saves applications from unwanted behaviors like memory leaks by cleaning up effects. In doing so, we can optimize our application’s performance. What is the useEffect cleanup function? Just like the 
     name implies, the useEffect cleanup is a function in the useEffect Hook that allows us to tidy up our code before our component unmounts. When our code runs and reruns for every render, useEffect also cleans up after 
     itself using the cleanup function.
     The useEffect Hook is built in a way that we can return a function inside it and this return function is where the cleanup happens. The cleanup function prevents memory leaks and removes some unnecessary and unwanted behaviors. the 
     useEffect cleanup function helps developers clean effects that prevent unwanted behaviors and optimizes application performance. However, it is pertinent to note that the useEffect cleanup function does not only run when our 
     component wants to unmount, it also runs right before the execution of the next scheduled effect.
           
   ~ What to add & Not to add as Dependencies
     You should add "everything" you use in the effect function as a dependency - i.e. all state variables and functions you use in there. That is correct, but there are a few exceptions you should be aware of:
      ` You DON'T need to add state updating functions (as we did in the last lecture with setFormIsValid): React guarantees that those functions never change, hence you don't need to add them as dependencies (you could though)
      ` You also DON'T need to add "built-in" APIs or functions like fetch(), localStorage etc (functions and features built-into the browser and hence available globally): These browser APIs / global functions are not related to the 
        React component render cycle and they also never change.
      ` You also DON'T need to add variables or functions you might've defined OUTSIDE of your components (e.g. if you create a new helper function in a separate file): Such functions or variables also are not created inside of a 
        component function and hence changing them won't affect your components (components won't be re-evaluated if such variables or functions change and vice-versa).
      ` So long story short: You must add all "things" you use in your effect function if those "things" could change because your component (or some parent component) re-rendered. That's why variables or state defined in component 
        functions, props or functions defined in component functions have to be added as dependencies.
                   
                                                                                                    
- useReducer: It is a React Hook that lets you add a reducer to your component. The useReducer() hook is similar to useState() since it also provides a way to manage state changes and updates in a functional component but is intended to 
  handle more complex state changes more efficiently. It:
    ` Takes a reducer() function as the first argument. This reducer() function is a pure function that takes in the current state, an action, and returns a new state. It does not modify the original state, but rather returns a new state 
      based on the action passed to it.
    ` Takes an initial state value as the second argument.
    ` Takes an (optional) initializer function that can be used to initialize state as the third argument. 
    ` And returns an array containing the current state value and a dispatch() function that can be used to trigger state changes by dispatching actions to the reducer.

                    const [state, dispatch] = useReducer(reducer, initialArg, init?);
                    
  > Parameters
    ~ state: It's the current state.
    ~ reducer: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types.
    ~ initialState: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next init argument.
      optional init: The initializer function that should return the initial state. If it’s not specified, the initial state is set to initialArg. Otherwise, the initial state is set to the result of calling init(initialArg).
  > Return 
    useReducer returns an array with exactly two values:
    The current state. During the first render, it’s set to init(initialState) or initialState(if there’s no init).
    The dispatch function that lets you update the state to a different value and trigger a re-render. Basically, what the "state" or "reducer" parameter recieves are the state (coming from initialState), and action (coming from dispatch). 
    And of course this will return the new state.
  > Caveats 
    useReducer is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
    In Strict Mode, React will call your reducer and initializer twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they 
    should be), this should not affect your logic. The result from one of the calls is ignored. 
  > dispatch function 
    The dispatch function returned by useReducer lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the dispatch function. (The dispatch function will basically run the 
    "reducer" function"). React will set the next state to the result of calling the reducer function you’ve provided with the current state and the action you’ve passed to dispatch. Now, by calling "reducer" we'll get the next function.
    It's important to remmind that the "state" parameter always needs to be returned.        function reducer(state, action){};
    
- useContext: El contexto permite a un componente recibir información de padres lejanos sin pasarlas como props. Por ejemplo, el componente en el nivel superior de tu aplicación puede pasar el actual tema de la UI a todos los 
  componentes dentro, sin importar la profundidad dentro del componente.     
    > useContext(SomeContext): Call useContext at the top level of your component to read and subscribe to context.
       ~ SomeContext: The context that you’ve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components.
    > Returns: useContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext.Provider above the calling component in the tree. If there is no such provider, then the returned 
      value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes.
    > Caveats: 
      ~ useContext() call in a component is not affected by providers returned from the same component. The corresponding <Context.Provider> needs to be above the component doing the useContext() call.
      ~ React automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison. Skipping re-
        renders with memo does not prevent the children receiving fresh context values.
      ~ If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if SomeContext that you use to provide context and SomeContext that you 
        use to read it are exactly the same object, as determined by a === comparison.
    
- useRef: This allows you to persist values between renders.This allows us to get access to other DOM elements and work with them. We can set up a connection between a HTML element which is being rendered in the end, and our JS code. 
  In difference with useState, useRef doesn't trigger a render and re-render of the component. It is not used for something that we're rendering, it's a hook that is used for values that are not needded for rendering.
  Se utiliza para crear una referencia mutable. Este hook retorna un objeto con una propiedad current la cual apuntará a un valor y podremos mutar. Se utiliza a menudo para acceder a elementos del DOM y modificarlos directamente. Esto 
  puede ser especialmente útil cuando se trabaja con librerías de terceros que requieren acceso directo a elementos del DOM. Es recomendable, siempre que sea posible, dejarle a React la responsabilidad de manejar el DOM. Además, useRef 
  también puede ser utilizado para mantener valores persistentes en el componente, lo que puede ser útil para realizar cálculos o para almacenar datos temporales que no deben ser expuestos al estado del componente. Es decir, cuando 
  actualizamos un estado o modificamos todo el contenido del componente, pero no los pertenecientes a useRef(). Esto es de gran ayuda porque en ocaciones dichas variables se pueden llegar a perder con los cambios de estado, y al utilizar 
  useRef(), esas variables siempre seguiran existiendo y con el mismo valor que le asignamos en un principio. Pero, si nosotros cambiamos el nombre de esa varaible, nuestra aplicacion no volvera a renderizarse, o sea, no se vera reflejado el 
  cambio en nuestra aplicacion pero si podriamos verlo en un console.log(), ya que internamente si cambiara. Pero, si el estado cambia o se actualiza la aplicacion, ahi SI se vera reflejado el cambio en esa variable de useref().
                                        const refObject = useRef( initialValue ); //initial value: pass the initial value to the useRef hook    //ref: React returns an object with a current property
  
  > Parameters 
    ~ initialValue: The value you want the ref object’s current property to be initially. It can be a value of any type. This argument is ignored after the initial render.
  > Returns: useRef returns an object with a single property:
    ~ current: Initially, it’s set to the initialValue you have passed. You can later set it to something else. If you pass the ref object to React as a ref attribute to a JSX node, React will set its current property.
      On the next renders, useRef will return the same object.
  > Caveats 
    ~ You can mutate the ref.current property. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn’t mutate that object.
    ~ When you change the ref.current property, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object.
    ~ Do not write or read ref.current during rendering, except for initialization. This makes your component’s behavior unpredictable.
    ~ In Strict Mode, React will call your component function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the 
      versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior.

- useCallback: permite guardar en caché una función definida antes de pasarla a un componente optimizado. useCallback is a React Hook that lets you cache a function definition between re-renders.
  > Parameters 
    ~ fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function 
      again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. 
      The function is returned to you so you can decide when and whether to call it.
    ~ dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for 
      React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency 
      with its previous value using the Object.is comparison algorithm.
  > Returns: 
    On the initial render, useCallback returns the fn function you have passed. During subsequent renders, it will either return an already stored fn  function from the last render (if the dependencies haven’t changed), or return the fn 
    function you have passed during this render.
  > Caveats 
    ~ useCallback is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
      React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React 
      will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists 
      in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on useCallback as a performance optimization. Otherwise, a state 
      variable or a ref may be more appropriate.
        
- useMemo: permite guardar en caché los resultados de un cálculo costoso de una funcion, y dicha funcion se volvera a ejecutar cuando una de sus dependencias (las cuales nosotros mismos definimos) cambie.

- useImperativeHandle: permite personalizar la ref expuesta por tu componente. Esto rara vez se usa. 
  We can call this hook in this component function to define properties and methods that should be accessible on this component here from outside this component.
  ref: The ref you received as the second argument from the forwardRef render function.
  function: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose.
    
- useLayoutEffect: se activa antes de que el navegador vuelva a pintar la pantalla. Aquí puedes hacer cálculos de maquetación (layout).
- useInsertionEffect: se activa antes de que React haga cambios en el DOM. Aquí las bibliotecas pueden insertar CSS dinámico.   
- useTransition: permite marcar una transición de estado como no bloqueante y permitir que otras actualizaciones la interrumpan.
- useDeferredValue: te permite aplazar la actualización de una parte no crítica de la interfaz de usuario y dejar que otras partes se actualicen primero.
- useDebugValue: permite personalizar la etiqueta que las Herramientas de Desarrollo de React muestran para tu Hook personalizado.
- useId: permite que un componente se asocie un ID único. Normalmente, se utiliza con las APIs de accesibilidad.
- useSyncExternalStore: permite que un componente se subscriba a un almacenamiento (store) externo.

- useFormState / useActionState: It is a Hook that allows you to update state based on the result of a form action.
  Call useActionState at the top level of your component to create component state that is updated when a form action is invoked. You pass useActionState an existing form action function as well as an initial state, and it returns a new 
  action that you use in your form, along with the latest form state. The latest form state is also passed to the function that you provided.
  
- useOptimistic: It lets you show a different state while an async action is underway. It accepts some state as an argument and returns a copy of that state that can be different during the duration of an async action such as a network 
  request. You provide a function that takes the current state and the input to the action, and returns the optimistic state to be used while the action is pending. This state is called the “optimistic” state because it is usually used to 
  immediately present the user with the result of performing an action, even though the action actually takes time to complete.  
                                      -->  const [optimisticState, addOptimistic] = useOptimistic(state, funcion(currentState, optimisticValue){});
    > state: Also knon as "prevState", the value to be returned initially and whenever no action is pending.
    > updateFn(currentState, optimisticValue): a function that takes the current state and the optimistic value passed to addOptimistic and returns the resulting optimistic state. It must be a pure function. The return value will be the 
      merged value of the currentState and optimisticValue.
    > optimisticState: The resulting and final optimistic state. It is equal to state unless an action is pending, in which case it is equal to the value returned by updateFn.
    > addOptimistic: addOptimistic is the dispatching function to call when you have an optimistic update. It takes one argument, optimisticValue, of any type and will call the updateFn with state and optimisticValue. 
      In this case, "optimisticValue" will catch the value we passed in the "addOptimistic()" function.
  The useOptimistic Hook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a  
  user submits a form, instead of waiting for the server’s response to reflect the changes, the interface is immediately updated with the expected outcome.
  For example, when a user types a message into the form and hits the “Send” button, the useOptimistic Hook allows the message to immediately appear in the list with a “Sending…” label, even before the message is actually sent to a server. 
  This “optimistic” approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the “Sending…” label is removed.
  
  useOptimistic helps manage the temporary optimistic state and the final state after the server response. It typically involves these steps:
    1. Initial State Setup: Define the initial state and the state that will be shown optimistically.
    2. Optimistic Update Function: Create a function that updates the state optimistically.
    3. Reverting Changes: Handle the case where the server responds with an error by reverting the state.
  
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$                                                                                                       


                                                                                                                   React-Router-Dom
                                                                                                                   
                                                                                                                   
- Absolute paths: An absolute path is the location of a file or directory specified from the root directory. It represents the complete path from the start of the filesystem from the root directory.
  The absolute path always begins from the start of the hard drive or other storage device, describing every step the user must take through the file system to end up in the specified location. Absolute paths are unambiguous and easy to 
  understand, and they are useful when you need to specify a file or directory's location precisely, irrespective of your current working directory. However, absolute paths can also be inconvenient to work with, especially when working with 
  deeply nested directories. They allow you to reference files and modules from any location in your project without specifying the relative path from the current file. This can make your code more readable and maintainable.
  In React-Router-Dom,  they're complete paths that define the exact location in the application's route hierarchy. They always start with a slash (/). They're useful when you want to define a route that should always be accessed directly 
  from the root of your application. For example: /about points directly to the /about route, regardless of the current location in the app.
  Absolute Paths always start with /, define routes relative to the root of the application, and are useful for top-level routes. (This means that it's always seen from after the domain name.)

- Relative paths: A relative path is the location of a file or directory relative to your current working directory. Unlike an absolute path, the relative path doesn't start with a slash or drive letter since it doesn't start from the root 
  directory. Relative paths simplify working with files by minimizing the typing needed to specify the file or directory path. A relative path is used whenever you refer to a file or directory only by its name. That is the simplest form of a 
  relative path, and the shell looks for the specified file name within the current directory.
  In React-Router-Dom, they're partial paths that are relative to the current route. They do not start with a slash. They're useful when defining nested routes or links within a nested route structure. For example:
  If you are currently on /dashboard and use a relative path settings, it will point to /dashboard/settings.
  Relative Paths do not start with /, define routes relative to the current route, and are useful for nested routes or links within nested structures. (they're nested in the "/" route)
                                                                                                                   
- createBrowserRouter([{}]): This is the recommended router for all React Router web projects. It's a powerful function provided by React Router that simplifies the process of setting up a router using the HTML5 history API. It allows you to 
  define routes declaratively and provides a clean, hash-free URL structure for your React applications.

- Routes: Routes are perhaps the most important part of a React Router appThey couple URL segments to components, data loading and data mutations. Through route nesting, complex application layouts and data dependencies become simple and 
  declarative. Routes are objects passed to the router creation functions.
   > path: The path pattern to match against the URL to determine if this route matches a URL, link href, or form action.
     ~ Dynamica Segments: If a path segment starts with : then it becomes a "dynamic segment". When the route matches the URL, the dynamic segment will be parsed from the URL and provided as params to other router APIs.
     ~ Optional Segments: You can make a route segment optional by adding a ? to the end of the segment.
     ~ Splats: Also known as "catchall" and "star" segments. If a route path pattern ends with /* then it will match any characters following the /, including other / characters.
     ~ Layout route: is a route that is used to apply a common layout or structure to multiple child routes. This is particularly useful when you have a consistent layout that should be applied to several pages or sections of your 
       pplication, such as a header, footer, or sidebar that remains the same while the content changes.  
   > index: Determines if the route is an index route. Index routes render into their parent's <Outlet/> at their parent's URL (like a default child route). This property is used to specify that a particular route should act as the default 
     or index route for a set of nested routes. This means that when a user navigates to the parent route, the index route will be rendered by default if no specific child route is matched. 
     This index route, which acts as the default route within a set of nested routes. It simplifies the management of nested routes by ensuring that a default component is rendered when navigating to a parent route. This approach enhances 
     the user experience by providing clear and intuitive navigation within your application.
   > element: This' the React Element/Component to render when the route matches the URL. The element parameter is used to specify the component that should be rendered when the route matches. This is typically used within a route definition 
     to determine what component should be displayed for a given path.
   > errorElement: When a route throws an exception while rendering, in a loader or in an action, this React Element/Component will render instead of the normal element/Component. The errorElement parameter is used to specify a component 
     that should be rendered when there is an error during the rendering of a route. This is useful for displaying custom error messages or handling errors gracefully within the routing system.
   > id: It helps uniquely identify each route. This ID can be useful in various scenarios, such as:
     ~ Error Handling: Each route can be assigned an id, and if an error occurs, the router can provide more detailed information about which specific route failed.
     ~ Data Loading and Caching: When using data loaders, the id can help identify and manage the data associated with each route. This can improve caching mechanisms and make the data loading process more efficient.
     ~ Nested Routes: In complex applications with nested routes, having unique identifiers for each route can simplify the process of locating and managing specific routes within the routing hierarchy.
   > children: This parameter is used to define nested routes within a parent route. This allows for the creation of complex routing structures where a parent route can contain multiple child routes, each rendering different components based 
     on the URL path. This also enables the creation of hierarchical routing structures, making it easier to manage complex applications with nested layouts or sections. By using the children parameter, you can ensure that nested routes are 
     rendered within a common layout, promoting code reuse and maintaining a consistent user experience.
   > loader: It's a function is used to load data asynchronously for a particular route. This function is part of the routing configuration and is called before the route component is rendered (then loader function will be triggered) and 
     provides data for the element through useLoaderData. It allows you to fetch data that the component needs in advance, ensuring that the component has all the data available when the it's mounted (first rendered), helping to avoid 
     loading states inside the component and improving the user experience by minimizing loading times and handling errors gracefully. This function returns a promise and allows you to load necessary data for a route and pass it to the 
     component that the route renders. 
   > action: It's called when a submission is sent to the route from a Form, fetcher, submission, navigation events, or other types of user interactions that trigger the route change. It is used to handle form submissions and other non-GET 
     requests (such as POST, PUT, DELETE) within a route. It allows you to process the form data and perform any necessary side effects (e.g., updating a database) before the component renders. This function receives a request object and 
     typically returns a response or a redirect. And you can use the useActionData hook to access the data returned from the action function in your component. Route actions are the "writes" to route loader "reads". 
     Specifically, it can refer to the way navigation is handled when using hooks like useNavigate or components like <Navigate>. For instance, when you use the useNavigate hook, you can specify the action parameter to determine how the 
     navigation should be performed.
   > lazy: In order to keep your application bundles small and support code-splitting of your routes, each route can provide an async function that resolves the non-route-matching portions of your route definition (loader, action,     
     Component/element, ErrorBoundary/errorElement, etc.). Lazy routes are resolved on initial load and during the loading or submitting phase of a navigation or fetcher call. You cannot lazily define route-matching properties (path, index, 
     children, caseSensitive) since we only execute your lazy route functions after we've matched known routes. Each lazy function will typically return the result of a dynamic import.
     In other words, this function is used to load components lazily, which means they are only loaded when needed. This can significantly improve the performance of your application by reducing the initial load time.
     The lazy function works by dynamically importing the component only when it is needed for rendering. This is particularly useful for large applications where loading all components upfront can be inefficient.

- <RouterProvider/>: All data router objects are passed to this component to render your app and enable the rest of the data APIs. It is used to wrap your entire application and provide the router instance you have configured to all the 
  components in your application tree. It  acts as a context provider for the routing context, making the routing state and functionality available throughout your component tree. It takes a router instance created by functions like 
  createBrowserRouter or createMemoryRouter as a prop. And, by using RouterProvider, you centralize the routing configuration and ensure all parts of your application can access and interact with the router.

- <Outlet>: An <Outlet> should be used in parent route elements to render their child route elements. This allows nested UI to show up when child routes are rendered. If the parent route matched exactly, it will render a child index route or 
  nothing if there is no index route. It's a placeholder that tells the router where to render the nested routes. This is particularly useful when building nested layouts, where you have a main layout and different content that changes based 
  on the current route.  
  If we were to use Outlet inside a <main> tag, then this tag specifies the main content of a document. The content inside the <main> element should be unique to the document. It should not contain any 
  content that is repeated across documents such as sidebars, navigation links, copyright information, site logos, and search forms. Outlet is what represents the content that is unique to the app. So basically it loads different views based 
  on the route that gets visited. So semantically using the main element makes sense but of course one can use any other element as well. There is no mandatory thing here.  
  
- <Link>: It's an element that lets the user navigate to another page by clicking or tapping on it. It renders an accessible <a> element with a real href that points to the resource it's linking to. it provides the following benefits:
   > Client-side navigation: Instead of making a full page reload, <Link> allows the application to navigate between different routes on the client side, making the transitions faster and smoother.
   > Preserves application state: By preventing full page reloads, it helps preserve the state of your application. This means that the state of components doesn't get reset upon navigation.
   > Integration with Router: <Link> works seamlessly with React Router to handle routing logic, such as updating the URL, maintaining history, and triggering route changes.
  You can use <Link reloadDocument> to skip client side routing and let the browser handle the transition normally (as if it were an <a href>).
  You can also use "realtive", which means that links are relative to the route hierarchy (relative="path"), so ".." will go up one Route level from the current contextual route. Occasionally, you may find that you have matching URL patterns 
  that do not make sense to be nested, and you'd prefer to use relative path routing from the current contextual route path. You can opt into this behavior with relative="path"
  
- <NavLink>: It is a special kind of <Link> that knows whether or not it is "active", "pending", or "transitioning". It is used to create navigation links with styling that can be automatically applied when the link is active, i.e., when the 
  link's destination matches the current URL. This is useful when building a navigation menu, such as a breadcrumb or a set of tabs where you'd like to show which of them is currently selected. It provides useful context for assistive 
  technology like screen readers. And, it provides a "transitioning" value to give you finer-grained control over View Transitions. This component has the following props: 
   > active: By default, an active class is added to a <NavLink> component when it is active so you can use CSS to style it. This make it easy to highlight the active link.
   > className: It works like a normal className, but you can also pass it a function to customize the classNames applied based on the active and pending state of the link.
   > children: You can pass a render prop as children to customize the content of the <NavLink> based on the active and pending state, which is useful to change styles on internal elements.
   > style: It works like a normal style prop, but you can also pass it a function to customize the styles applied based on the active and pending state of the link.
   > to: The destination URLK (required).
   > caseSensitive: Adding the caseSensitive prop changes the matching logic to make it case sensitive.
   > end: It changes the matching logic for the active and pending states to only match to the "end" of the NavLink's to path. If the URL is longer than to, it will no longer be considered active. <NavLink to="/"> is an exceptional case 
     because every URL matches /. To avoid this matching every single route by default, it effectively ignores the end prop and only matches when you're at the root route. For example: 
       <NavLin
       k to="/tasks"/>         --->  /tasks/123    --->   isActive = true
       <NavLink to="/tasks" end/>     --->  /tasks/123    --->   isActive = false
       <NavLink to="/tasks/" end />   --->	 /tasks        --->   isActive = false
       <NavLink to="/tasks/" end />   --->  /tasks/       --->   isActive = true
   
- <Form>: The Form component is a wrapper around a plain HTML form that emulates the browser for client side routing and data mutations. It is not a form validation/state management library like you might be used to in the React ecosystem 
  (for that, we recommend the browser's built in HTML Form Validation and data validation on your backend server). All of this will trigger state updates to any rendered useNavigation hooks so you can build pending indicators and optimistic 
  UI while the async operations are in-flight. If the form doesn't feel like navigation, you probably want useFetcher.
    > action: It's the url to which the form will be submitted, just like HTML form action. The only difference is the default action. With HTML forms, it defaults to the full URL. With <Form>, it defaults to the relative URL of the closest 
      route in context.
    > method: This determines the HTTP verb to be used. The same as plain HTML form method, except it also supports "put", "patch", and "delete" in addition to "get" and "post". The default is "get". (Get submissions will not call an action)
    > navigate: You can tell the form to skip the navigation and use a fetcher internally by specifying <Form navigate={false}>. This is essentially a shorthand for useFetcher() + <fetcher.Form> where you don't care about the resulting data 
      and only want to kick off a submission and access the pending state via useFetchers().
    > fetcherKey: When using a non-navigating Form, you may also optionally specify your own fetcher key to use via <Form navigate={false} fetcherKey="my-key">.
    > replace: Instructs the form to replace the current entry in the history stack, instead of pushing the new entry.
    > relative: By default, paths are relative to the route hierarchy, so .. will go up one Route level. Occasionally, you may find that you have matching URL patterns that do not make sense to be nested,and you're prefer to use relative 
      path routing. You can opt into this behavior with <Form to="../some/where" relative="path">
    > reloadDocument: Instructs the form to skip React Router and submit the form with the browser's built in behavior. 
    > state: The state property can be used to set a stateful value for the new location which is stored inside history state. This value can subsequently be accessed via useLocation().
    > preventScrollReset: this lets you prevent the scroll position from being reset to the top of the window when the form action redirects to a new location.
  The "Form" tag will make sure that the browser default of sending a request to the backend will be omitted, but it will take that request that would've been sent and give it to our action. This is pretty useful because that request will 
  contain all the data that was submitted as part of the form. That's to say, the 'post' method in Form won't be sent to the backend automatically, but instead to the our action and it will include all the form data.
  
- <Await>: Used to render deferred values with automatic error handling. Make sure to review the Deferred Data Guide since there are a few APIs that work together with this component. It expects to be rendered inside of a <React.Suspense> or 
  <React.SuspenseList> parent to enable the fallback UI. If you do not provide an errorElement, the rejected value will bubble up to the nearest route-level errorElement and be accessible via the useRouteError hook.
   > children: Can either be React elements or a function.
   > errorElement: The error element renders instead of the children when the promise rejects. You can access the error with useAsyncError. If the promise rejects, you can provide an optional errorElement to handle that error in a contextual 
     UI via the useAsyncError hook.
   > resolve: Takes a promise returned from a deferred loader value to be resolved and rendered. That's to say, the promise comiong from the "defer" utility.

- redirect: When you wanna return or throw responses in loaders and actions, you can use redirect to redirect to another route. It's recommended to use redirect in loaders and actions rather than useNavigate in your components when the 
  redirect is in response to data.

- json: It's used for handling and parsing JSON responses within loader and action functions. Loader and action functions are responsible for fetching and managing data. These functions return a response object, and the json() utility 
  simplifies the process of creating these responses with JSON content. The json() utility helps in creating a response object with the appropriate headers and JSON data. This is useful when you want to return JSON data from a loader or 
  action function. And it makes it easier to handle and return errors with appropriate status codes and messages.   You can throw in your loader to break out of the current call stack (stop running the current code) and React Router will 
  start over down the "error path". That's to say:
   > return json()   --> return code with no errors
   > throw json()    --> generate an error. Then, with help of "useRouteError" we'll be able to get that error.
  
  A shortcut for: 
      new Response(JSON.stringify(someValue), {
        headers: { "Content-Type": "application/json; utf-8" },
      });  
      
- defer: This utility allows you to defer values returned from loaders by passing promises instead of resolved values. It's used to defer the loading of data until it is actually needed. This can be particularly useful for optimizing the 
  loading experience of your application. When data fetching is deferred, it means that the rendering of a component or a route can proceed without waiting for the data to be fully loaded, and the data can be loaded asynchronously in the 
  background. It's important to note that this must be used with help of <Await> and <Suspense>.
  Here’s a basic explanation of how defer works:
    > Deferring Data Loading: Instead of fetching all necessary data before rendering a route, defer allows you to fetch the data after the route has been matched and the component has been rendered. This can improve the perceived 
      performance of your application by reducing the initial load time.
    > Loading States: While the data is being fetched, you can display a loading indicator or a placeholder UI. Once the data is loaded, it can be seamlessly injected into the component.
    > Optimizing Route Rendering: By deferring the data fetching, you can avoid blocking the rendering of your routes and provide a smoother user experience.
 By using defer, the component can start rendering immediately, and the data will be injected once it is available, providing a smoother and faster user experience.
 
- useLoaderData: It's a speciall hook which allow us to get access to the closest loader data. That's to say, you can retrieve data from the "loader" function used in the router "createBrowserRouter". You can use it in the elements that's 
  assigned to a route and in all compo0nents that might be used inside that element.

- useRouteLoaderData: This hook makes the data at any currently rendered route available anywhere in the tree. This is useful for components deep in the tree needing data from routes much farther up, as well as parent routes needing the data 
  of child routes deeper in the tree. Basically, it allow us to get access to a higher level loader (by means of an id) from a route that doesn't have a loader. 
  React Router stores data internally with deterministic, auto-generated route ids, but you can supply your own route id to make this hook much easier to work with. Consider a router with a route that defines an id.

- useSubmit: The imperative version of <Form> that lets you, the programmer, submit a form instead of the user. It's used to programmatically submit a form. It's particularly useful in scenarios where you need to trigger a form submission 
  without using a traditional form submit button, and based on some custom logic or events that are not directly tied to the form's submit button. This give you more control over how and when forms are submitted in your React applications.
  It's important to keep in mind that we must use and "action" function so we can retrieve the data coming from useSubmit. For example, we'd have our action function like this:    async function actionEventDetail({ request, params }) {}
  and this data is related to the "request" variable. 
  The first argument to submit accepts many different values. You can submit any form or form input element. You can submit FormData, URLSearchParams or anything that the URLSearchParams constructor accepts. This data will automatically be 
  wrapped in a form data object which we then could extract by using "request.formData()
  The second argument is a set of options that map (mostly) directly to form submission attributes. Some of those arguments are: 
    > method: The HTTP method to use (e.g., 'post', 'get').
    > action: The URL to submit the form to.
    > replace": A boolean indicating whether to replace the current entry in the history stack.
    > fetcherKey: 
    > navigate:  
    > preventScrollReset: 
    > relative: 
    > state: 

- useRouteError: Inside of an errorElement, this hook returns anything THROWN during an action, loader, or rendering.

- useAsyncError: Returns the rejection value from the nearest [<Await>][await] component. This is useful when handling errors by means of the "defer" utility. 

- useNavigate: The useNavigate hook returns a function that lets you navigate programmatically, for example in an effect. The navigate function has two signatures: Either pass a To value (same type as <Link to>) with an optional second 
  options argument (similar to the props you can pass to <Link>). Or pass the delta you want to go in the history stack. For example, navigate(-1) is equivalent to hitting the back button.

- useNavigation: This hook tells you everything you need to know about a page navigation to build pending navigation indicators and optimistic UI on data mutations. Things like: Global loading indicators, Disabling forms while a mutation is 
  happening, Adding busy indicators to submit buttons, Optimistically showing a new record while it's being created on the server,and Optimistically showing the new state of a record while it's being updated. 
  When using this hook, we'll be able to get access to the following methods:
    > state: When using this method, we'll get the following 3 answers: 
       ~ idle - There is no navigation pending.
       ~ submitting - A route action is being called due to a form submission using POST, PUT, PATCH, or DELETE
       ~ loading - The loaders for the next routes are being called to render the next page
      Normal navigations and GET form submissions transition through these states:       idle → loading → idle
      Form submissions with POST, PUT, PATCH, or DELETE transition through these states: idle → submitting → loading → idle
    > location: This tells you what the next location is going to be.
    > formData: Any POST, PUT, PATCH, or DELETE navigation that started from a <Form> or useSubmit will have your form's submission data attached to it. This is primarily useful to build "Optimistic UI" with the submission.formData FormData 
      object: In the case of a GET form submission, formData will be empty and the data will be reflected in navigation.location.search.
    > json: Any POST, PUT, PATCH, or DELETE navigation that started from a useSubmit(payload, { encType: "application/json" }) will have your JSON value available in navigation.json.
    > text: Any POST, PUT, PATCH, or DELETE navigation that started from a useSubmit(payload, { encType: "text/plain" }) will have your text value available in navigation.text.
    > formAction: Any POST, PUT, PATCH, or DELETE navigation that started from a <Form> or useSubmit will have form's submission action route's path value available in navigation.formAction. In the case of a GET form submission, 
      navigation.formAction will be empty. If you submitted the form at example.com/id, then navigation.formAction would be "/id"
    > formMethod: Any POST, PUT, PATCH, or DELETE navigation that started from a <Form> or useSubmit will have form's submission method value available in navigation.formMethod. In the case of a GET form submission, navigation.formMethod 
      will be empty. Here is an example.
   
- useFetcher: In HTML/HTTP, data mutations and loads are modeled with navigation: <a href> and <form action>. Both cause a navigation in the browser. The React Router equivalents are <Link> and <Form>.
  But sometimes you want to call a loader outside of navigation, or call an action (and get the data on the page to revalidate) without changing the URL or reloading. Or you need to have multiple mutations in-flight at the same time.
  Many interactions with the server aren't navigation events. This hook lets you plug your UI into your actions and loaders without navigating.   
  
  It should be used in different cases:
    > Whenever we wanna trigger actions, loaders or perform side effects such as loading data or submitting data (like forms) without actually navigating to the page to which the loader or action belongs. That's to say, avoid moving to a 
      different route transition or re-loading the page. If we use just Form then we'll be forwarded to the other route after submitting.
    > Fetching Data: It can be used to load data from an external source, such as an API endpoint, without triggering a navigation. Basically, without navigating away from the current page. This allows you to fetch data when certain events 
      occur, like when a component mounts or when a button is clicked.
    > Submitting Forms: You can use it to submit forms programmatically or asynchronously and handle the form submission lifecycle, including loading states and handling responses.
    > handle multiple concurrent submissions in a list (typical "todo app" list where you can click multiple buttons and all should be pending at the same time)
    > infinite scroll containers
    > creating seamless user experiences where data loading and form handling happen in the background.
    > Provides a streamlined way to manage loading states, handle errors, and manage form submission responses.
    > You can programmatically control the form submission process, including handling responses and updating UI state based on the outcome of the submission.

  Fetchers have a lot of built-in behavior:
    > Automatically handles cancellation on interruptions of the fetch
    > When submitting with an HTTP method, the action's called first after the action completes, the data on the page is revalidated to capture any mutations that may have happened,automatically keeping your UI in sync with your server state
    > When multiple fetchers are inflight at once, it will commit the freshest available data as they each land, and ensure no stale loads override fresher data, no matter which order the responses return.
    > Handles uncaught errors by rendering the nearest errorElement (just like a normal navigation from <Link> or <Form>)
    > Will redirect the app if your action/loader being called returns a redirect (just like a normal navigation from <Link> or <Form>)
    
  This hook owns the folloing properties: 
    > Form: Just like <Form> except it doesn't cause a navigation.
    > state: You can know the state of the fetcher with fetcher.state. It will be one of:
      ~ idle - nothing is being fetched.
      ~ submitting - A route action is being called due to a fetcher submission using POST, PUT, PATCH, or DELETE
      ~ loading - The fetcher is calling a loader (from a fetcher.load) or is being revalidated after a separate submission or useRevalidator call
    > submit(): The imperative version of <fetcher.Form>. If a user interaction should initiate the fetch, you should use <fetcher.Form>. But if you, the programmer are initiating the fetch (not in response to a user clicking a button, 
      etc.), then use this function.
    > data: The returned data from the loader or action is stored here. Once the data is set, it persists on the fetcher even through reloads and resubmissions.
    > json: When using fetcher.submit(data, { formEncType: "application/json" }), the submitted JSON is available via fetcher.json.
    > text: When using fetcher.submit(data, { formEncType: "text/plain" }), the submitted text is available via fetcher.text.
    > formData: When using <fetcher.Form> or fetcher.submit(), the form data is available to build optimistic UI.
    > formAction: Tells you the action url the form is being submitted to.
    > formMethod: Tells you the method of the form being submitted: get, post, put, patch, or delete.

- useSubmit: 
   
- useActionData:


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$                                                                                                       


                                                                                                                   Redux-Toolkit & React-Redux

https://redux.js.org/usage/deriving-data-selectors
https://redux-toolkit.js.org/api/createSlice#reducers
https://redux-toolkit.js.org/rtk-query/usage/automated-refetching#definitions 
https://redux-toolkit.js.org/rtk-query/api/createApi#tagtypes
https://redux-toolkit.js.org/rtk-query/usage/queries#selecting-data-from-a-query-result
https://redux-toolkit.js.org/rtk-query/usage/mutations
https://redux-toolkit.js.org/rtk-query/usage/manual-cache-updates#optimistic-updates
https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#usequery
https://redux-toolkit.js.org/rtk-query/api/createApi#basequery
https://redux-toolkit.js.org/rtk-query/api/fetchBaseQuery#baseurl
https://redux-toolkit.js.org/rtk-query/usage/queries
https://redux-toolkit.js.org/rtk-query/usage/customizing-queries

- Provider: The <Provider> component makes the Redux store available to any nested components that need to access the Redux store. Since any React component in a React Redux app can be connected to the store, most applications will render a 
  <Provider> at the top level, with the entire app’s component tree inside of it. Typically, you only need to pass <Provider store={store}>.
  
- ApiProvider: It simplifies data fetching and caching in your Redux applications. ApiProvider is a component that integrates with the store and provides context for the API services created using createApi. It sets up the necessary 
  middleware and manages the caching, invalidation, polling, and other aspects of data fetching.
    1. Context Provider: ApiProvider provides the context needed for RTK Query to function correctly. It ensures that the API service's hooks and other functionality are connected to the Redux store.
    2. Middleware Setup: When using ApiProvider, it automatically sets up the required middleware for handling API requests and responses, which includes caching, re-fetching, and more.
    3. Simplifies Configuration: Using ApiProvider simplifies the configuration needed to start using RTK Query. It abstracts away the manual setup of middleware and store enhancements required for API slices.

- store: The Redux store is like a giant container that holds all the data for your application.

- selector: It is a function used to extract and compute derived data from the Redux store state. Selectors help in selecting specific pieces of state and can also be used to transform or compute data based on that state. They play a crucial 
  role in ensuring that components only receive the data they need, thus improving performance and maintainability.
    > State Extraction: Selectors are primarily used to read and return a specific part of the Redux state.
    > Derived data: Selectors can compute derived data, meaning they can perform calculations or transformations on the state to produce new data that components might need.
    > Memoization: When created using "createSelector", selectors are memoized. This means they remember the previous inputs and outputs and only recompute the result if the inputs change, thus optimizing performance.
    > Reusability and composability: They can be composed from other selectors, promoting code reuse and modularity. They can be reused across different parts of the application, making it easier to maintain consistent data access patterns.

  It is any function that accepts the Redux state tree as an argument, and returns some extracted or derived data. They typically expect the entire Redux state object as an argument, while slice reducers only have access to a specific subset 
  of the entire Redux state

- action: An action is an object that describes what changes need to be made to the state of your application. It sends data from your application to the Redux store and serves as the only way to update the store. An action must have a 
  "type" property describing the action being performed. This "type" property is typically defined as a string constant to ensure consistency and avoid typos.
  In addition to the "type" property, an action can have a "payload" property. The "payload" property represents the data that provides additional information about the action being performed. For example, if an action type is ADD_TASK, the 
  payload might be an object containing a new task item's "id", "text", and "completed status". 
  "actions" doesn't allow to access the reducers methods to find up, but instead we get methods created automatically by Redux Toolkit, which when called will create action objects for us. These methods on the actions object which we can 
  call will create action objects for us. Therefore these methods are called action creators and they will create action objects for us where these objects already have a type property with a unique identifier per action. Automatically 
  created behind the scenes. So we don't have to worry about action identifiers. We don't have to create those action objects on our own. We can tap into this actions key into this actions object on our createSlice and execute these action 
  creator methods, which with their name match our reducer methods to dispatch actions, which will then ultimately trigger those different reducer methods.

- dispatch: dispatch is a function provided by the store that allows you to send an action to update the state of your application. When you call dispatch, the store runs an action through all of the available reducers, which in turn update 
  the state accordingly. You can think of dispatch as a mail carrier who delivers mail to different departments in a large company. Just like how the mail carrier delivers mail to different departments, dispatch delivers actions to various 
  reducers in your Redux store. Each reducer is like a department in the company that processes the mail and updates its own part of the company's data.

- reducer: A reducer is a function that takes in the current state of an application and an action as arguments, and returns a new state based on the action.
  Remember that reducer functions must be pure, side-effect free and synchronous. So your reducer functions should take some input in the case of the Redux reducer, the old state and the action, and then produce some output. And that's, by 
  the way not just the case for Redux reducer function. The reducer function you pass to use reducer, is react hook, works in the same way. It has nothing to do with redux, but it just general reducer concept that you have a pure, side 
  effects synchronous function that takes input and produces some output. And for the same input, for the same values, it will always produce the same output, without any side effects that happen along the way without any asynchronous code 
  that blocks it. No code of that kind must be part of your reducer functions.
    
- action creators and action types: These are fundamental concepts used to manage state in a Redux store. RTK simplifies and streamlines the process of working with these concepts compared to plain Redux.
    > action types: Action types are constants that represent the type of action being performed. They are typically defined as strings and are used to identify actions in the reducers. 
      In Redux Toolkit, you don't usually need to define these explicitly, as they are generated automatically when you create actions.
      Constants that represent the type of action being performed. In Redux Toolkit, they are usually generated automatically.
    > action creators: Action creators are functions that return action objects. An action object contains a type property (representing the action type) and an optional payload property 
      (containing any data needed to perform the action). Redux Toolkit simplifies the creation of action creators using functions like createAction and createSlice.
      Functions that return action objects. They can be created using createAction or automatically generated by createSlice.  
   
- subscribe: It's a term used in the context of the Redux store. Subscribing to the store means setting up a listener that will be called every time an action is dispatched, and as a result, the state tree might have changed. It's integral 
  to how state changes can be observed and responded to in a Redux-based application. In other words, it refers to a method provided by the Redux store that allows components or functions to listen for state updates. When you subscribe to 
  the store, a callback function is executed every time an action is dispatched and the state potentially changes.
  Cache subscriptions are used to tell RTK Query that it needs to fetch data for an endpoint. A subscription for an endpoint can be added by dispatching the result of the initiate thunk action creator attached to a query endpoint.
      
- thunk: It's a term that means "a piece of code that does some delayed work. So it's simply a function, that delays an action until later, until something else finished. We could write an action creator as a thunk, to write an action 
  creator, which does not immediately return the action object, but which instead, returns another function which eventually returns the action. So that we can run some other code before we then dispatch the actual action object that we did 
  want to create. 
  In RTK, a "thunk" is a middleware function that allows you to write action creators that return a function instead of an action. This function can then perform asynchronous operations, such as fetching data from an API or dispatching 
  multiple actions sequentially.
  In RTK, actions are usually plain objects, but when you need to perform asynchronous tasks, plain action objects are not sufficient. Thunks in Redux Toolkit enable you to manage asynchronous operations and complex synchronous logic 
  efficiently. By using thunks, you can keep your components clean and focus on handling side effects in a structured manner. Redux Toolkit’s createAsyncThunk further simplifies this process by automatically generating action types and 
  creators, making it easier to manage different states of asynchronous operations.
                                                                                                                   
- The "prepare" callback: It is a function used in createSlice to customize the payload and meta properties of an action. This is useful when you need to preprocess the action's payload or add additional metadata before the action is handled 
  by the reducer. It returns the action payload as it needs to be formatted. 
  If you need to customize the creation of the payload value of an action creator by means of a prepare callback, the value of the appropriate field of the reducers argument object should be an object instead of a function. This object must 
  contain two properties: reducer and prepare. The value of the reducer field should be the case reducer function while the value of the prepare field should be the prepare callback function.
  
- The "extraReducers" builder callback" notation: Sometimes a slice reducer needs to respond to other actions that weren't defined as part of the slices reducers, and that is like what happens when using "createAsyncThunk" or responding to 
  an action from another slice. It receives a builder object that has methods like addCase and addMatcher which are used to add additional reducers. And this builder parameter is an object that lets us definie additional case reducers that 
  run in response to the actions refined outside of the slice. However, unlike the reducers field, each individual case reducer inside of extraReducers will not generate a new action type or action creator. 
  If two fields from reducers and extraReducers happen to end up with the same action type string, the function from reducers will be used to handle that action type.
  We would use extraReducers when dealing with an action that we have already defined somewhere else. The extrareducers property in createSlice can be used as a function or as an object. extraReducers in Redux Toolkit provides a powerful way 
  to handle actions that are not defined within the slice itself. It is especially useful for managing the side effects of asynchronous actions and for ensuring that your slices remain decoupled and maintainable. By using extraReducers, you 
  can keep your action handling logic organized and clear, making your Redux store easier to manage and extend.

- Entity: It refers to a structured and normalized way of storing (or manage) collections of related items within the Redux state, in a normalized and efficient manner. This concept isused in conjunction with the createEntityAdapter utility, 
  which helps manage such collections efficiently.
  The term "Entity" is used to refer to a unique type of data object in an application. Entities are individual pieces of data, typically objects, that are identified by a unique key (usually an ID). Storing data as entities involves 
  normalizing the state, which means storing the data in a flat structure rather than deeply nested objects. This makes it easier to update, delete, and retrieve specific items without affecting other parts of the state.  
  For example, in a blogging application, you might have User, Post, and Comment data objects, with many instances of each being stored in the 
  client and persisted on the server. User is an "entity" - a unique type of data object that the application uses. Each unique instance of an entity is assumed to have a unique ID value in a specific field.

- Query: 

- Memoization: Storing the results of expensive function calls and returning the cached result when the same inputs occur again.
  Memoization in RTK Query refers to the process of caching the results of a function so that if the function is called again with the same arguments, the cached result is returned instead of recalculating the result. This is particularly 
  useful in reducing redundant network requests and improving performance by reusing previously fetched data. In the context of RTK Query (Redux Toolkit Query), memoization helps in the following ways:
    > Caching Requests: When a query is made, RTK Query caches the response. If the same query is requested again with the same parameters, RTK Query returns the cached response instead of making a new network request. This reduces 
      unnecessary API calls and speeds up the application.
    > Selective Refetching: RTK Query can be configured to refetch data only when specific conditions are met (e.g., after a certain time has passed or when the data becomes stale). This ensures that the application has the latest data 
      without overwhelming the server with requests.
    > Avoiding Recalculation: By memoizing query results, RTK Query avoids recalculating the data when the input parameters haven't changed. This leads to more efficient data management and rendering in the application.

-Tags: They are just a name that you can give to a specific collection of data to control caching and invalidation behavior for re-fetching purposes. It can be considered as a 'label' attached to cached data that is read after a mutation, to 
 decide whether the data should be affected by the mutation.   

- Normalization: It refers to the process of structuring your Redux state in a flat and organized manner, rather than deeply nested. This concept is borrowed from database design, where data is stored in a way that minimizes redundancy and 
  ensures consistency.
    1. Simplifies Updates: Updating deeply nested state can be complex and error-prone. Normalized state makes updates straightforward.
    2. Avoids Redundancy: By storing each entity in a single place, you avoid duplicating data and reduce the risk of inconsistencies.
    3. Improves Performance: Selectors can efficiently access and compute derived data without needing to traverse nested structures.
    4. Easier Debugging: A flat state structure is easier to inspect and understand. 
  In a normalized state, entities are stored in a flat structure, typically using an object where keys are entity IDs and values are the entity objects. Additionally, an array of IDs is maintained to keep track of the 
  order of entities. Normalized state structure is a recommended approach for storing items, and normalization means no duplication of data and it also means keeping the items stored in a lookup table by item id.
  
- Error handling: If your query or mutation happens to throw an error when using fetchBaseQuery, it will be returned in the error property of the respective hook. The component will re-render when that occurs, and you can show appropriate UI 
  based on the error data if desired. Some Error Display Examples are "Query Error" and "Mutation Error". If you need to access the error or success payload immediately after a mutation, you can chain .unwrap().  
  
- Manual Cache Updates: There are use cases when manual cache updates are necessary, such as "optimistic" or "pessimistic" updates, or modifying data as part of cache entry lifecycles. RTK Query exports thunks for these use cases, attached 
  to api.utils: updateQueryData and upsertQueryData. Since these are thunks, you can dispatch them anywhere you have access to dispatch. They're both utility functions that allow you to directly manipulate the cached data for a given query. 
    > Updating existing cache entries: For updates of existing cache entries, use updateQueryData. updateQueryData is strictly intended to perform updates to existing cache entries, not create new entries. If an updateQueryData thunk action 
      is dispatched and the endpointName + args combination that does not match any existing cache entry, the provided recipe callback will not be called, and no patches or inversePatches will be returned.
      Use cases for manual update of cache entries:
        ~ Providing immediate feedback to the user when a mutation is attempted
        ~ After a mutation, updating a single item in a large list of items that is already cached, rather than re-fetching the whole list
        ~ Debouncing a large number of mutations with immediate feedback as though they are being applied, followed by a single request sent to the server to update the debounced attempts
    > Creating new cache entries or replacing existing ones: To create or replace existing cache entries, use upsertQueryData. upsertQueryData is intended to perform replacements to existing cache entries or creation of new ones. Since 
      upsertQueryData does not have access to the previous state of the cache entry, the update may be performed only as a replacement. In comparison, updateQueryData allows patching of the existing cache entry, but cannot create a new one.
      One example use case is pessimistic updates. If the client makes an API call to create a Post, the backend could return its complete data including the id. Then we can use upsertQueryData to create a new cache entry for the 
      getPostById(id) query, preventing an extra fetch to retrieve the item later.       
  
                                                                                                 $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
                                                                                               

- configureStore(): The standard method for creating a Redux store. It wraps createStore to provide simplified configuration options and good defaults. It can automatically combine your slice reducers, adds whatever Redux middleware you 
  supply, includes redux-thunk by default. It accepts a reducer function as a named argument and automatically sets up the store with good default settings.
    > "reducer": A callback which will receive getDefaultMiddleware as its argument, and should return a middleware array. If this option is provided, it should return all the middleware functions you want added to the store. configureStore 
      will automatically pass those to applyMiddleware. If not provided, configureStore will call getDefaultMiddleware and use the array of middleware functions it returns.
    > "middleware": A callback which will receive getDefaultMiddleware as its argument, and should return a middleware array. If this option is provided, it should return all the middleware functions you want added to the store. 
      configureStore will automatically pass those to applyMiddleware. If not provided, configureStore will call getDefaultMiddleware and use the array of middleware functions it returns.
        ~ getDefaultMiddleware: Returns an array containing the default list of middleware. By default, configureStore adds some middleware to the Redux store setup automatically If you want to customize the list of middleware, you can 
          supply an array of middleware functions to configureStore.When you supply the middleware option, you are responsible for defining all the middleware you want added to the store. configureStore will not add any extra middleware 
          beyond what you listed. It's useful if you want to add some custom middleware, but also still want to have the default middleware added as well.

- createSlice(): Accepts an object of reducer functions, a slice name, and an initial state value, and automatically generates a slice reducer with corresponding action creators and action types. This function is a more powerful and 
  convenient way to define a slice of the state, including action creators and reducers. It automatically generates action types and action creators based on the reducer functions you provide.
  
- createAsyncThunk: Accepts an action type string and a function that returns a promise, and generates a thunk that dispatches pending/fulfilled/rejected action types based on that promise. The first argument is a string that's used as the 
  prefix for the generated action type. The second argument is a creator payload callback adnd this function should return a promise that contains some data or rejected primise with an error. 
  It simplifies the process of handling asynchronous actions by abstracting much of the boilerplate code required in traditional Redux. Here's a detailed look at how createAsyncThunk works behind the scenes:
    1. Thunk Action Creator: createAsyncThunk generates an action creator that returns a thunk function when dispatched.
    2. Lifecycle Actions: It automatically generates three action types for each async operation: pending, fulfilled, and rejected.
    3. Middleware: Redux Thunk middleware intercepts these thunks and executes them, allowing side effects to be handled.
    
- createSelector: This is a function that generates memoized selectors that will only recalculate results when the inputs change. It is used to create memoized selectors that can efficiently derive computed data from the RTK, ensuring that 
  the computations are only done when the state slices involved in the selector change. If the generated output selector is called multiple times, the output will only be recalculated when the extracted values have changed.
  (Memoization ensures that a selector only recalculates its result if one of its input selectors has changed, which can significantly improve performance, especially with complex state transformations).
  It takes one or more input selectors (An array of input selectors, can also be passed as separate arguments) and an output selector, which is a function that takes the results of the input selectors as separate arguments. The output 
  selector computes the derived state. The result is cached, and the output selector is only recomputed if the inputs change. And finally, it returns a memoized selector.
  The output selectors created by createSelector have several additional properties attached to them:
    > resultFunc                       The final function passed to createSelector.
    > memoizedResultFunc               The memoized version of resultFunc.
    > lastResult                       Returns the last result calculated by memoizedResultFunc.
    > dependencies                     The array of the input selectors used by createSelector to compose resultFunc.
    > recomputations                   Counts the number of times memoizedResultFunc has been recalculated.
    > resetRecomputations              Resets the count of recomputations count to 0.
    > dependencyRecomputations         Counts the number of times the input selectors (dependencies) have been recalculated. This is distinct from recomputations, which tracks the recalculations of the result function.
    > resetDependencyRecomputations    Resets the dependencyRecomputations count to 0.
    > memoize                          Function used to memoize the resultFunc.
    > argsMemoize                      Function used to memoize the arguments passed into the output selector.  
  
  By leveraging memoization, createSelector helps optimize performance, especially for complex state transformations, and makes your codebase more maintainable and readable. Here are the key reasons for using createSelector:
    > Memoization: 
      ~ Efficiency: createSelector memoizes the results of selector functions. This means that if the inputs to a selector haven't changed, it will return the cached result instead of recalculating. This avoids unnecessary recalculations and 
        renders, improving the efficiency of your application.
      ~ Performance: In large applications with complex state, recalculating derived data can be costly. Memoization ensures that computations are only performed when necessary.
    > Compatibility: 
      ~ Modularity: createSelector allows you to compose selectors from smaller selectors. This modular approach makes your code easier to read, maintain, and test.
      ~ Reuse: You can reuse selectors across different parts of your application, promoting DRY (Don't Repeat Yourself) principles.
    > Separation of Concerns:
      ~ Logic Encapsulation: Selectors encapsulate the logic of extracting and transforming state data. This keeps your component code clean and focused on presentation logic, while selectors handle data manipulation.
      ~ Centralized Logic: By defining data derivation logic in selectors, you ensure that changes to how data is derived are centralized, reducing the risk of bugs and making the logic easier to update.
    > Improved Readability and Maintainability:
      ~ Declarative Data Selection: Selectors provide a declarative way to specify what data your components need, making the data dependencies of your components explicit and easier to understand.
      ~ Ease of Testing: Selectors can be tested independently of your components, allowing you to verify that data derivation logic is correct without involving the UI layer.
  
- createEntityAdapter: Generates a set of reusable reducers and selectors to manage normalized data in the store. In summary, the createEntityAdapter function in Redux Toolkit primarily accepts an object with two optional properties: 
  selectId and sortComparer, allowing you to customize how entities are identified and sorted in your state.
  It is a function that generates a set of prebuilt reducers and selectors for performing CRUD operations on a normalized state structure containing instances of a particular type of data object. These reducer functions may be passed as case 
  reducers to createReducer and createSlice. They may also be used as "mutating" helper functions inside of createReducer and createSlice. It may be called multiple times in an application. If you are using it with plain JavaScript, you may 
  be able to reuse a single adapter definition with multiple entity types if they're similar enough (such as all having an entity.id field).
  A "entity adapter" instance. An entity adapter is a plain JS object (not a class) containing the generated reducer functions, the original provided selectId and sortComparer callbacks, a method to generate an initial "entity state" value, 
  and functions to generate a set of globalized and non-globalized memoized selector functions for this entity type.
  
    > "getInitialState": Returns a new entity state object like {ids: [], entities: {}}. It accepts an optional object as an argument. The fields in that object will be merged into the returned initial state value. For example, perhaps you 
       want your slice to also track some loading state
    > "selectAll" is a selector that allows you to replace all the entities in the state with a new set of entities, effectively resetting the collection This can be particularly useful when you need to update the state with a new list of 
      items, such as when fetching data from an API. It returns all entities in the collection as an array. It's a convenient way to access the entire list of entities stored in the normalized state.
      To use selectAll, you need to first set up your entity adapter and include it in your Redux slice and store. It s a convenient way to retrieve all entities in your state as an array. It simplifies the process of accessing and 
      displaying a list of entities in your application. By using selectAll, you can ensure that your component remains efficient and easy to read.
   > ".getSelectors()" Can create a set of memoized selectors based on the location of this entity state.
      The entity adapter will contain a getSelectors() function that returns a set of selectors that know how to read the contents of an entity state object:
      selectIds: returns the state.ids array. selectEntities: returns the state.entities lookup table. selectAll: maps over the state.ids array, and returns an array of entities in the same order. selectTotal: returns the total number of 
      entities being stored in this state.  selectById: given the state and an entity ID, returns the entity with that ID or undefined.
      Because selector functions are dependent on knowing where in the state tree this specific entity state object is kept, getSelectors() can be called in two ways:
       ~ If called without any arguments (or with undefined as the first parameter), it returns an "unglobalized" set of selector functions that assume their state argument is the actual entity state object to read from.
       ~ It may also be called with a selector function that accepts the entire Redux state tree and returns the correct entity state object.
      
- createApi():The core of RTK Query's functionality. It allows you to define a set of endpoints and describe how to retrieve data from a series of endpoints, including configuration of how to fetch and transform that data. In most cases, you 
  should use this once per app, with "one API slice per base URL" as a rule of thumb.  
    > "baseQuery": The base query used by each endpoint if no queryFn option is specified. RTK Query exports a utility called fetchBaseQuery as a lightweight wrapper around fetch for common use-cases.
      ~ args: The return value of the query function for a given endpoint. This arguments comes from the "query" method.
      ~ api: The BaseQueryApi object contains the following parameters: signal, abort, dispatch, getState, extra, endpoint, type and forced. (It's a built-in method by redux, whilst "args" are the parameters we sent manually).
      ~ extraOptions: The value of the optional extraOptions property provided for a given endpoint
    > "transformResponse" allows you to modify or process the response data before it is stored in the Redux state, and also manipulate the data returned by a query or mutation. In some cases, you may want to manipulate the data returned 
      from a query before you put it in the cache. In this instance.
    > "providesTags" facilitates efficient caching and automatic re-fetching of data. It is part of the caching mechanism that RTK Query uses to manage and invalidate cache entries. It allows you to define a list of tags that a query 
      endpoint provides. These tags can then be used to invalidate or refetch data whenever certain mutations (like creating, updating, or deleting data) occur. By specifying tags, you enable RTK Query to automatically know which queries 
      need to be re-fetched when related data changes, thus keeping your application state up-to-date with minimal manual intervention.
    > "invalidatesTags" is used by mutation endpoints. Determines which cached data should be either re-fetched or removed from the cache. Expects the same shapes as providesTags. For example, if we add, update or eliminate a new element, 
       we'll have to find a way to display it on the screen without reloading our app. So, "invalidatesTags" takes the obsolete cache values and will invalidate them so that it can extract the new values from the server (without reloading).
    > "keepUnusedDataFor" Defaults to 60 (this value is in seconds). This is how long RTK Query will keep your data cached for after the last component unsubscribes. For example, if you query an endpoint, then unmount the component, then 
      mount another component that makes the same request within the given time frame, the most recent value will be served from the cache. It may be used either inside "endpoints" or outside (together with reducerPath).
    > ".unwrap()": If you need to access the error or success payload immediately after a mutation, you can chain this command. (Remember that this must be in an async function). 
      It's used to handle the results of asynchronous thunks more conveniently, especially when dealing with fulfilled or rejected states of those thunks. The main uses are:
        ~ Access Data Directly: It returns the actual data from a fulfilled action, making it easier to work with the results without having to extract it from the action payload.
        ~ Error Handling: It throws an error if the thunk was rejected, allowing you to use try...catch blocks for error handling in a more straightforward way.
        ~ Simplified Access to Payload: When a thunk resolves successfully, the returned action contains the result in the payload property. Without .unwrap(), you need to manually extract this data. With .unwrap(), you directly get the 
          result, avoiding the need for extra property access.
        ~ Error Handling: If a thunk is rejected, the action still resolves, but you have to check the rejected status and handle errors separately. Using .unwrap(), if the thunk rejects, it throws an error, which you can catch using 
          try...catch. This makes error handling more natural and integrates well with async/await syntax.
 
- fetchBaseQuery(): A small wrapper around fetch that aims to simplify requests. Intended as the recommended baseQuery to be used in createApi for the majority of users. It's an optimal way to replace axios or "fetch",avoiding complex logic.
  This return a base query function (which is used internally by RTK Query) that handles making network requests, which is used as the base query in an RTK Query API slice, and you can use to define how API requests are made. You can also 
  customize request behavior using options like baseUrl, credentials, and prepareHeaders. It abstracts the underlying fetch logic and allows you to customize how requests are prepared, sent, and handled. When you call fetchBaseQuery with a 
  configuration object. This base query function takes an argument that includes the endpoint details and the request parameters, and it returns a promise that resolves with the response data or an error. For example, we would get the 
  following object depending on the response:  { data:{...}, meta:{...} } or { error:{...}, meta:{...} }
   > baseUrl: Sets the base URL for the API requests. For example: 'http://localhost:3500'
   > "credentials": It instructs the browser to include credentials (such as cookies, authorization headers, authentication tokens or TLS client certificates) and if they should be should be sent in the fetch request to the specified 
     baseUrl. It's particularly important when making cross-origin requests to ensure that cookies (like session tokens) are sent to the server. It's crucial for authentication scenarios where the server relies on cookies to verify the 
     client's session.
      ~ 'omit': Never send or receive cookies.
      ~ 'same-origin': Send cookies only if the request is to the same origin as the script calling the fetch.
      ~ 'include': Always send cookies, even for cross-origin requests. It's crucial becasue our application needs to maintain a user session across multiple requests, which is common in authenticated applications. The server requires 
        cookies to authenticate requests and manage sessions, especially in cross-origin requests. And we need to ensure that cookies are always sent with the request, regardless of whether the request is to the same origin or a different 
        origin.
   > prepareHeaders: Allows you to inject or modify headers on every request. You can specify (customize) headers of your API requests at the endpoint level. By accessing the current Redux state, you can add authentication tokens, setting 
     content types, or including any other necessary headers dynamically to ensure that your requests are properly configured before they are sent. This is essential for handling authenticated requests, setting content types, or including 
     any custom headers required by your API. This function provides a way to dynamically add or alter headers based on the current state or other conditions. The main porpose is that it's used to customize the headers for each request. This 
     is particularly useful for adding authentication tokens, setting content types, or including any other necessary headers dynamically.    
     It takes two arguments: the headers object and, as a convenience mechanism, the second argument allows you to use getState to access your redux store in the event you store information you'll need there such as an auth token. 
     Additionally, it provides access to extra, endpoint, type, and forced to unlock more granular conditional behaviors. You can mutate the headers argument directly, and returning it is optional.
       ~ getState(): function provides access to the current Redux state. This can be useful when you need to customize the behavior of your fetchBaseQuery or include dynamic data from the state in your requests. This function allows you to 
         access the Redux state, which can be useful for dynamically setting headers based on the current state, such as including an authentication token. It'll return two parameters: "api and "auth".

- createAction(): Generates an action creator function for the given action type string. It generates an action creator function. 
  
- createReducer(): That lets you supply a lookup table of action types to case reducer functions, rather than writing switch statements. In addition, it automatically uses the immer library to let you write simpler immutable updates with 
  normal mutative code, like state.todos[3].completed = true.


- updateQueryData: It updates an already existing cache entry. For updates of existing cache entries, use this. It requires the endpoint name and cache key arguments, so it knows which piece of cache state to update.
  We could use it when we have a list of posts cached, and we want to add a new post to this list.
    > Purpose: This function is used to update the existing cached data for a specific query.
    > Behavior: It modifies the current cached data based on the provided updater function. This means you need to have some existing data in the cache for the query; otherwise, updateQueryData has no effect.
    > Usage: You provide a query endpoint, query arguments, and an updater function that receives the current cached data and returns the new data.
  Some key differences are: I requires existing cached data to work. It uses an updater function to modify the existing data. And, when you need to modify existing cached data (e.g., adding a new item to a list).

- upsertQueryData: It creates or replaces cache entries. We could use it when we want to make sure that a specific list of posts is in the cache, regardless of whether it was there before.
    > Purpose: This function is used to update the cached data if it exists, or insert new data if it doesn't.
    > Behavior: It first checks if there is existing cached data for the query. If there is, it updates it; if not, it sets the provided data as the new cache.
    > Usage: You provide a query endpoint, query arguments, and the new data to be upserted into the cache.
  Some jey differeneces are: It does not require existing cached data and will insert new data if none exists. It directly sets or updates the cached data with the provided new data. And when we need to ensure the data is present in the 
  cache, either by inserting it if it's missing or updating it if it already exists.

- onQueryStarted(): It is a lifecycle hook that is used to run additional logic when a query or mutation is initiated. This can be particularly useful for handling optimistic updates, triggering side effects, or dispatching additional 
  actions when a query begins. The key Use Cases for onQueryStarted are:
    1. Optimistic Updates: Immediately update the UI based on the assumption that the server operation will succeed, providing a more responsive user experience.
    2. Side Effects: Perform additional operations, such as logging, analytics tracking, or dispatching other Redux actions.
    3. Error Handling: Manage errors in a centralized way by handling them when the query fails.
  When defining an endpoint in RTK Query, you can include the onQueryStarted option in the object of "builder" configuration. This function receives the argument of the query/mutation and an object with several utilities (dispatch, getState, 
  extra, requestId, queryFulfilled, etc.). Them, it's executed right after the query is started, but before it's resolved or fails, allowing you to handle a variety of use cases. 
  With onQueryStarted, optimistic updates make the app feel faster and more responsive, allows handling of side effects related to queries in a centralized manner, and provides a straightforward way to manage errors specific to a query.
  When using this hook, we have to keep into account that the 2nd parameter is the destructured `MutationLifecycleApi`. And we'll get the following parameters: dispatch, getState, queryFulfilled, requestId, extra, getCacheEntry.
  As for the first paramaeter, they'll be those values (variables) we created previously.

                                                                                               $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$  
  
- useSelector: Read data from the store. Allows you to extract data from the Redux store state for use in this component, using a selector function.
  The selector will be called with the entire Redux store state as its only argument. The selector may return any value as a result, including directly returning a value that was nested inside state, or deriving new values. The return value 
  of the selector will be used as the return value of the useSelector() hook.
  The selector will be run whenever the function component renders (unless its reference hasn't changed since a previous render of the component so that a cached result can be returned by the hook without re-running the selector). 
  useSelector() will also subscribe to the Redux store, and run your selector whenever an action is dispatched.
  When an action is dispatched, useSelector() will do a reference comparison of the previous selector result value and the current result value. If they are different, the component will be forced to re-render. If they are the same, the 
  component will not re-render. useSelector() uses strict === reference equality checks by default, not shallow equality (see the following section for more details).
  You may call useSelector() multiple times within a single function component. Each call to useSelector() creates an individual subscription to the Redux store. Because of the React update batching behavior used in React Redux v7, a 
  dispatched action that causes multiple useSelector()s in the same component to return new values should only result in a single re-render.

- useDispatch: This hook returns a reference to the dispatch function from the Redux store. It returns the store's dispatch method to let you dispatch actions (which are into "reducers" or "createAsyncThunk").                                                                                                                
  In react-redux, the useDispatch hook is used to obtain the dispatch function from the Redux store. This function allows you to dispatch actions to the Redux store, which then triggers the appropriate reducer functions to update the state.  

- <ApiProvider />: Can be used as a Provider if you do not already have a Redux store.


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$                                                                                                       


                                                                                                                   Tanstack Query
                                                                                                                   

- Definition: TanStack Query is often described as the missing data-fetching library for web applications, but in more technical terms, it makes fetching, caching, synchronizing and updating server state in your web pplications a breeze. It 
  is a powerful data-fetching library for React applications. It simplifies the management of server-state and provides tools to handle data fetching, caching, synchronization, and more. 
  Tanstack Query doesn't come with some built-in logic to send HTTP requests. Instead it comes with logic for managing those requests, for keeping track of the data and the possible errors that are yielded by these requests and so on.
  Here are some key features and concepts:
    > Data Fetching and Caching: Automatically caches data from server requests and synchronizes with the server, reducing the need for repetitive fetch requests.
    > Stale-While-Revalidate: Keeps the UI fast and responsive by serving stale data from the cache while simultaneously fetching fresh data in the background.
    > Automatic Refetching: Automatically refetches data when certain conditions are met, such as when the component mounts or the window is refocused.
    > Pagination and Infinite Query: Easily handles paginated data and infinite scrolling scenarios.
    > Query Invalidation: Allows you to invalidate specific queries, prompting a refetch to ensure the UI shows the most up-to-date data.
    > Background Sync: Automatically refetches data at specified intervals to keep the UI in sync with the server.
    > Optimistic Updates: Provides tools to perform optimistic updates, allowing the UI to be updated immediately while the server request is still in progress.
    > DevTools: Offers a set of development tools to inspect queries, mutations, and cache status, which aids in debugging.
  Some of the basic concepts are: 
    > Queries: Represent asynchronous operations (like fetching data from an API). They are defined using the useQuery hook.
    > Mutations: Represent operations that modify data (like sending data to an API). They are defined using the useMutation hook.
    > Query Client: Manages the cache and orchestrates the fetching of data. It provides methods to manipulate the cache and refetch queries.
 
- Queries: A query is a declarative dependency on an asynchronous source of data that is tied to a unique key. A query can be used with any Promise based method (including GET and POST methods) to fetch data from a server. If your method 
  modifies data on the server, we recommend using Mutations instead. To subscribe to a query in your components or custom hooks, call the useQuery hook with at least:
    > A unique key for the query. The unique key you provide is used internally for refetching, caching, and sharing your queries throughout your application.
    > A function that returns a promise that resolves the data, or throws an error
  The query result returned by useQuery contains all of the information about the query that you'll need for templating and any other usage of the data.

- Query keys: 

- <QueryClientProvider>: 

- queryClient: The QueryClient can be used to interact with a cache. It is a central piece of the library responsible for managing queries, caching, triggering refetches, invalidate queries, and manage various states related to your data 
  fetching, and interactions with the query cache. It acts as a service to the application by providing methods to fetch, cache, synchronize, and update data. 
  The queryClient is used to:
     1. Initiate Queries: Start fetching data and manage the state of the data fetching lifecycle.
     2. Cache Data: Store data in a cache to prevent unnecessary network requests and provide instant access to previously fetched data. It handles the caching of query results, making it possible to share data across components and avoid 
        unnecessary network requests.
     3. Invalidate Queries: Mark queries as stale to trigger refetching. This is useful when you perform a mutation and want to ensure that the affected queries are refetched to reflect the latest data.
     4. Update Queries: Programmatically update the data of a query.
     5. Remove Queries: Remove queries from the cache.
     6. Refetching: It can refetch queries on demand, which is useful for ensuring that your data is up-to-date.
     7. Managing Query States: It allows you to manage the states of queries (loading, error, success) globally.

- queryClient.invalidateQueries: Invalidates and refetches (automatically) single or multiple queries in the cache, matching a certain key, filter, or any other functionally accessible property/state of the query. So that allows us to tell 
  RQ that the data fetched that's connected to some queries is outdated and that it should be marked as stale and that an immediate refetch should be triggered if the Query belongs to a component that's currently visible on the screen. 
  By default, all matching queries are immediately marked as invalid and active queries are refetched in the background. 
  If you want inactive queries to refetch, use the refetchType: 'all' option. If you do not want to active queries to refetch, and simply be marked as invalid, you can use the <refetchType: 'none'> option so you can you make sure that when 
  you call "invalidateQueries", these existing queries will not automatically be triggered again immediately. Instead, they will just be invalidated and the next time they are required, they will run again. But they will not be re-triggered 
  immediately which otherwise would be the default behavior.

  It doesn't directly send a request to the backend. It marks the cached data associated with the query key as invalid. When someone tries to fetch that data again, the query client automatically triggers a request to the backend to refresh 
  the data, using the information stored in the query key to construct the request. This will then invalidate all queries that include the an specific key on "queryKey".
 
  It's important to note that we can have queryKey's with multiple keys inside but, if we'd have something like: queryClient.invalidateQueries({queryKey: ["events"]});
  it means that we'd be invalidating queryKey's like: 
     (1) queryKey: ["events"]
     (2) queryKey: ["events", {searchTerm: searchTerm}]
  The (2) will actually be invalidated because includes "events". Now, If we'd want to invalidate ONLY (1) and NOT the (2), then we should use: queryClient.invalidateQueries({queryKey: ["events"], exact: true}).
  When using "events", all event related queries should be invalidated because they're all affected by the fact that an event has been deleted, updated, etc. After that, we invalidated all event related queries and we're still on that page.
  And therefore, since we invalidated all queries. RQ went ahead and immediately triggered a refetch for the details query here.
 
- queryClient.cancelQueries: The cancelQueries method can be used to cancel outgoing queries based on their query keys or any other functionally accessible property/state of the query. This is most useful when performing optimistic updates 
  since you will likely need to cancel any outgoing query refetches so they don't clobber your optimistic update when they resolve. The queries being cancelled might involve network requests, which are inherently asynchronous. By making 
  cancelQueries return a promise, it aligns with the asynchronous nature of network operations.
  Put another way, It's used to cancel all active queries for a specific key by passing an object to cancel queries, and then setting a query key for which you want to cancel queries. With this, we're making sure that if we had any outgoing 
  queries for that key, those queries would be canceled and we would not have clashing response data from those queries and our optimistically updated query data because if those ongoing queries finished before the updating request was done, 
  we would've fetched old data again. (Keep in mind thas this returns a promise). So with that, we're canceling ongoing queries and then we'll set our own data with help of setQueryData. "cancelQueries" will not cancel the mutation it will 
  really only cancel queries triggered with use query.
  
- queryClient.getQueryData: Retrieves the cached data for a query. It is a synchronous function that can be used to get an existing query's cached data. If the query does not exist, undefined will be returned.
  Put another way, updating process on the backend could fail and in that case, we would now have outdated data in any modified data in the inputs. For example, if we delete something like the entire title (an input that's required) in a 
  card, now it's updated in the frontend, but if we reload it's actually back because our backend code blocks this, the backend code need a title because it's a required parameter in the backend. So we wanna make sure that we roll back our 
  optimistic update if it does fail on the backend. Then, to make sure that we can roll back, we also need to get the old data and store that old data somewhere so that we can roll back to that old data. And we should do that before we 
  update the data. This method gives us the currently stored query data, which we of course want to execute before we set it to some new data. Now the getQueryData simply wants the key of the query for which we want to get the data. And with 
  that we get our previous event. So the old event data. That's what we get with getQueryData. And now we wanna roll back to that event if our update mutation failed.  
  
- queryClient.setQueryData: It is a SYNCHRONOUS function that can be used to immediately update a query's cached data. If the query does not exist, it will be created. If the query is not utilized by a query hook in the default gcTime of 5 
  minutes, the query will be garbage collected. To update multiple queries at once and match query keys partially, you need to use queryClient.setQueriesData instead. 
  Directly sets the cached data for a specific query. This can be useful in scenarios where you need to update the query data locally, without making a network request. For example, after a mutation (like adding or updating an item), you 
  might want to update the corresponding query's data to reflect the changes immediately.
    
  Put another way, we can manipulate that already stored data without waiting for a response. Normally it's manipulated by React Query whenever you got a new response that's being cached. It needs two arguments. The first one is the key of 
  the query that you do want to edit. It is therefore the data that's stored for that event by React-Query which we wanna manipulate here without "waiting" for the response. The second one is the new data (updater) we wanna store under the 
  query key. React Query actually passes the "data" variable, which you passed to "mutate", as a value to the "onMutate" function. So we automatically get that data which we did submit to the backend as input in the function in onMutate. Now 
  that data we passed in from "mutate" to "onMutate" will manipulate the data behind the scenes without waiting for a response. 

- queryClient.fetchQuery: It is an ASYNCHRONOUS method that can be used to fetch and cache a query. It will either resolve with the data or throw with the error. Use the prefetchQuery method if you just want to fetch a query without needing 
  the result. If the query exists and the data is not invalidated or older than the given staleTime, then the data from the cache will be returned. Otherwise it will try to fetch the latest data.  
  It will ensure that duplicate requests for this query are not created with useQuery instances for the same query are rendered while the data is fetching. 
  The options for fetchQuery are exactly the same as those of useQuery, except the following: enabled, refetchInterval, refetchIntervalInBackground, refetchOnWindowFocus, refetchOnReconnect, refetchOnMount, notifyOnChangeProps, throwOnError, 
  select, suspense, placeholderData; which are strictly for useQuery and useInfiniteQuery.

- queryClient.refetchQueries: Refetches queries matching a certain key or filter without invalidating them. It can be used to refetch queries based on certain conditions.

- queryClient.removeQueries: Removes queries matching a certain key or filter from the cache. It's be used to remove queries from the cache based on their query keys or any other functionally accessible property/state of the query.

- useQuery: This hook is used to fetch and cache data in React apps. It's recommended to be used to only get data, NOT to send or update data even though it's possible. To send or update data, you should use useMutation().
  It simplifies the process of making asynchronous requests and managing server state, providing features like caching, background updates, and automatic refetching:
    > Data Fetching: Simplifies data fetching by managing the request and response cycle, including handling loading and error states.
    > Caching: Automatically caches the fetched data to avoid unnecessary requests and improve performance.
    > Background Refetching: Automatically refetches data in the background to keep it up-to-date.
    > Stale-While-Revalidate: Serves stale data from the cache while fetching fresh data in the background.
    > Automatic Retry: Retries failed requests automatically based on specified retry policies.
    > Data Synchronization: Keeps multiple components synchronized with the latest data without manual intervention. 
  Put another way, this hook will send an HTTP request, get us events data that we need and also give us information about loading state. So, if we are sending the request and potential errors. The {data} variable will exist on that object 
  returned by useQuery and will be a property which holds the actual response data as a value so that, which in the end is returned by our custom fetching function, that data is what will end up in this data property as a value once this 
  Query is done. But of course it will not be done instantly, instead as a first step, the request must be sent and we must wait for a response. Therefore, this object also contains an isPending property which tells us whether the request is 
  currently still on its way or if we already get a response. And if we do have a response it must not necessarily be that data here. Instead, we could also be facing an error if something went wrong on the server.
  
  Here are some of the main options in this hook:
    > queryKey: It's the query key to use for this query. The query key will be hashed into a stable hash. The query will automatically update when this key changes (as long as enabled is not set to false).
      Put another way,every query or fetch request we are sending (every get HTTP request we are sending), also should have such a queryKey which will then internally be used by react-query to cache the data that's yielded by that request so 
      that that response from that request could be used in the future if we're trying to send the same request again. And we can configure how long data should be stored and reused. This basically will make sure that data can be shown to 
      the user quicker if we already have it because it doesn't need to be refetched all the time. That's why queryKey needs such a key and the key is actually an array of values which are then internally stored by react-query such that 
      whenever we're using a similar array of fimilar values React Query sees that and is able to reuse existing data. Instead, React Query caches the response data you are getting back from your requests and it will reuse that data whenever 
      it encounters a never useQuery execution with the same Query Key. 
      For example: If we go back from other page to the an specific component, therefore, this component function executes again, React-Query will see that the queryKey has been used before and that it did already cache data for that key. 
      And it will then instantly yield that data, but at the same time, also send the queryFn request again behind the scenes to see if the updated data is available. And then it will kind of silently replace that data with the updated data 
      so that after a couple of seconds or however long it takes to fetch that data, we do have the updated data on the screen.
    > queryFn: It's used to define the function responsible for fetching data. This function is called whenever a query is executed, and its return value is used to update the query's state. Essentially, queryFn is where you specify how and 
      from where the data should be fetched. With this function we define the actual code that will be executed that will send the actual request and it'll return a promise. There are a few key concepts about this method which are: 
        ~ This is required, but only if no default query function has been defined. 
        ~ The function that the query will use to request data.
        ~ Receives a QueryFunctionContext
        ~ Must return a promise that will either resolve data or throw an error. The data cannot be undefined.
      "signal" is used to handle request cancellation (abortion). If you, for example, left the page or navigate away from a page before the request was finished. You often define a queryFn that performs the data fetching. The signal method 
      can be used within this function to check if a request has been cancelled, allowing you to abort the fetch request or any other async operation if necessary. This is particularly useful for improving performance and preventing memory 
      leaks in applications by stopping unnecessary requests when a component unmounts or when a new request is triggered before the previous one completes. You can something like: 
      queryFn: function({signal, queryKey}){};  If we extract that "signal" in the function it'll used to fetch the data, we can actually make sure that the request that is being sent is aborted if RQ thinks that it should be aborted.
    > staleTime: This controls after which time react-query will send such a behind the scenes request to get updated data if it found data in your cache. 0 means that it will use data from the cache but it will then always also send such a 
      Behind the Scenes request to get updated data. If you set staleTime to 5,000, for example, it will wait for 5,000 milliseconds before sending another request.
    > gcTime: This is the Garbage Collection Time. This controls how long the data and the cache will be kept around. And the default here are five minutes. This would mean that the cached data would only be kept for 5 minutes and 
      thereafter, it would be discarded. So thereafter, if this component needs to render again, there would be no cached data, and therefore, React Query would always need to send a new request to get some data before it can show anything.
    > gcTime: The time in milliseconds that unused/inactive cache data remains in memory. When a query's cache becomes unused or inactive, that cache data will be garbage collected after this duration. When different garbage collection times 
      are specified, the longest one will be used.
    > staleTime: The time in milliseconds after data is considered stale. This value only applies to the hook it is defined on. If set to Infinity, the data will never be considered stale. If set to a function, the function will be executed 
      with the query to compute a staleTime.
    > enabled: Set this to false to disable this query from automatically running. If we set it to false, the query (request) is disabled and won't be sent, but if we set it to true, the query will be sent. It's important to note that when a 
      query is disabled react-query treats the query as "pending" because we don'thave any data an instead we're waiting for that data to arrive, which can only happen once teh Query is enabled. Remember that you need to use the boolean 
      "isLoading" method instead of using "isPending".
      
   Here are some of the main return values in this hook:
    > isPending : A derived boolean from the status variable above, provided for convenience. The difference between is loading and is pending is that is loading will not be true if this Query is just disabled.
    
- useMutation(): It's a hook for creating, updating, or deleting data on the server. Unlike useQuery, which is primarily used for fetching data, useMutation handles actions that change data. Here are some key features and use cases:
    1. Creating, Updating, Deleting Data: Use useMutation when you need to perform operations that modify data, such as POST, PUT, PATCH, or DELETE requests.
    2. Optimistic Updates: useMutation supports optimistic updates, where the UI is updated immediately and then synchronized with the server response. This can improve the user experience by making the application feel more responsive.
    3. Error Handling: It provides mechanisms for handling errors during mutations, allowing you to show appropriate error messages to users.
    4. Side Effects: You can specify side effects to be performed before, during, and after the mutation using the onMutate, onError, onSuccess, and onSettled callbacks.
    5. Invalidate Queries: After a mutation, you might want to invalidate certain queries to ensure that the UI reflects the latest data from the server. useMutation makes it easy to specify which queries should be invalidated upon success.
  Put another way, this hook is optimized for such data changing queries, for example, simply by making sure that any requests are not sent instantly when the component renders as it by default is the case with useQuery. But that instead 
  requests are only sent when you want to send them. We don't necessarily need to do use "mutationKey" because the idea with mutations typically isn't to cache their response data because they are primarily about changing something on your 
  backend, not about getting and storing data in your fronted.

  Here are some of the main options in this hook:
    > mutationFn: Required, but only if no default mutation function has been defined. A function that performs an asynchronous task and returns a promise.
      Even though the function in mutationFn needs some input data, we don't have to wrap it with an anonymous function if we don't want to.
    > onSuccess: This function will fire when the mutation is successful and will be passed the mutation's result. If a promise is returned, it will be awaited and resolved before proceeding.
      That's to say, we might want to wait for a mutation to be finished so we could navigate (let's say, by using useNavigate) to another page. So, the onSuccess function will ONLY be executed as soon as the mutationFn succeeds. On the 
      other hand, if we were to use, like "useNavigate" withouth onSuccess, then our handler function would be executed no matter if "mutationFn" succeeds or fails.
    > onMutate: This optional function will fire before "mutationFn" is fired (without waiting for a response of a backend) and is passed the same variables "mutationFn" would receive. It's useful to perform optimistic updates to a resource 
      in hopes that the mutation succeeds, and the value returned from this function will be passed to both the onError and onSettled functions in the event of a mutation failure and can be useful for rolling back optimistic updates.
      Put another way, This function will be executed right when you call "mutate". So before that process is done and before you got back a response. And it's in onMutate where you essentially wanna update the data that's cached by React 
      Query where you wanna update the data that's stored behind the scenes. We must use queryClient because through it we can essentially interact with React Query and tell it to invalidate queries or to change the cached data. We 
      should start by getting the currently stored data so that we can then manipulate and edit it.
    > onError: This optional function will fire if the mutation encounters an error and will be passed the error. If a promise is returned, it will be awaited and resolved before proceeding.
      Put another way, it's also wants a function which will be executed if this update mutation errors, so if it fails. It receives a couple of inputs that are passed in automatically by React Query. It receives the error object with which 
      it failed, the data which was submitted to the mutationFn, and a "context" object that must come from the onMutate function.
    > onSettled: This optional function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error If a promise is returned, it will be awaited and resolved before proceeding
      Put another way, It will simply be called whenever the "mutationFn" is done, no matter if it failed or succeeded. And in that case, just to be sure that you really got the same data in your frontEnd as you have on your backend. You 
      should also, again use queryClient.invalidateQueries to invalidate our queries. And with this line and that property added in there we simply make sure that whenever this mutation finished, even though we did perform this optimistic 
      updating and we rolled back if things went wrong, we still make sure that you fetched the latest data from the backend so that if the backend did something different and the data would be out of sync between backend and front end right 
      now it gets back into sync by forcing React Query to refetch the data behind the scenes.

  Here are some of the main return values in this hook:
    > mutate: This function in the useMutation hook is used to trigger a mutation, which typically involves performing some operation that changes data on the server. This can include operations like creating, updating or deleting resources.
      By using mutate, you can easily manage asynchronous operations that alter server-side data while integrating with Tanstack Query's powerful caching and synchronization features. Here's a basic overview of how the mutate function works:
        1. Definition: You define a mutation by calling useMutation and passing it a function that performs the actual mutation (e.g., an API call).
        2. Trigger: The mutate function returned by useMutation is called whenever you want to execute the mutation. You pass the necessary variables or data required by the mutation function. 
        3. Callbacks: The mutate function can accept optional callbacks to handle the results of the mutation, including onSuccess, onError, and onSettled.
      It is extremely important because this is now a function which you can call anywhere in a component to actually send a request, because useMutation, unlike useQuery does not automatically send a request 
      when a component is rendered but instead only when you tell it to send that request, which you do with help of that mutationFn.
        ~ onSuccess: This function will fire when the mutation is successful and will be passed the mutation's result. Void function, the returned value will be ignored. If you make multiple requests, onSuccess will fire only after the 
          latest call you've made.
        ~ onError: This function will fire if the mutation encounters an error and will be passed the error. Void function, the returned value will be ignored
        ~ onSettled: This function will fire when the mutation is either successfully fetched or encounters an error and be passed either the data or error. Void function, the returned value will be ignored

- useIsFetching(): It is an optional hook that returns the number of the queries that your application is loading or fetching in the background (useful for app-wide loading indicators).
        
- Optimistic Updates (Via the cache): When you optimistically update your state before performing a mutation, there is a chance that the mutation will fail. In most of these failure cases, you can just trigger a refetch for your optimistic 
  queries to revert them to their true server state. In some circumstances though, refetching may not work correctly and the mutation error could represent some type of server issue that won't make it possible to refetch. In this event, you 
  can instead choose to roll back your update.
  To do this, useMutation's onMutate handler option allows you to return a value that will later be passed to both onError and onSettled handlers as the last argument. In most cases, it is most useful to pass a rollback function.
  If you only have one place where the optimistic result should be shown, using variables and updating the UI directly is the approach that requires less code and is generally easier to reason about. For example, you don't need to handle 
  rollbacks at all. However, if you have multiple places on the screen that would require to know about the update, manipulating the cache directly will take care of this for you automatically.
    

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$                                                                                                             
    

                                                                                                                   NextJS

- Definition: https://nextjs.org/docs

- Next.js Project Structure: This page provides an overview of the project structure of a Next.js application. It covers top-level files and folders, configuration files, and routing conventions within the app and pages directories.

- app Routing Convention: The following file conventions are used to define routes and handle metadata in the app router. These filenames are only reserved when creating them inside of the app/ folder (or any subfolder). Outside of the app/ 
  folder, these filenames are not treated in any special way.
   > page.js:  Create a new page (e.g., app/about/page.js creates a <your-domain>/about page)
   > layout.js: Create a new layout that wraps sibling and nested pages
   > not-found.js: Fallback page for "Not Found" errors (thrown by sibling or nested pages or layouts)
   > error.js: Fallback page for other errors (thrown by sibling pages or nested pages or layouts)
   > loading.js: Fallback page which is shown whilst sibling or nested pages (or layouts) are fetching data
   > route.js: Allows you to create an API route (i.e., a page which does NOT return JSX code but instea

- Hydration: It's how React attaches to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the 
  client. 
  It refers to the process of taking a server-rendered HTML markup and making it interactive by attaching event handlers or event listeners to the DOM, and converting it into a fully functional React application on the client side 
  to make the static HTML interactive. This is particularly important in scenarios involving server-side rendering (SSR), where the initial HTML is generated and sent by the server to ensure faster load times and better SEO. Here's a step-
  by-step breakdown of the hydration process:
    1. Server-Side Rendering (SSR): The React application is rendered to HTML on the server. This HTML is sent to the client as the initial response.
    2. Initial Load: The client receives the server-rendered HTML, which can be displayed immediately. This helps with performance as users can see the content faster, and it improves SEO since search engines can crawl the HTML content.
    3. Hydration: Once the HTML is loaded, React takes over and "hydrates" the application. This involves:
       > React loading the JavaScript bundle.
       > React attaching event listeners and making the HTML interactive.
       > React reconciling the initial HTML markup with the current state of the React components.
    4. Interactive Application: After hydration, the application becomes fully interactive, and React takes control of the DOM updates as usual.
  Hydration is crucial for combining the benefits of SSR and client-side rendering (CSR). It allows for faster initial page loads with server-rendered HTML while still enabling the rich, interactive user experiences provided by a client-side 
  React application.

  Put another way, It's like watering the “dry” HTML with the “water” of interactivity and event handlers. The server sends the client HTML along with a link to the JS to download. The JS gets downloaded and then “hydrates” the page taking 
  it from a plain page to one with interactivity meaning adding handlers to buttons, events to elements on the page like onClick and so forth.

- Client components: They allow you to write interactive UI that is prerendered on the server and can use client JavaScript to run in the browser. Here are a couple of benefits to doing the rendering work on the client, including:
   > Interactivity: Client Components can use state, effects, and event listeners, meaning they can provide immediate feedback to the user and update the UI.
   > Browser APIs: Client Components have access to browser APIs, like geolocation or localStorage.

  Put another way, it typically refers to components that are rendered and managed on the client-side, as opposed to being rendered on the server-side. Here's a breakdown of what client components involve:
   1. Client-Side Rendering (CSR):
      > Client components are rendered in the browser.
      > The initial HTML content is minimal and serves as a placeholder.
      > React code (JavaScript) is sent to the browser, which then takes over and dynamically generates and manages the content.
      > The rendering happens entirely on the client side after the initial page load.
   2. Advantages of Client Components:
      > Interactivity: They allow for rich interactivity and dynamic updates without requiring a full page reload.
      > Performance: For highly interactive applications, rendering on the client can reduce the load on the server and improve perceived performance for users.
      > User Experience: They enable smooth transitions and animations, contributing to a better user experience.
   3. Lifecycle Management:
      > Client components have a full React lifecycle, meaning they go through phases like mounting, updating, and unmounting.
      > This allows for complex state management and side effects handling directly in the browser.
   4. Client-Side State:
      > They can manage local state using hooks like useState, useEffect, and others.
      > State changes trigger re-renders only on the client side, which can lead to more responsive and interactive applications.
   5. Examples and Usage:
      > Client components are typical in Single Page Applications (SPAs) where most of the application logic and UI updates are handled on the client side.
      > They are commonly used in scenarios where real-time updates, such as chat applications, live dashboards, or interactive forms, are required.
   
- 'use client': To use Client Components, you can add the React "use client" directive at the top of a file, above your imports. It is used to declare a boundary between a Server and Client Component modules. This means that by defining a 
  this in a file, all other modules imported into it, including child components, are considered part of the client bundle. 
  Put another way, It is used to explicitly specify that a file or module should be treated as client-side code. This is part of Next.js's approach to server-side rendering (SSR) and client-side rendering (CSR), helping developers manage 
  where and how their code runs. Here’s what it does:
    1. Explicit Client-Side Execution: By adding 'use client' at the top of a file, you're indicating that this component should only run on the client side. This can be important for components that rely on browser-specific APIs (like 
       window or document) or need to handle client-side state and effects.
    2. Optimized Performance: Using this directive can help optimize performance by preventing certain parts of your application from being unnecessarily processed on the server. This separation allows the server to focus on rendering 
       server-specific code while offloading client-specific logic to the browser.
    3. Clarity in Code: It provides clarity in your codebase, making it clear which components are meant for client-side rendering. This can improve maintainability and reduce bugs related to rendering context (server vs. client).

- Server Actions: They're asynchronous functions that are executed on the server. They can be used in Server and Client Components to handle form submissions and data mutations. They can be defined with the React "use server" directive.
  We've got to always use "async" whenever we use 'use server'.

- Server Components: They can use the inline function level or module level "use server" directive. To inline a Server Action, add "use server" to the top of the function body. 
  server components are a feature introduced to improve the performance and flexibility of React applications. They allow you to render components on the server, sending the pre-rendered HTML to the client, which can then be hydrated with 
  client-side interactivity as needed. Here’s a more detailed breakdown. Here's a breakdown of what server components involve:
    1. Rendering on the Server: 
       > Server components are rendered on the server, meaning the HTML is generated there and sent to the client.
       > This can improve performance, as the client receives fully rendered HTML and can display it immediately, even before JavaScript loads.
    2. Improved Performance:
       > Server components can reduce the amount of JavaScript that needs to be sent to the client.
       > They allow for better use of server-side resources, reducing the load on the client and improving overall performance, especially for slower devices or connections.
    3. Data Fetching:
       > Server components can fetch data directly from the server, which can simplify the data-fetching logic.
       > They can leverage server-side APIs and databases directly without exposing sensitive data to the client.
    4. Hydration:
       > Once the HTML is rendered and sent to the client, it can be hydrated to add interactivity where needed.
       > Only the necessary JavaScript for interactive parts of the page is sent, rather than the entire application.
    5. Seamless Integration with Client Components:
       > Server components can be used alongside client components, allowing for a mix of server-rendered and client-rendered content.
       > This enables developers to choose the best rendering strategy for each part of their application. 

- 'use server': It is needed only if you’re using React Server Components or building a library compatible with them, and marks server-side functions that can be called from client-side code. This directive explicitly tells Next.js that the 
  component or function should be executed on the server side rather than the client side. This is particularly useful for optimizing performance and controlling where specific logic is executed in your application.

  To use it, you must add 'use server' at the top of an async function body to mark the function as callable by the client (Server Action), or at the top of a separate file to mark all exports of that file as Server Actions.
  When calling a Server Action on the client, it'll make a network request to the server that includes a serialized copy of any arguments passed. If the Server Action returns a value, that value will be serialized and returned to the client.
  Instead of individually marking functions with 'use server', you can add the directive to the top of a file to mark all exports within that file as Server Actions that can be used anywhere, including imported in client code.
    > It must be at the very beginning of their function or module; above any other code including imports (comments above directives are OK). They must be written with single or double quotes, not backticks.
    > It can only be used in server-side files. The resulting Server Actions can be passed to Client Components through props. See supported types for serialization.
    > To import a Server Action from client code, the directive must be used on a module level.
    > Because the underlying network calls are always asynchronous, 'use server' can only be used on async functions.
    > Always treat arguments to Server Actions as untrusted input and authorize any mutations. See security considerations.
    > Server Actions should be called in a Transition. Server Actions passed to <form action> or formAction will automatically be called in a transition.
    > Server Actions are designed for mutations that update server-side state; they are not recommended for data fetching. Accordingly, frameworks implementing Server Actions typically process one action at a time and do not have a way to 
      cache the return value.

- React Server Component Payload: refers to the data sent from the server to the client when using Server Components. React Server Components allow developers to render parts of their React applications on the server, which can improve 
  performance by reducing the amount of JavaScript that needs to be sent to the client. 
  When a React Server Component is rendered on the server, the output is serialized into a payload. This payload contains the necessary data and instructions for the client to understand and render the component on the client side. The 
  payload is then sent to the client, where it is deserialized and used to rehydrate the component in the browser.
  The benefits of using React Server Components include improved initial load times, better SEO, and the ability to use server-side data fetching more seamlessly within the component logic. The payload is a crucial part of this process as it 
  ensures that the client receives the necessary information to correctly render the server-rendered components. Here are the key aspects of React Server Component Payload:
    > Serialization: The server renders the components and serializes the output into a payload format.
    > Data Transfer: This payload is transferred from the server to the client.
    > Deserialization: On the client side, the payload is deserialized to reconstruct the component state and render it in the browser.
    > Rehydration: The client uses the payload to rehydrate the server-rendered components, making them interactive.  
    
- Client-side rendering (CSR): It means rendering all pages directly in the browser using JavaScript. When all the data fetching is done by the browser instead of a server then it is pretty obvious that the page loading will be slow leading 
  to a bad user experience. It is faster after the first load since there are no server requests to change pages, which makes it insanely fast, and provides a better UX (user experience) because it gives a native-app feel to the page.
  It always loads a blank page and the markup only gets displayed after the JS has completely loaded. Keep in mind that this is only for the first render i.e. the first time React tree gets rendered from the DOM
  
- Server-side Rendering (SSR): Server-side rendering uses servers' request-response process to render the pages using JavaScript. Data fetching is done by the servers and hence it has good user experience.  
  The reason is that in SSR the server first loads the HTML content for the user to at least have some content on the web page while the JavaScript is being loaded in the background. 
  Put another way, it is the process of rendering web pages on the client using JavaScript. In this approach, the server sends the initial HTML file, but the client then uses JavaScript to dynamically update the page as needed. This allows 
  for more interactive and responsive web pages, as the client can update specific parts of the page without needing to reload the entire page. One example of a popular CSR framework is React. With React, you can write JavaScript code that 
  updates the DOM as needed, providing a more interactive and dynamic web application. But, how SSR Works in ReactJS:
    1. Request: The client (browser) makes a request to the server for a specific URL.
    2. Server Processing: The server runs the React code to generate the HTML for the requested URL.
    3. HTML Response: The server sends the fully rendered HTML back to the client.
    4. Hydration: The client-side JavaScript bundle is downloaded and executed. React "hydrates" the server-rendered HTML, making it interactive by attaching event handlers.

  Here are some of the most important beneffits: 
   > SSR is better for slow connections because the HTML is immediately provided, whereas in CSR the user sees a blank page until the Javascript is loaded and renders the page's content.
   > It allows better SEO (Search Engine Optimization) because the content doesn't have to be loaded by Javascript like in CSR, so the search engine's web crawlers can directly parse the information.
   > SSR first load is usually faster because it doesn't need to fetch the whole website in a Javascript bundle as CSR does (some performance optimizations can be made in CSR to reduce this payload, like dynamic imports).
   > More dynamic and interactive web applications
   > Can provide a smoother and more seamless user experience
   > Can reduce the need for additional server requests

- Static site generator (SSG): SSG has similarities with SSR. The page is also generated in the server, however, the page is rendered at build time. So, instead of rendering the page on the server upon the receival of a request, the page is 
  already rendered in the server, waiting to be served to the client. I’ll discuss the advantages and disadvantages of this approach, and compare it with SSR further below.

- Difference between SSR and SSG: The difference between these two is that in SSR the server needs to render the page before sending it to the user (render at runtime), and with SSG this is not necessary, because it's done at build time. You 
  may feel like "why on earth should I use SSR then?". It's simple: most websites usually have dynamic, stateful data (e.g.: user email/logo on the navbar when a user is logged in). This means we can't pre-render at build time templates with 
  this data, so the only way to have this data with SSG would be to import it via Javascript (which would defeat SSG's core purpose).
  
- Incremental Static Regeneration (ISR): It allows you to create or update static pages after you’ve built your site. This means you can incrementally regenerate static pages without needing to rebuild the entire site.
  
- Loader in image: A loader is a function that generates the URLs for your image. It modifies the provided src, and generates multiple URLs to request the image at different sizes. These multiple URLs are used in the automatic srcset 
  generation, so that visitors to your site will be served an image that is the right size for their viewport.
  The default loader for Next.js applications uses the built-in Image Optimization API, which optimizes images from anywhere on the web, and then serves them directly from the Next.js web server. If you would like to serve your images 
  directly from a CDN or image server, you can write your own loader function with a few lines of JavaScript.

- Layout shift: refers to unexpected movement of web page elements while the page is still loading or when dynamic content is being added to the page. This can be a frustrating experience for users as it may cause them to lose track of what 
  they were reading or accidentally click on something they didn't intend to. In the context of Next.js (and web development in general), layout shifts can occur due to several reasons, such as:
    > Late Loading Images: When images don't have specified dimensions, the browser doesn't know how much space to allocate for them, leading to a shift in layout once the image loads.
    > Dynamic Content Injection: Content loaded dynamically via JavaScript can cause elements to move around.
    > Fonts: Custom fonts that are not initially loaded can cause text to re-render with a different size once the font is available.
    > Ads and Embeds: Ads or third-party embeds can load and push content around.

- blur-up placeholders: It refer to a technique used to enhance the user experience when loading images. This method involves displaying a low-resolution, blurred version of an image while the high-resolution version is being loaded. 
  Here's how it works and why it's used:
    > Low-Resolution Placeholder: A small, low-resolution version of the image is initially loaded. This image is quick to download because of its small size.
    > Blur Effect: This low-resolution image is displayed with a blur effect. The blur makes the low quality less noticeable and provides a smooth visual transition to the high-resolution image.
    > High-Resolution Image: As the high-resolution image finishes loading, it replaces the blurred placeholder.
  The benefits of using blur-up placeholders include:
  > Improved Perceived Performance: Users see something related to the final content quickly, reducing the perception of waiting.
  > Smooth Transition: The gradual transition from a blurred placeholder to a sharp image is visually pleasing and less jarring than loading the image in chunks or displaying a blank space.
  
- Largest Contentful Paint (LCP): LCP reports the render time of the largest image or text block visible in the viewport, relative to when the user first navigated to the page.
  
- Working in develoment-mode: NextJS performs pretty aggressive caching and there is one extra step it performs and goes through when preparing the app for production Because when you run this NPM run build command to prepare the app for 
  production, NextJS goes ahead and actually generates, pre-renders all the pages of your app that can be pre-generated, so basically all non-dynamic pages.
  All that data is fetched and rendered during the build process. And NextJS is doing that because by pre-rendering all pages, it of course has those pages available right from the start after being deployed. And so the very first visitor of 
  your website is able to instantly see the finished page without having to wait for anything to render. Then, NextJS caches those pre-rendered pages so that it's able to serve them to all visitors. 
  But the downside of this, is that it never re-fetches the server-actions because the code is never executes again. Instead, it just uses pre-generated pages.  
  
- Parallel routes: It allows you to simultaneously or conditionally render one or more pages within the same layout. They are useful for highly dynamic sections of an app, such as dashboards and feeds on social sites.
    > Slots: Parallel routes are created using named slots. Slots are defined with the @folder convention. And Slots are passed as props to the shared parent layout. However, slots are not route segments and do not affect the URL structure.
      It's important to keep in mind that the "children" prop is an implicit slot that does not need to be mapped to a folder. 
    > Active state and navigation: By default, Next.js keeps track of the active state (or subpage) for each slot. However, the content rendered within a slot will depend on the type of navigation:
      ~ Soft Navigation: During client-side navigation, Next.js will perform a partial render, changing the subpage within the slot, while maintaining the other slot's active subpages, even if they don't match the current URL.
      ~ Hard Navigation: After a full-page load (browser refresh), Next.js cannot determine the active state for the slots that don't match the current URL. Instead, it will render a default.js file for the unmatched slots, or 404 if 
        default.js doesn't exist. The 404 for unmatched routes helps ensure that you don't accidentally render a parallel route on a page that it was not intended for. You can instead define a default.js file to render as a fallback for 
        unmatched slots during the initial load or full-page reload.
        
  A clear benefit of parallel routes is their ability to split a single layout into various slots, making the code more manageable. This is particularly advantageous when different teams work on various sections of the page.
  However, the true benefit of parallel routes lies in their capacity for independent route handling and sub-navigation. Let’s take a closer look at these benefits.
    > Independent route handling: One of the most compelling features of parallel routes is the ability to handle each route independently. This means that each slot of your layout, such as user analytics or activity logs, can have its own  
      loading and error states. This granular control is particularly beneficial in scenarios where different sections of the page load at varying speeds or encounter unique errors. For instance, if the user analytics data takes longer to 
      load, you can display a loading spinner specifically for that section, while other parts of the dashboard remain interactive. Similarly, if there's an error in fetching revenue metrics, you can show an error message in that specific 
      section without affecting the rest of the dashboard. This level of detail in handling states not only improves the user experience but also simplifies debugging and maintenance.
    >  Sub-navigation in routes: Another significant advantage of using parallel routes is their capability to offer a seamless sub-navigation experience within each parallel route. Each slot of your dashboard can essentially function as a 
       mini-application, complete with its own navigation and state management. This is especially useful in a complex application such as our dashboard where different sections serve distinct purposes.
   https://www.builder.io/blog/nextjs-14-parallel-routes
   
- Catch-all Routes: It refer to dynamic routes that can match multiple segments of a URL path. This is useful for scenarios where you need to handle nested routes or flexible routing structures without having to define each possible path 
  explicitly. By using catch-all segments, you can simplify your routing logic and reduce the number of route files you need to maintain, while still supporting complex URL structures.  
  They can be made optional by including the parameter in double square brackets: [[...folderName]]. The difference between catch-all and optional catch-all segments is that with optional, the route without the parameter is also matched. 

- Interception Routes: Intercepting routes allows you to load a route from another part of your application within the current layout. This routing paradigm can be useful when you want to display the content of a route without the user 
  switching to a different context. For example, when clicking on a photo in a feed, you can display the photo in a modal, overlaying the feed.
  However, when navigating to the photo by clicking a shareable URL or by refreshing the page, the entire photo page should render instead of the modal. No route interception should occur.
  Intercepting routes can be defined with the (..) convention, which is similar to relative path convention ../ but for segments. You can use:
    --> (.)        to match segments on the same level
    --> (..)       to match segments one level above
    --> (..)(..)   to match segments two levels above
    --> (...)      to match segments from the root app directory

- Route Groups: In the app directory, nested folders are normally mapped to URL paths. However, you can mark a folder as a Route Group to prevent the folder from being included in the route's URL path. This allows you to organize your route 
  segments and project files into logical groups without affecting the URL path structure. A route group can be created by wrapping a folder's name in parenthesis: (folderName).
  Route groups are useful for:
    > Organizing routes into groups e.g. by site section, intent, or team.
    > Enabling nested layouts in the same route segment level:
    > Creating multiple nested layouts in the same segment, including multiple root layouts
    > Adding a layout to a subset of routes in a common segment
  Good to know:
    > The naming of route groups has no special significance other than for organization. They do not affect the URL path.
    > Routes that include a route group should not resolve to the same URL path as other routes.
    > If you use multiple root layouts without a top-level layout.js file, your home page.js file should be defined in one of the route groups, For example: app/(marketing)/page.js.
    > Navigating across multiple root layouts will cause a full page load (as opposed to a client-side navigation).
    
- Route Handlers:  

- Middlewares: 

- NextResponse: 

                                                               $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$                                                                                                       
                                                               

- <Link>: It's a React component that extends the HTML <a> element to provide prefetching and client-side navigation between routes. It is the primary way to navigate between routes in Next.js.

- <Image>: This API reference will help you understand how to use props and configuration options available for the Image Component. For features and usage, please see the Image Component page.
   > fill: A boolean that causes the image to fill the parent element, which is useful when the width and height are unknown.
     The parent element must assign position: "relative", position: "fixed", or position: "absolute" style.
     By default, the img element will automatically be assigned the position: "absolute" style.
     If no styles are applied to the image, the image will stretch to fit the container. You may prefer to set object-fit: "contain" for an image which is letterboxed to fit the container and preserve aspect ratio.
     Alternatively, object-fit: "cover" will cause the image to fill the entire container and be cropped to preserve aspect ratio. For this to look correct, the overflow: "hidden" style should be assigned to the parent element.

- notFound(): The notFound function allows you to render the not-found file within a route segment as well as inject a <meta name="robots" content="noindex" /> tag. Invoking the notFound() function throws a NEXT_NOT_FOUND error and 
  terminates rendering of the route segment in which it was thrown. Specifying a not-found file allows you to gracefully handle such errors by rendering a Not Found UI within the segment.  
  Put another way, calling this function will stop this component from executing and will show the closest not-found or error page.

- metadata: This built-in variable in Nextjs allow us to add a bunch of metadata which is then, let's say, exposed to search engine crawlers or which shows ip when you're sharing a link to a page on X or FB.

- generateMetadata(): When we wanna export dynamic metadata, we must use an async function. Dynamic metadata depends on dynamic information, such as the current route parameters, external data, or metadata in parent segments, can be set by 
  exporting a generateMetadata function that returns a Metadata object. generateMetadata should return a Metadata object containing one or more metadata fields.
    > If metadata doesn't depend on runtime information, it should be defined using the static metadata object rather than generateMetadata.
    > fetch requests are automatically memoized for the same data across generateMetadata, generateStaticParams, Layouts, Pages, and Server Components. React cache can be used if fetch is unavailable.
    > searchParams are only available in page.js segments.
    > The redirect() and notFound() Next.js methods can also be used inside generateMetadata.
  "metadata" and "generateMetadata()" are only supported in Server Components.

- redirect: It allows you to redirect the user to another URL. redirect can be used in Server Components, Route Handlers, and Server Actions. If a resource doesn't exist, you can use the notFound function instead. In Server Actions and Route 
  Handlers, redirect should be called after the try/catch block.

- revalidatePath: This function tells NextJS to revalidate the cache that belongs to a certain route path. It allows you to purge cached data on-demand for a specific path.
  It is a function used in combination with the Incremental Static Regeneration (ISR) feature. This function specifically is used to trigger a revalidation (regeneration) of a specific static page. When you call this 
  function, Next.js will regenerate the static page for the given path the next time it is requested, ensuring that it serves fresh content based on the latest data.
    > Only invalidates the cache when the included path is next visited. This means calling revalidatePath with a dynamic route segment will not immediately trigger many revalidations at once. The invalidation only happens when the path is 
      next visited.
    > Currently, revalidatePath invalidates all the routes in the client-side Router Cache. This behavior is temporary and will be updated in the future to apply only to the specific path.
    > Using revalidatePath invalidates only the specific path in the server-side Route Cache.
    > It does not return any value.
    
- usePathname: It is a Client Component hook that lets you read the current URL's pathname.

- useRouter: It allows you to programmatically change routes inside Client Components. It's recommendated to use the <Link> component for navigation unless you have a specific requirement for using useRouter.
    > router.push(href: string, { scroll: boolean }): Perform a client-side navigation to the provided route. Adds a new entry into the browser’s history stack.
    > router.replace(href: string, { scroll: boolean }): Perform a client-side navigation to the provided route without adding a new entry into the browser’s history stack.
    > router.refresh(): Refresh the current route. Making a new request to the server, re-fetching data requests, and re-rendering Server Components. The client will merge the updated React Server Component payload without losing unaffected 
      client-side React (e.g. useState) or browser state (e.g. scroll position).
    > router.prefetch(href: string): Prefetch the provided route for faster client-side transitions.
    > router.back(): Navigate back to the previous route in the browser’s history stack.
    > router.forward(): Navigate forwards to the next page in the browser’s history stack.
  The <Link> component automatically prefetch routes as they become visible in the viewport.
  refresh() could re-produce the same result if fetch requests are cached. Other dynamic functions like cookies and headers could also change the response.

- useFormState: It is a Hook that allows you to update state based on the result of a form action.
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

