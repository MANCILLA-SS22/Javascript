- HTML <script> Tag: The <script> tag is used to embed a client-side script (JavaScript). The <script> element either contains scripting statements, or it points to an external script file through the src attribute. Common uses for 
  JavaScript are image manipulation, form validation, and dynamic changes of content.

    ~ <script src="./main.js"></script>         
    ~ <script async src="./main.js"></script        Specifies that the script is downloaded in parallel to parsing the page, and executed as soon as it is available (before parsing completes) (only for external scripts)
    ~ <script defersrc="./main.js"></script>        Specifies that the script is downloaded in parallel to parsing the page, and executed after the page has finished parsing (only for external scripts)

Existen tres casos para poner el archivo script, los cuales son: 
  1) Cuando no tenemos ningun atributo en el script, lo que se hace primro es que el navegador interpretare el archivo HTML para que se descargue el script y despues de eso, seguir con la interpretacion del JS (va al final del HTML)
  2) El segundo caso reduce el tiempo de pausa de interpretacion del html, por lo que ganaermos en cargar mas cosas antes de llegar a la pausa (va al final del head)
  3) El ultimo, sirve para no bloquear la interpretacion del HTML en toda la descarga de la web. Esta se realiza igual que el segundo caso, pero con la diferencia de que la ejecucion se hace despues de la carga (va al final del head)


- Como crear variables en javascript

   > var definimos una variable con local scope, también nos permite utilizar un comportamiento llamado hoisting, sin generar ningún error. El ámbito, significa esencialmente dónde están disponibles estas variables para su uso. Las
     declaraciones var tienen un ámbito global o un ámbito de función/local. El ámbito es global cuando una variable var se declara fuera de una función. Esto significa que cualquier variable que se declare con var fuera de una función está 
     disponible para su uso en toda la pantalla. var tiene un ámbito local cuando se declara dentro de una función. Esto significa que está disponible y solo se puede acceder a ella dentro de esa función. 
     Las variables con var se pueden volver a declarar y modificar. 

   > let definimos variable con block scope, las variables declaradas de esta manera nos genera un error de referencia cuando intentamos utilizar hoisting. Un bloque es un trozo de código delimitado por {}. Un bloque vive entre llaves. Todo 
     lo que está dentro de llaves es un bloque. Así que una variable declarada en un bloque con let  solo está disponible para su uso dentro de ese bloque.

   > const definimos variables de sólo lectura (no confundir con inmutables), esto quiere decir que, cuando asignamos una variable, el nombre de esta va estar asignada a un puntero en memoria, el cual no puede ser sobreescrito o reasignado.
     Las variables declaradas con const mantienen valores constantes. Las declaraciones const similitudes con las declaraciones let. Al igual que las declaraciones let, solamente se puede acceder a las declaraciones const dentro del bloque 
     en el que fueron declaradas. const no puede modificarse ni volver a declararse Esto significa que el valor de una variable declarada con const s el mismo dentro de su ámbito. No se puede actualizar ni volver a declarar. 
     
     Las declaraciones con let y const tienen controles adicionales para las variables. Principalmente impiden que se puedan crear dos variables con el mismo nombre. Una variable let puede recibir múltiples asignaciones en el transcurso de 
     la aplicación, es decir que puede cambiar de valor varias veces. Una constante const recibe una única asignación al momento de su declaración, impidiendo que su valor se modifique luego.
     
     let te permite declarar variables limitando su alcance (scope) al bloque, declaración, o expresión donde se está usando. A diferencia de la palabra clave var la cual define una variable global o local en una función sin importar el 
     ámbito del bloque. La otra diferencia entre var y let es que este último se inicializa a un valor sólo cuando un analizador lo evalúa. Al igual que const, let no crea propiedades del objeto se declara globalmente (en el alcance más 
     alto)

- Tipos de mensajes en pantalla

    > prompt(): La sentencia prompt() mostrará un cuadro de diálogo para que el usuario ingrese un dato. Se puede proporcionar un mensaje que se colocará sobre el campo de texto. El valor que devuelve es una cadena que representa lo que el 
      usuario ingresó. En la pantalla del navegador, el usuario verá una ventana sobre la web que le solicitará un dato. Al valor que el usuario ingresa se lo conoce por el término de entrada.
                                                                          
    > console.log(): La sentencia console.log() muestra el mensaje que pasemos como parámetro a la llamada en la consola JavaScript del Navegador web
    
    > alert(): mostrará una ventana sobre la página web que estemos accediendo mostrando el mensaje que se pase como parámetro a la llamada. Al valor que mostramos al usuario como un resultado se lo conoce por el término de salida.
    
    > Existen dos formas de concatenar algo: 
      1. +;
      2. ` ${nombreDeVariable} `;

- Operadores logicos

==             Es igual                                       a == b
===            Es estrictamente igual                         a === b
!=             Es distinto                                    a != b
!==            Es estrictamente distinto                      a != b
<, <=, >, >=   Menor, menor o igual, mayor, mayor o igual     a <= b
&&             Operador and (y)                               a && b
||             Operador or (o)                                a || b
!              Operador not (no)                              !a

   > Diferencia entre "==" y "===": El operador de estricta igualdad ( === ) revisa si dos operandos son iguales y produce un resultado Booleano. A diferencia del operador de igualdad regular (==), el operador de estricta igualdad siempre
     considera que los operandos de distinto tipo de valor son diferentes y nunca similares.
     (==): Se utiliza para comparar variables o valores. Los dobles iguales no comprueban el tipo de dato variable/valor mientras se hace la comparación. Usa este operador cuando no estés seguro sobre el tipo de datos de la 
     variable/valor. ‘1’ == 1 Esto devolverá true porque los valores dobles iguales no verifican el tipo de datos. 0 == falseDevolverá true porque convierte el 0 en falso y luego lo compara. 7 == “7” // true	
     (===): También se utiliza para comparar variables/valores. Triple igual comprueba el tipo de datos de una variable durante la comparación. Usa este operador cuando estés seguro del tipo de datos de la variable/valor y desees una 
            comparación estricta. ‘1’ === 1Esto devolverá false porque los triples iguales también comparan el tipo de datos. Simplemente el 1 es de tipo string y no es un número. 0 === false Devolverá false porque son diferentes tipos de 
            datos. 7 === “7” // false
               
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Funciones

  > Declaracion de una funcion: una función, declarada como una instrucción separada, en el flujo de código principal.
       
       function sum(a, b) {
       return a + b;
       };
    
    Una Declaración de Función puede ser llamada antes de ser definida. Por ejemplo, una Declaración de Función global es visible en todo el script, sin importar dónde se esté. Esto se debe a los algoritmos internos. Cuando JavaScript se 
    prepara para ejecutar el script, primero busca Declaraciones de Funciones globales en él y crea las funciones. Podemos pensar en esto como una “etapa de inicialización”. Y después de que se procesen todas las Declaraciones de Funciones, 
    el código se ejecuta. Entonces tiene acceso a éstas funciones.
    Si la función se declara como una declaración separada en el flujo del código principal, eso se llama “Declaración de función”.
    Las Declaraciones de Funciones se procesan antes de ejecutar el bloque de código. Son visibles en todas partes del bloque.
      
  > Expresion de una funcion: una función, creada dentro de una expresión o dentro de otra construcción sintáctica. Aquí, la función es creada en el lado derecho de la “expresión de asignación” =:
    Tambien son conocidas como "funciones anónimas" que es una función que se define sin nombre y se utiliza para ser pasada como parámetro o asignada a una variable. En el caso de asignarla a una variable, pueden llamar usando el 
    identificador de la variable declarada.

      let sum = function(a, b) {
      return a + b;
      };
    
    Una Expresión de Función es creada cuando la ejecución la alcance y es utilizable desde ahí en adelante. Una vez que el flujo de ejecución pase al lado derecho de la asignación let sum = function… – aquí vamos, la función es creada y 
    puede ser usada (asignada, llamada, etc.) de ahora en adelante. Las Declaraciones de Función son diferente.
    Si la función se crea como parte de una expresión, se llama “Expresión de función”.
    Las Expresiones de Función se crean cuando el flujo de ejecución las alcanza.
      
  > Funciones flecha Son como funciones anónimas de sintaxis simplificada. No usan la palabra function pero usa => (flecha) entre los parámetros y el bloque. Las funciones flecha permiten definir de manera compacta una función convencional. 
    Si la función tiene solamente una sentencia que devuelve un valor, el uso de funciones flecha nos permite eliminar las llaves y la palabra return. Incluso utilizando parámetros también podemos ver mucho más reducido el código.
    No tiene sus propios enlaces a this o super y no se debe usar como métodos. No tiene argumentos o palabras clave new.target. No apta para los métodos call, apply y bind, que generalmente se basan en establecer un ámbito o alcance No se 
    puede utilizar como constructor. No se puede utilizar yield dentro de su cuerpo.
    
      + const calcAge3 = birthYear => 2037 - birthYear;               //Esta funcion flecha se escribe de esta manera cuando solamente requiere de una linea de codigo. Aqui no se necesita de un retur.
      + const yearUntilRetirement1 = (birthYear, firstName) => {}     //Esta funcion se utiliza con llaves cuando se requiere de mas de 1 linea. Se requiere de un return si es que queremos regresar un valor.
      + const yearUntilRetirement1 = function(birthYear, firstName){} //Esta funcion es la misma que la de arriba pero de la forma tradicional. Se requiere de un return si es que queremos regresar un valor.    
      + toString = () => {return this.nombre +" ($"+ this.precio.toFixed(2) +")"}; //Asi se define una funcion flecha dentro de una clase
      + toString(){return this.nombre +" ($"+ this.precio.toFixed(2) +")"} //Asi se define una funcion tradicional dentro de una clase
      
      
  > Anonymus function: 
  
  > Funciones (function): Lo primero que tenemos que saber es que en Javascript, las funciones son objetos de primera clase. Como tales, podemos trabajar con ellos de la misma forma que trabajamos con otros objetos, como asignarlos a 
    variables y pasarlos como argumentos a otras funciones. Esto es importante, porque esta última técnica nos permite ampliar la funcionalidad de nuestras aplicaciones. JavaScript ejecuta el código secuencialmente en orden descendente. Sin 
    embargo, hay algunos casos en los que el código se ejecuta (o debe ejecutarse) después de que ocurra otra cosa y también de forma no secuencial. Esto se llama programación asíncrona.
         
        
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- POO en JAVASCRIPT

  > Objetos: os objetos son estructuras que podemos definir para agrupar valores bajo un mismo criterio. Podemos decir que un objeto es una colección de datos relacionados como una entidad. Se componen de un listado de pares clave-valor, es 
    decir, contienen propiedades y valores agrupados. La utilidad de los objetos deviene de su composición por varios valores y operaciones comunes (funciones) para todos los elementos de este tipo y sus propiedades". 
    + Anatomía de un objeto: Un objeto literal se define directamente entre llaves {} Los valores que almacenan se listan separados por coma, bajo la forma propiedad: valor
    + Obteniendo valores del objeto: Para obtener el valor de una propiedad en un objeto utilizamos la notación punto (.): El nombre de la variable del objeto, seguido de punto y el nombre de la propiedad.
      ~ Otra forma de obtener el valor de una propiedad en un objeto utilizamos la notación corchetes ([]): El nombre de la variable del objeto, seguido de corchetes y dentro de ellos un string del nombre de la propiedad.
    + Asignar valores a las propiedades: Es posible usar las dos formas( corchetes y paréntesis) para acceder a las propiedades y asignar nuevos valores a los datos almacenados en las propiedades del objeto
    
        
  > Formas de llamar a un objeto y diferencia entre Dot Notation y Bracket Notation Property Accessor:
        console.log(producto.nombre);
        console.log(producto['nombre']);     
        
    Cuando usamos corchetes podemos acceder a propiedades que tienen un espacio o carácter no permitido en la notación de punto (por ejemplo, miMascota.numero de amigos no es válido, pero miMascota["numero de amigos"] sí lo es). Si queremos 
    minificar nuestro código, la notación del punto no es válida, debemos usar la notación de corchetes. La notación con corchetes, a diferencia de la notación con punto, puede usarse con variables. Si usas una variable con notación con 
    corchetes, la variable debe hacer referencia a una string.
    Dot Notation only allows static keys while Bracket Notation accepts dynamic keys. Static key here means that the key is typed directly, while Dynamic key here means that the key is evaluated from an expression.
    
(1) const obj = {                                  (2) const obj = {                                    (3) const obj = {
    name: "deeecode",                                  name: "deeecode",                                    name: "deeecode",
    age: 80,                                           age: 80,                                             age: 80,
    language: "javascript",                            language: "javascript",                              language: "javascript",
    }                                                  }                                                    }
    
    const myKey = "language";                          const myKey = "language";                            const myKey = "language";
    const target = obj.myKey;                          const target = obj[myKey];                           const target = obj["myKey"];
    console.log(target);                               console.log(target);                                 console.log(target);
    //undefined                                        // javascript                                        // undefined
    
(4) const obj = {                                  (5) const obj = {                                        
    name: "deeecode",                                  name: "deeecode",                                    
    age: 80,                                           age: 80,                                             
    language: "javascript",                            language: "javascript",                              
    }                                                  }                   
                                     
    const target = obj.name;                           const target = obj["name"];                            
    console.log(target);                               console.log(target);                             
    //deecode                                          // javascript                                       
    
    
    
    1. Here, I assigned the value "language" to a myKey variable. What I would expect here is that when I use the dot notation, like obj.myKey, "myKey", should be replaced with "language". So it would read as obj.language and that would 
       return "javascript". But that's not what happens. Instead, the result is undefined. The reason for this is that Dot Notation only accepts static keys. So when you do obj.myKey, JavaScript looks for the property with the key myKey in 
       obj. But that property does not exist, so we get undefined. The Bracket Notation, on the other hand, allows dynamic keys. Because this notation accepts expressions, you can use any expression that evaluates to a value.
    2. The expression we passed to the square brackets is myKey which is a variable. This expression evaluates to "language" which is the value of the variable. Using this value, the square brackets can get the value of the property, which 
       is "javascript".
    3. This is because the string expression "myKey" evaluates to the value "myKey" which serves as the key for accessing the property. Since there's no myKey key on obj, the returned value is undefined.

  > Como crear un metodo en un objeto: En este caso se hace de la misma manera que cuando creamos una funcion global, con la diferencia de que en lugar de usar (=) usamos (:) solo cuando esta dentro del objeto
  
       calcAge: function (birthYeah){   //Metodo
           return variable;
       }
        
  > Llamar a la funcion de una clase: Para hacer esto, sabemos primero que la funcion se encuentra dentro de una clase, por lo que ahora, fuera de ella cuando queramos llamarla, tendremos que poner le nommbre de una variable, le colocamos un 
    punto y despues escribimos el nombre de la funcion. La sintaxis es la siguiente       -->       NombreDeVariable.nombreDeFuncion()

  > clases: Las clases de JavaScript, introducidas en ES6, proveen una sintaxis mucho más clara y simple para crear objetos personalizados. Son una equivalencia al empleo de función constructora y permite definir distintos tipos de métodos.
  
  > Clases y Métodos: En la declaración de clase, la función constructora es reemplazada por el método constructor. Los métodos en las clases no referencian a propiedades, se declaran dentro del bloque sin la palabra function. Los metodos se 
    declaran fuera del metodo constructor pero dentro de la clase. Estos metodos no llevan el "=" ni tampoco los "=>", a diferencia de la funcion constructora de objetos.

  > new: El operador new permite a los desarrolladores crear una instancia de un tipo de objeto definido por el usuario o de uno de los tipos de objeto integrados que tiene un función constructora.
    La palabra clave new hace lo siguiente:

      1) It creates a new object. The type of this object is simply object.
      2) It sets this new object's internal, inaccessible, [[prototype]] (i.e. __proto__) property to be the constructor function's external, accessible, prototype object (every function object automatically has a prototype property).
      3) It makes the this variable point to the newly created object.
      4) It executes the constructor function, using the newly created object whenever this is mentioned.
      5) It returns the newly created object, unless the constructor function returns a non-null object reference. In this case, that object reference is returned instead.    
      6) Para definir un tipo de objeto, crea una función para el tipo de objeto que especifique su nombre y propiedades. Un objeto puede tener una propiedad que en sí misma es otro objeto.
    
   Note: constructor function refers to the function after the new keyword, as in
        
        new ConstructorFunction(arg1, arg2)

   Once this is done, if an undefined property of the new object is requested, the script will check the object's [[prototype]] object for the property instead. This is how you can get something similar to traditional class inheritance in JS
   The most difficult part about this is point number 2. Every object (including functions) has this internal property called [[prototype]]. It can only be set at object creation time, either with new, with Object.create, or based on the 
   literal (functions default to Function.prototype, numbers to Number.prototype, etc.). It can only be read with Object.getPrototypeOf(someObject). There is no other way to get or set this value.
   Functions, in addition to the hidden [[prototype]] property, also have a property called prototype, and it is this that you can access, and modify, to provide inherited properties and methods for the objects you make. Here is an example:
   
   ObjMaker = function() { this.a = 'first'; };
   // `ObjMaker` is just a function, there's nothing special about it that makes it a constructor.
   
   ObjMaker.prototype.b = 'second';
   // like all functions, ObjMaker has an accessible `prototype` property that we can alter. I just added a property called 'b' to it. Like all objects, ObjMaker also has an inaccessible `[[prototype]]` property that we can't do anything
   
   with obj1 = new ObjMaker(); 
   //3 things just happened. A new, empty object was created called `obj1`.  At first `obj1` was just `{}`. The `[[prototype]]` property of `obj1` was then set to the currentobject value of the `ObjMaker.prototype` (if `ObjMaker.prototype` 
   is laterassigned a new object value, `obj1`'s `[[prototype]]` will not change, but youcan alter the properties of `ObjMaker.prototype` to add to both the`prototype` and `[[prototype]]`). The `ObjMaker` function was executed, with`obj1` in 
   place of `this`... so `obj1.a` was set to 'first'.
   
   obj1.a;
   // returns 'first'
   
   obj1.b; 
   //`obj1` doesn't have a property called 'b', so JavaScript checks  its `[[prototype]]`. Its `[[prototype]]` is the same as `ObjMaker.prototype` `ObjMaker.prototype` has a property called 'b' with value 'second' returns 'second'

  > this: Se refiere al elemento actual en el que se está escribiendo el código. Cuando se emplea un función constructora para crear un objeto (con la palabra clave new), this está enlazado al nuevo objeto instanciado. This es muy útil para 
      asegurar que se emplean las propiedades del objeto actual. El puntero this es una variable predefinida para todas las funciones u operadores miembro de una clase. Este puntero contiene la dirección del objeto concreto de la clase al 
      que se está aplicando la función o el operador miembro. Se puede decir que *this es un alias del objeto correspondiente. Conviene tener en cuenta que cuando una función miembro se aplica a un objeto de su clase (su argumento 
      implícito), accede directamente a las variables miembro (sin utilizar el operador punto o flecha), pero no tiene forma de referirse al objeto como tal, pues no le ha sido pasado explícitamente como argumento. Ojo, que hace referencia 
      al objeto instanciado y no a la clase.
      
      this en JavaScript es una palabra clave muy utilizada dentro de funciones y clases, pues tiene un valor flexible. This hace referencia al objeto en cuestión. Es decir, si estamos creando cualquier función, la palabra clave this se 
      usará para representar o llamar al objeto que dicha función está modificando. ES5 introdujo el método bind() para establecer el valor de la función this independientemente de como es llamada.
      this es una referencia que se crea cuando una función es invocada, no declarada. El valor de esa referencia depende al 100% del lugar en la que esa invocación se realice, llamado call-site. Ese lugar de llamada es la invocación en sí a 
      la función. Es decir, el momento justo en que es llamada (no declarada, no referenciada) esa función. El valor de this puede cambiar dependiendo del contexto en el que se invoca una función o método. Hay cuatro contextos principales en 
      los que se puede utilizar this en JavaScript:
        + En una función global: En una función que se ejecuta en el contexto global, this hace referencia al objeto window, que es el objeto global en JavaScript.
      
        + En una función dentro de un objeto: Cuando se invoca una función dentro de un objeto, this hace referencia al objeto que contiene la función.
       
        + El método call() o apply(): Son métodos que permiten invocar una función con un objeto diferente de this. Esto significa que se puede cambiar el contexto de this mediante la llamada a una de estas do funciones.
          ~ call ();  Permite que una función/método que pertenece a un objeto, ser asignada y llamada para un objeto diferente. Provee un nuevo valor de this a la función/método. Podemos escribir un método ona vez y heredarlo a otro objeto, 
                      sin tener que reescribir el método en el nuevo objeto. No recive una lista de argumentos despues del this.
                      You can write a method that can be used on different objects. It takes arguments separately. It can be used to invoke (call) a method with an owner object as an argument (parameter). 
                      With call(), an object can use a method belonging to another object. 
          ~ apply (); Con apply , puede escribirse un método una vez y heredarlo a otro objeto, sin necesidad de reescribir el método para adecuarlo al nuevo objeto. apply es muy similar a call() , excepto por el tipo de argumentos que 
                      soporta. Puede utilizarse un arreglo de parámetros en lugar de un conjunto de pares nombre-valor. You can write a method that can be used on different objects. It takes arguments as an array.
          ~ bind (); El método bind() crea una nueva función, que cuando es llamada, asigna a su operador this el valor entregado, con una secuencia de argumentos dados precediendo a cualquiera entregados cuando la función es llamada. El 
                     valor de this es ignorado cuando la función es llamada con el operador new.
                     Allows us to manually set "this" for any function call. With the bind() method, an object can borrow a method from another object. Bind doesn't immediately call the function. Instead, it returns a new function where the 
                     "this" is bound. So it's set to whatever value we pass into bind. Sometimes the bind() method has to be used to prevent losing this.
        
        + Con el operador new: Cuando se invoca una función con el operador new, this hace referencia al objeto que se está creando.
        
      In JavaScript, the this keyword refers to an object. Which object depends on how this is being invoked (used or called). The this keyword refers to different objects depending on how it is used:
         ~ In an object method, this refers to the object.
         ~ Alone, this refers to the global object.
         ~ In a function, this refers to the global object.
         ~ In a function, in strict mode, this is undefined.
         ~ In an event, this refers to the element that received the event.
         ~ Methods like call(), apply(), and bind() can refer this to any object.  
      
      En resumen, this se utiliza para hacer referencia al objeto en el contexto actual, y su valor puede cambiar dependiendo del contexto en el que se invoca una función o método. Conocer cómo funciona this en diferentes contextos es 
      esencial para escribir código efectivo en JavaScript.       https://www.freecodecamp.org/espanol/news/la-guia-completa-sobre-this-en-javascript/   https://www.programiz.com/javascript/this

  > super: The super keyword is used to call the constructor of its parent class to access the parent's properties and methods, to access properties on an object literal or class's [[Prototype]], or invoke a superclass's constructor.
    When we extend a parent class, we call "super" in order to call the parent constructor.

  > extends: The extends keyword is used to create a child class of another class (parent). The child class inherits all the methods from another class. Inheritance is useful for code reusability: reuse properties and methods of an existing 
    class when you create a new class. 
    Note: From the example above; The super() method refers to the parent class. By calling the super() method in the constructor method, we call the parent's constructor method and gets access to the parent's properties and methods.
    Extends is used to denote the parent class that the child class will inherit its methods from, and super is used to reference the parent classes constructor method.
      
  > Constructor: El constructor de un objeto es una función que usamos para crear un nuevo objeto cada vez que sea necesario. Con función constructora podemos inicializar las propiedades del objeto al momento de ser instanciado con new.
    El constructor ejecutara asi mismo las funciones y/o variables que esten dentro de el UNICAMENTE cuando se cree una nueva instancia del objeto.
    
    Constructor is a "special" prop returns a reference to the Object constructor function that created the instance object.
    A constructor is a special function (prop) that creates and initializes an object instance of a class. It returns a reference to the Object constructor function that created the instance object. In JavaScript, a constructor gets called 
    when an object is created using the new keyword. The purpose of a constructor is to create a new object and set values for any existing object properties.
      
        function Persona(nombre, edad, calle) {
           this.nombre = nombre;
           this.edad = edad;
           this.calle = calle;
        }
        const persona1 = new Persona("Homero", 39, "Av. Siempreviva 742 ");
        const persona2 = new Persona("Marge", 36, "Av. Siempreviva 742 ");
        
     Estos metodos constructores NO son asincronos.

  > static: La palabra static en Javascript se utiliza para definir propiedades y métodos que pertenecen a toda la clase en lugar de pertenecer a instancias individuales de esa clase. Estas propiedades y métodos son accesibles directamente
    desde la clase misma, sin necesidad de crear objetos. Es importante destacar que las propiedades estáticas no están disponibles en las instancias de la clase. Los métodos y propiedades estáticos pueden resultar muy útiles en muchas 
    situaciones. Algunos de los beneficios y casos de uso comunes son:
      ~ Acceso global: las propiedades estáticas permiten acceder a valores comunes desde cualquier parte del código, sin la necesidad de crear instancias de la clase.
      ~ Utilidades compartidas: los métodos estáticos se utilizan a menudo para implementar utilidades compartidas que no dependen del estado de una instancia en particular.
      ~ Rendimiento mejorado: al utilizar métodos estáticos en lugar de métodos de instancia, puedes reducir el uso de memoria y mejorar el rendimiento de tu aplicación.
    Sin embargo, es importante tener en cuenta que el uso excesivo de propiedades y métodos estáticos puede derivar en un código menos flexible y acoplado.

    The static keyword defines a static method or field for a class, or a static initialization block. Static properties cannot be directly accessed on instances of the class. Instead, they're accessed on the class itself. 
    Static methods are often utility functions, such as functions to create or clone objects, whereas static properties are useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.
    Usually, static methods are used to implement functions that belong to the class as a whole, but not to any particular object of it. (You cannot call a static method on an object, only on an object class).
  
  > Metodo: Los métodos de los objetos también son técnicamente funciones, sólo que se limitan a poder ser ejecutados solo desde el mismo objeto. Se requiere un objeto y puede no retornar un valor.
        function Persona(nombre, edad, calle) {
           this.nombre = nombre; this.edad = edad; this.calle = calle;
        } 
        
  > Encaptulation: It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together code and the data it manipulates. In Encapsulation, the variables or data of a class are hidden from any 
    other class and can be accessed only through any member function of their class in which they are declared. As in encapsulation, the data in a class is hidden from other classes, so it is also known as data-hiding.    
    
    This principle states that all important information is contained inside an object and only select information is exposed. The implementation and state of each object are privately held inside a defined class. Other objects do not have 
    access to this class or the authority to make changes. They are only able to call a list of public functions or methods. This characteristic of data hiding provides greater program security and avoids unintended data corruption.
    
     ~ Public: These members of the class and available to everyone that can access the (owner) class instance.
     
     ~ Private: These members are only accessible within the class that instantiated the object.
     
     ~ Protected: This keyword allows a little more access than private members but a lot less than the public. A protected member is accessible within the class (similar to private) and any object that inherits from it. A protected value is 
       shared across all layers of the prototype chain. It is not accessible by anybody else.
   
  > Array de objetos: Los array pueden usarse para almacenar objetos personalizados. Podemos asignar objetos literales o previamente instanciados en la declaración del array o agregar nuevos objetos usando el método push y el constructor.
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Conceptos y definiciones de POO
    
  > Objeto: los objetos tienen propiedas especificas, tales como posicion, tamano, color, etc., que definen su estado. Los objetos tambien tienen ciertos comportamientos que los hacen diferentes 
    de otros objetos. Cada objeto forsozamente debe tener tanto atributos como metodos, y se debe crear siempre despues de las clases. Los objetos poseen: 
    + Atributos (Caracteristica, datos o miembros de la clase): Son las descripciones que posee dicho objeto. Es decir, su informacion. Tambien, es una característica de un objeto, que ayuda a definir su estructura y permite diferenciarlo de
      otros objetos. Se define con un identificador y un tipo, el cual indica los valores que puede almacenar. El conjunto de valores de los campos  definen el estado del objeto. En codigo, son unicamente los nombres de algo, como por 
      ejemplo, el color, altura, velocidad, peso o precio, y son de tipo int, string, float, etc.
    + Metodos (acciones, funcionalidades o parametros): Son las acciones o tareas que estas pueden desempenar, como lo son sumar(), encender(), abrir() etc. Se debe crear en un archivo deferente al que se uso para crear una clase. Tambien, 
      son los comportamientos o conductas de un objeto y permite identificar la forma en que actúa respecto a su entorno o respecto a otros objetos. Además, representa una operación o función que un objeto realiza. El conjunto de los métodos 
      de un objeto determinan el comportamiento general del objeto. En codigo, los metodos son las funciones que ejecutaran una accion, por ejemplo: los metodos seters, geters, fucniones void, o aquellas que retornan un valor

  > Clase: Es un conjunto de objetos que comparten una estructura y comporamiento comunes. Una clase se debe crear antes que los objetos. Y debe tener el metodo constructor. Se debe crear en un archivo deferente al que se uso para crear una 
    metodo. Se puede crear una clase usando la palabra clave struct, la diferencia es que con struct los miembros se hacen públicos por defecto, mientras que con class se hacen privados por defecto. 
    + De instancia: Son aquellas que se declaran dentro de una clase y que no existen hasta que se hace una instancia de esa clase (se crea un objeto) nombre [ = ];
    + De referencia: Son aquellas que hace referencia a otra clase. Esto se puede definir mejor diciendo que es una variable del tipo de otra clase, y cuando se haga la instancia tendremos: un objeto dentro de otro objeto. nombre [ = ];
    + De clase: Estas variables se declaran antemoniendo la palabra static a su declaración, y a diferencia de las variables de instancia, éstas no necesitan que se haga una instancia (que se cree un objeto), existen desde que se crea la 
      clase.static nombre [ = ];
      
    + clases abstractas: A veces es posible que nos interese que una clase sea abstracta. Con esto lo que queremos decir es que a veces no tiene finalidad alguna crear un objeto de una clase que no tenga funcionalidad pero represente un 
     concepto de clase útil. Se utilizan solo como clase base, y a traves de ella van a derivar 1 o varias clases para tener clases hijas. NO SE PUEDEN ISNTANCIAR (CREAR) OBJETOS EN ESA CLASE, sino que solamente serviran para crear clases 
     derivadas. Sirven para proporcionar una clase base apropiada a partir de la cual heredan otras clases. Es decir, se le pueden sacar clase derivadas y no se pueden crear objetos.     
    + Clases derivadas: Es la relacion que existe entre dos clases, en la que una clase denominada hija o clase derivada se crea a partir de otra ya existente, denominada clase padre o clase base. Para crear una clase derivada, tras el 
      nombre de la clase, se pondrán dos puntos y el nombre de la clase que se quiere tomar como base. Además, deberemos especificar el tipo de herencia, lo cual se especificará delante del nombre de la clase base. Las clases derivadas 
      pueden acceder a todo lo de la clase principal.
    + Clase padre: La clase de la cual otra deriva directamente. Decimos que la clase A es padre de la clase B si B deriva directamente de A (está conectada directamente en el árbol de jerarquías de las clases).
    + Clase hija: Clase que es derivada directamente de otra. Decimos que la clase B es hija de la clase A si B deriva directamente de A (está conectada directamente en el árbol de jerarquías de las clases).
    + Clase base: Llamamos así a la clase que se halla al inicio del árbol de las jerarquías de clases. La raíz de ese árbol es la clase base o superclase.
    + Clases compuestas: Es aquella clase que entre sus atributos tiene objetos que derivan de otras clases. Es decir, no tienen ningun parentezco ninguna ni otra.
    + Clase contenedora: Al hecho de crear nuevas clases utilizando otras clases como componentes, se le llama composición, y a la clase compuesta se le llama contenedora. Es decir, si alguno de los datos de una clase es a su vez una 
      instancia de otra clase (o de sí misma) a la clase se le llama contenedoras y a las clases albergadas contenidas.
      
  > Encapsulación (visualizacion de los miembros de la clase): Este concepto permite tener un control de acceso selectivo tanto a los miembros como a los métodos, de tal forma que desde fuera del objeto sólo se pueda acceder a los métodos e 
    identificadores que permita el creador del objeto.
    
    This principle states that all important information is contained inside an object and only select information is exposed. The implementation and state of each object are privately held inside a defined class. Other objects do not have 
    access to this class or the authority to make changes. They are only able to call a list of public functions or methods. This characteristic of data hiding provides greater program security and avoids unintended data corruption.

  
  > Abstracción: Son las características especificas de un objeto, aquellas que lo distinguen de los demás tipos de objetos y que logran definir límites conceptuales respecto a quien está haciendo dicha abstracción del objeto. Una 
    abstracción se enfoca en la visión externa de un objeto, separa el comportamiento específico de un objeto, a esta división que realiza se le conoce como la barrera de abstracción, la cuál se consigue aplicando el principio de mínimo 
    compromiso. La abstracción es el proceso por el cual se descarta toda aquella información que no resulta relevante en un contexto en particular enfatizando algunos de los detalles o propiedades de los objetos. Depende principalmente del 
    interés del observador, permitiendo abstracciones muy diferentes de la misma realidad, debido a esto algunos la clasifican un tanto subjetiva. Y consiste en captar las características y funcionalidades que un objeto desempeña y estos son
    representados en clases por medio de atributos y métodos de dicha clase.
    
      + principio de mínimo compromiso: Se refiere al proceso por el cuál la interfaz de un objeto muestra su comportamientoespecífico y nada más, absolutamente nada más.
      + Interfaz: Una interfaz de objeto permite crear código con el cuál se específica que métodos serán implementados por una clase sin necesidad de definir que harán estos métodos, dichos métodos deben ser públicos.
      + Abstracción de Entidades: Es un objeto que representa un modelo útil de una entidad que se desea.
      + Abstracción de Acciones: Un objeto que representa un conjunto de operaciones y todas ellas desempeñan funciones del mismo tipo.
      + Abstracción de Máquinas virtuales: Un objeto que agrupa operaciones, todas ellas virtuales, utilizadas por algún nivel superior de control u operaciones.
      + Abstracción de coincidencia: Un objeto que almacena un conjunto de operaciones que no tienen relación entre sí.
          
    Abstraction is a process which displays only the information needed and hides the unnecessary information. We can say that the main purpose of abstraction is data hiding. Abstraction means selecting data from a large number of data to 
    show the information needed, which helps in reducing programming complexity and efforts.  
    There are also abstract classes and abstract methods. An abstract class is a type of class that declares one or more abstract methods. An abstract method is a method that has a method definition but not implementation. Once we have 
    modelled our object using data abstraction, the same sets of data can also be used in different applications—abstract classes, generic types of behaviours and object-oriented programming hierarchy. Abstract methods are used when two or 
    more subclasses do the same task in different ways and through different implementations. An abstract class can have both methods, i.e., abstract methods and regular methods.

  
  > Herencia: Permite la reutilización y la extensión del código. Permite diseñar nuevas clases a partir de otras ya existentes, pudiéndose además extender sus métodos (cambiar su semántica en la  clase que hereda). Aqui, una clase base o 
    hija, se crea a partir de otra ya existente, las llamadas clase padre o base. La herencia define relaciones jerárquicas entre clases, de forma que atributos y métodos comunes puedan ser reutilizados. Las clases principales extienden 
    atributos y comportamientos a las clases secundarias. A través de la definición en una clase de los atributos y comportamientos básicos, se pueden crear clases secundarias, ampliando así la funcionalidad de la clase principal y 
    agregando atributos y comportamientos adicionales.La herencia es una de las características fundamentales de la Programación Orientada a Objetos por la que, tomando como base una clase ya existente, es posible derivar una nueva, que 
    heredará todos sus miembros, teniendo posibilidad de sobrecargarlos, crear unos nuevos o utilizarlos. La idea básica por tanto, es reutilizar las clases existentes y extender o modificar su semántica.
    
      + Herencia publica: En general, significa que una clase derivada tiene acceso a los elementos protegidos y publicos de su clase base. Los elementos publicos se heredan como elementos publicos; los elementos protegidos permanecen 
        protegidos; los elementos privados no se heredan.
      + Herencia privada: Los miembros publicos y protegidos de la clase base se vuelven miembros privados de la clase derivada. En efecto, los usuarios de la clase derivada no tiene acceso a las facilidades proportcionadas por la clase 
        base. Los miembros privados de la clase base son inaccesibles a las funciones miembro de la clase derivada. 
      + Herencia protegida: Todos los miembros públicos de la clase base adquieren el nivel de acceso protegido en las clases derivadas, mientras que los miembros 
        protegidos conservan su nivel de acceso. Lo anterior indica que una clase derivada puede luego heredar a otra clase los miembros protegidos que heredó de su clase base.
      + Herencia multiple: Es un tipo de herencia en la que una clase hereda los miembros de mas de una clase base. Es decir, existen multiples clases base (padres) para la clase derivada (hija). Esta herencia plantea diferentes problemas 
        tales como la ambiguedad por el uso de nombres identicos en diferentes clases base. Los problemas que se pueden presentar cuando se danan clases con herencia multiple son:
        ~ colisiones de nombres: de diferentes clases base (dos o mas clases base tiene el mismo identificador para algun elemento de su interfaz. Se resuelve con el operador de ambito ::)
        ~ Herencia repetida de una misma clase base (una clase puede heredar indirectamente dos copias de una clase base. Se resuelve con el operador de resolucion de ambito ::)
        
     
     Inheritance is a method in which one object acquires/inherits another object’s properties, and inheritance also supports hierarchical classification. The idea behind this is that we can create new classes built on existing classes, 
     i.e., when you inherit from an existing class, we can reuse methods and fields of the parent class. Inheritance represents the parent-child relationship. For example, a whale is a part of the classification of marine animals, which is 
     part of class mammal, which is under that class of animal. We use hierarchical classification, i.e., top-down classification. If we want to describe a more specific class of animals such as mammals, they would have more specific 
     attributes such as teeth; cold-blooded, warm-blooded, etc. This comes under the subclass of animals whereas animals come under the superclass. The subclass is a class which inherits properties of the superclass. This is also called a 
     derived class. A superclass is a base class or parental class from which a subclass inherits properties.
  
  > Polimorfismo: Es la posibilidad de definir clases diferentes que tienen métodos o atributos denominados de forma idéntica, pero que se comportan de manera distinta al mismo mensaje. Esto hace referencia al hecho de que varios objetos de 
    diferentes clases, pero con una base común, se pueden usar de manera indistinta, sin tener que saber de qué clase exacta son para poder hacerlo. 
    
    *El concepto de polimorfismo se puede aplicar tanto a funciones como a tipos de datos. Así nacen los conceptos de funciones polimórficas y tipos polimórficos. Las primeras son aquellas funciones que pueden evaluarse o ser aplicadas a 
     diferentes tipos de datos de forma indistinta; los tipos polimórficos, por su parte, son aquellos tipos de datos que contienen al menos un elemento cuyo tipo no está especificado. Permite tratar de forma genérica objetos de distintas 
    clases, ahorrando así código y proporcionando simplicidad. Por tanto, trata de forma genérica objetos de distintos tipos derivados de una misma clase  de objetos.    
     
    *Es la capacidad que tienen ciertos lenguajes para hacer que, al enviar el mismo mensaje (o, en otras palabras, invocar al mismo método) desde distintos objetos, cada uno de esos objetos pueda 
     responder a ese mensaje (o a esa invocación) de forma distinta.     
    
    *Tambien es la capacidad que tienen los objetos de comportarse de múltiples formas sin olvidar que para esto se  requiere de la herencia, en si consiste en hacer referencia a objetos de una clase que puedan tomar comportamientos de 
     objetos descendientes de esta. Con el polimorfismo usamos la generalización olvidando los detalles concretos de los objetos para centrarnos en un punto en común mediante una clase padre.    
    
    *El concepto de polimorfismo se puede aplicar tanto a funciones como a tipos de datos. Así nacen los conceptos de funciones polimórficas y tipos polimórficos. Las primeras son aquellas funciones que pueden evaluarse o ser aplicadas a 
     diferentes tipos de datos de forma indistinta; los tipos polimórficos, por su parte, son aquellos tipos de datos que contienen al menos un elemento cuyo tipo no está especificado.
    
    *En lenguajes basados en clases y con un sistema de tipos de datos fuerte (independientemente de si la verificación se realiza en tiempo de compilación o de ejecución), es posible que el único modo de poder utilizar objetos de manera 
     polimórfica sea que compartan una raíz común, es decir, una jerarquía de clases, ya que esto proporciona la compatibilidad de tipos de datos necesaria para que sea posible utilizar una misma variable de referencia (que podrá apuntar a 
     objetos de diversas subclases de dicha jerarquía) para enviar el mismo mensaje (o un grupo de mensajes) al grupo de objetos que se tratan de manera polimórfica.
    
    El polimorfismo adquiere su maxima potencia cuando se utiliza en union de herencia. Para poder utilizar polimorfismo en C++ se debe tomar en cuenta lo siguiente:
     + Crear una jerarquia de clases con las operaciones importantes definidas por las funciones miembro declaradas como virtuales en la clase base
     + Las implementaciones especificas de las funciones virtuales se deben hacer en las clases derivadas. Cada clase derivada puede tener su propia version de las funciones.
     
    Polymorphism refers to many forms, or it is a process that performs a single action in different ways. It occurs when we have many classes related to each other by inheritance. Polymorphism is of two different types, i.e., compile-time 
    polymorphism and runtime polymorphism. One of the examples of Compile time polymorphism is that when we overload a static method in java. Run time polymorphism also called a dynamic method dispatch is a method in which a call to an 
    overridden method is resolved at run time rather than compile time. In this method, the overridden method is always called through the reference variable. By using method overloading and method overriding, we can perform polymorphism. 
    Generally, the concept of polymorphism is often expressed as one interface, and multiple methods. This reduces complexity by allowing the same interface to be used as a general class of action. 
     
  > this: Se refiere al elemento actual en el que se está escribiendo el código. Cuando se emplea un función constructora para crear un objeto (con la palabra clave new), this está enlazado al nuevo objeto instanciado. This es muy útil para 
    asegurar que se emplean las propiedades del objeto actual. El puntero this es una variable predefinida para todas las funciones u operadores miembro de una clase. Este puntero contiene la dirección del objeto concreto de la clase al 
    que se está aplicando la función o el operador miembro. Se puede decir que *this es un alias del objeto correspondiente. Conviene tener en cuenta que cuando una función miembro se aplica a un objeto de su clase (su argumento 
    implícito), accede directamente a las variables miembro (sin utilizar el operador punto o flecha), pero no tiene forma de referirse al objeto como tal, pues no le ha sido pasado explícitamente como argumento. Ojo, que hace referencia 
    al objeto instanciado y no a la clase.
    
    This hace referencia al objeto actual de la clase, es decir, a una instancia concreta de la clase y nos sirve para usar los métodos y atributos de esa clase desde alguno de sus métodos, para llamar a otro de sus constructores o 
    simplemente para pasarle el objeto completo a algún otro método u objeto.
      
         
  > instanciacion: La instanciacion no es mas que la creacion de un objeto a partir de una clase o a la derivacion de un objeto con otro, la cual se crea desde un inicio. Un objeto creado de una clase tambien de denomina instancia de una
    clase. De esta forma, todos los objetos son instancias de algún otro, menos la clase Object que es la madre de todas. Cuando usted declara una clase, no se reserva memoria para la clase hasta que usted crea un objeto de la clase.
    Por ejemplo, si creamos una clase para un objeto que es para un carro, el cual tenga "velocidad", "potencia" y "color", entonces a partir de eso, podemos definir nuestro primer objeto, digamos "Carro_1", el cual posee las 3 
    caracteristicas mencionadas arriba. Ahora, si queremos instanciar, entonces debemos crear otro objeto, digamos "Carro_2", debera tener exactamente los mismas 3 caracteristicas definidas en un principio. Esto es la instanciacion.
  
  > Diferencia entre crear objetos e instanciar objetos: De una clase abstracta no se pueden instanciar objetos pero si crear. A continuacion un ejemplo de la sintaxis de cada uno:
   + NombreDeVariable *NombreDeVariable[2]; - Creamos un objeto
   + NombreDeVariable[0] = new OtraVariable(7,4); - instanciamos 2 objeto a partir del arreglo de objetos creado. Dicha instanciacion se crea a partir de la clase derivada, no de la clase base.
     Instancia significa simplemente crear una referencia(copia) o a la derivacion de un objeto con otro, mientras que crear un objeto (o instanciar una clase) significa cuando le damos vida a una clase que acabamos de crear utilizando la 
     palabra reservada "new", y que la ubicación de la memoria está asociada con el objeto (es una entidad en tiempo de ejecución de la clase) mediante el uso del nuevo operador. En palabras simples, Instancia se refiere a la copia del 
     objeto en un momento particular, mientras que objeto se refiere a la dirección de memoria de la clase.

  > CONSTRUCTOR: El constructor de un objeto es una función que usamos para crear un nuevo objeto cada vez que sea necesario. Con función constructora podemos inicializar las propiedades del objeto al momento de ser instanciado con new.
     Es un método que se ejecuta automáticamente cuando se define o se crea un objeto, y su función es inicializar el objeto y prepararlo para realizar las operaciones necesarias. Debe tener el mismo nombre de la clase y servira 
     para inicializar los atributos que la misma clase tenga. Las funciones constructoras son una técnica para crear objetos personalizados con valores predeterminados y métodos específicos. Al contrario de la notación de objetos literales,
     las funciones constructoras deben ser llamadas con la palabra clave "new" para asegurar que se está creando un nuevo objeto. Con las funciones constructoras podemos crear varios objetos a partir de una sola función y cada uno podrá 
     tener valores diferentes, algo que no es posible con los objetos literales. Además, las funciones constructoras nos permiten crear métodos específicos para los objetos creados a partir de ellas, lo que nos permite tener un mejor control 
     sobre el comportamiento de los objetos.

  > Miembros static de una clase: Miembros estaticos (static): Un dato declarado estático en una clase es un dato de una sola instancia, se crea al definir la clase y sólo existirá uno, independientemente del número de objetos que se creen. 
    Esto es bueno cuando todos los objetos van a compartir una misma variable. Los atributos de tipo "static" NO SE PUEDEN INICIALIZAR DENTRO DE LA CLASE, SINO FUERA DE ELLA. Los atributos pertenecen a la clase y no a los objetos, similar a 
    las  variables locales y globales. Es decir, se crea un atributo estatico y todos los objetos tendran el mismo valor para el mismo atributo. En el caso de los metodos de tipo "static" sucede exactamente lo mismo. Los miembros YA NO le
    pertenecen a los objetos instanciados, sino a la clase. Los métodos estáticos son llamados sin instanciar su clase. Son habitualmente utilizados para crear funciones para una aplicación.
    Permite el acceso a métodos y variables de clase sin la necesidad de instanciar un objeto de dicha clase, permitiendo la inicialización de forma cómoda y durante la carga de clase.
    
    El hecho de no poder disponer de "this" dentro de un método estático es debido a que el método no se invoca con relación a ningún objeto. Como has visto, usamos el nombre de la clase para invocarlo y no un objeto instanciado. Como sabes, 
    "this" tiene una referencia al objeto donde se lanzó un mensaje (el objeto sobre el que se invocó un método). Como no existe tal objeto de invocación, no existe un objeto en "this". En principio podríamos pensar que "this" entonces 
    valdrá "undefined", pero lo que hay en realidad es el código de la propia clase.
    
    The static keyword defines a static method or field for a class, or a static initialization block. Static properties cannot be directly accessed on instances of the class. Instead, they're accessed on the class itself.
    Static methods are often utility functions, such as functions to create or clone objects, whereas static properties are useful for caches, fixed-configuration, or any other data you don't need to be replicated across instances.


  > Modificadores de acceso
    + Publico (public: ) = Un miembro público es accesible en cualquier lugar en el que exista un objeto de la clase. El modificador public ofrece la máxima visibilidad, una variable, método o clase con modificador public será visible desde 
      cualquier clase, aunque estén en paquetes distintos 
    + Protegidos (protected:) = Un miembro protegido sólo es accesible desde las clases que se hereden de la clase que lo contiene. Es visible para las clases que se encuentren en el mismo paquete y para cualquier subclase de esta aunque 
      este en otro paquete. Este modificador es utilizado normalmente para Herencias, así que lo estudiaremos más a fondo cuando lleguemos a las Herencias.
    + Privados (private: ) = Es miembro privado sólo es accesible por los métodos de la clase a la que pertenece. Cuando un método o atributo (variable) es declarada como private, su uso         
      queda restringido al interior de la misma clase, no siendo visible para el resto. Una clase no puede ser Private, sólo atributos y métodos.

     Puede ser accedido desde:	                     public       protected       default      private 
     Su misma clase                                   SI	          SI	         SI            SI
     Cualquier clase que esté en el mismo paquete     SI	          SI             SI            NO
     Cualquier subclase que esté en otro paquete      SI             SI	         NO            NO
     Cualquier otra clase que esté en otro paquete    SI	          NO             NO            NO

   > DESTRUCTOR: [ ~NombreDeVariable(); ] es un método que se ejecuta automáticamente cuando un objeto queda fuera del ámbito en el que se creó, y su función es destruir el objeto, liberando cualquier asignación dinámica de memoria que se 
     haga. Sirve para liberar memoria utilizada al crear los objetos cuando el programa finaliza. Esto cuando nosotros creamos nuestras clases e instanciamos muchos objetos de esas mismas clases y se utiliza mucha memoria en la computadora. 
     El no utilizar el constructor por defecto, puede no afectar nuestro programa, pero cuando manejamos con programas muy largos, es de suma recomendacion utilizarlos. Es un método de una clase cuyo fin es eliminar un objeto de una clase.
     El objeto puede tener o no definidos explícitamente el constructor y el destructor, o tener varios constructores.
     
   > Constructor por defecto: Es aquel en el cual no existe ningun tipo de paramateros y no contiene nada dentro. Tambien inicia todos los atributos con ceros binarios (o bien, no se inicializan). SE UTILIZA PARA LA CREACION DE OBJETOS 
     DINAMICOS. Cuando trabajamos con este tipo de objetos dinamicos, es correcto el usar o no ningun constructor, puesto que, no inicializamos los atributos directamente cuando se crea el arreglo en la funcion principal.
     
   > Destructor por defecto: Al igual que existe un constructor por defecto, existe un destructor por defecto. Este método, elimina de memoria el objeto al terminarse el ámbito de la variable que lo contiene, recuperando para su uso la 
     porción de memoria que el objeto ocupaba.
     
     
     
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
     
- JavaScript Object Reference
    > constructor	Returns the function that created an object's prototype
    > keys()	     Returns an Array Iterator object with the keys of an object
    > prototype	     Let you to add properties and methods to JavaScript objects
    > toString()	     Converts an object to a string and returns the result
    > valueOf()	     Returns the primitive value of an object
 
  
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Global Methods and Properties
    > decodeURI()	        Decodes a URI
    > decodeURIComponent()    Decodes a URI component
    > encodeURI()	        Encodes a URI
    > encodeURIComponent()	   Encodes a URI component
    > eval()	              Evaluates a string and executes it as if it was script code
    > Infinity	              A numeric value that represents positive/negative infinity
    > isFinite()	              Determines whether a value is a finite, legal number
    > isNaN()	              Determines whether a value is an illegal number
    > NaN	                  "Not-a-Number" value
    > Number()	             Converts an object or string' value to a number
    > parseFloat()	        Parses a string and returns a floating point number
    > parseInt()	             Parses a string and returns an integer
    > String()	             Converts an object's value to a string
    > undefined	             Indicates that a variable has not been assigned a value
    
    > constructor	   Returns the function that created an object's prototype
    > keys()	        Returns an Array Iterator object with the keys of an object
    > prototype	        Let you to add properties and methods to JavaScript objects
    > toString()         Converts an object to a string and returns the result
    > valueOf()	         Returns the primitive value of an object
    > values()           Object.values() returns an array whose elements are values of enumerable string-keyed properties found directly upon object. This is the same as iterating with a for...in loop, except that a for...in loop enumerates 
                         properties in the prototype chain as well. The order of the array returned by Object.values() is the same as that provided by a for...in loop.
                         
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    

- Métodos del objeto CONSOLE

    > assert()	            Writes an error message to the console if a assertion is false
    > clear()	            Clears the console
    > count()	            Logs the number of times that this particular call to count() has been called
    > error()	            Outputs an error message to the console
    > group()	            Creates a new inline group in the console. This indents following console messages by an additional level, until console.groupEnd() is called
    > groupCollapsed()	 Creates a new inline group in the console. However, the new group is created collapsed. The user will need to use the disclosure button to expand it
    > groupEnd()	            Exits the current inline group in the console
    > info()	            Outputs an informational message to the console
    > log()	            Outputs a message to the console
    > table()	            Displays tabular data as a table
    > time()	            Starts a timer (can track how long an operation takes)
    > timeEnd()	            Stops a timer that was previously started by console.time()
    > trace()	            Outputs a stack trace to the console
    > warn()	            Outputs a warning message to the console
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    

- JavaScript Statement Identifiers

    > break	                    Exits a switch or a loop
    > class	                    Declares a class
    > const	                    Declares a variable with a constant value
    > continue	                    Breaks one iteration (in the loop) if a specified condition occurs, and continues with the next iteration in the loop
    > debugger	                    Stops the execution of JavaScript, and calls (if available) the debugging function
    > do while	              Executes a block of statements and repeats the block while a condition is true
    > for	                         Loops through a block of code a number of times
    > for in	                    Loops through the properties of an object
    > for of	                    Loops through the values of an iterable object
    > function	                    Declares a function
    > if else - else if	    Marks a block of statements to be executed depending on a condition
    > let	                          Declares a variable
    > return	                    Stops the execution of a function and returns a value from that function
    > switch	                    Marks a block of statements to be executed depending on different cases
    > throw	                    Throws (generates) an error
    > try ... catch ... finally	    Marks the block of statements to be executed when an error occurs in a try block, and implements error handling
    > var	                          Declares a variable
    > while	                    Marks a block of statements to be executed while a condition is true    
     
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    

- Math Object Methods and Properties: Javascript provee el objeto Math que funciona como un contenedor de herramientas y métodos para realizar operaciones matemáticas

    > abs(x)	      Returns the absolute value of x
    > acos(x)	      Returns the arccosine of x, in radians
    > acosh(x)	      Returns the hyperbolic arccosine of x
    > asin(x)	      Returns the arcsine of x, in radians
    > asinh(x)	      Returns the hyperbolic arcsine of x
    > atan(x)	      Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians
    > atan2(y, x)	  Returns the arctangent of the quotient of its arguments
    > atanh(x)	      Returns the hyperbolic arctangent of x
    > cbrt(x)	      Returns the cubic root of x
    > ceil(x)	      Returns x, rounded upwards to the nearest integer
    > clz32(x)	      Returns the number of leading zeros in a 32-bit binary representation of x
    > cos(x)	      Returns the cosine of x (x is in radians)
    > cosh(x)	      Returns the hyperbolic cosine of x
    > E	              Returns Euler's number (approx. 2.718)
    > exp(x)	      Returns the value of Ex
    > expm1(x)	      Returns the value of Ex minus 1
    > floor(x)	      Returns x, rounded downwards to the nearest integer
    > fround(x)	      Returns the nearest (32-bit single precision) float representation of a number
    > LN2	          Returns the natural logarithm of 2 (approx. 0.693)
    > LN10	          Returns the natural logarithm of 10 (approx. 2.302)
    > log(x)	      Returns the natural logarithmof x
    > log10(x)	      Returns the base-10 logarithm of x
    > LOG10E	      Returns the base-10 logarithm of E (approx. 0.434)
    > log1p(x)	      Returns the natural logarithm of 1 + x
    > log2(x)	      Returns the base-2 logarithm of x
    > LOG2E	          Returns the base-2 logarithm of E (approx. 1.442)
    > max(x1,x2,..)	  Returns the number with the highest value
    > min(x1,x2,..)	  Returns the number with the lowest value
    > PI	            Returns PI (approx. 3.14)
    > pow(x, y)	      Returns the value of x to the power of y
    > random()	      Returns a random number between 0 and 1. Para generar números aleatorios dentro de un rango deseado, distinto de 0-1, podemos multiplicar su resultado por el rango esperado. A la vez podemos sumar el límite inferior.
                      console.log( Math.random() * 10 )// números entre 0 y 10
                      console.log( Math.random() * 50) // números entre 0 y 50
                      console.log( Math.random() * 30 + 20 ) // números entre 20 y 50
    > round(x)	      Rounds x to the nearest integer
    > sign(x)	      Returns the sign of a number (checks whether it is positive, negative or zero)
    > sin(x)	      Returns the sine of x (x is in radians)
    > sinh(x)	      Returns the hyperbolic sine of x
    > sqrt(x)	      Returns the square root of x
    > SQRT1_2	      Returns the square root of 1/2 (approx. 0.707)
    > SQRT2	          Returns the square root of 2 (approx. 1.414)
    > tan(x)	      Returns the tangent of an angle
    > tanh(x)	      Returns the hyperbolic tangent of a number
    > trunc(x)	      Returns the integer part of a number (x)


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- Number                      
  
constructor	       Returns the function that created JavaScript's Number prototype
EPSILON	            Returns the difference between 1 and the smallest number greater than 1
isFinite()	            Checks whether a value is a finite number
isInteger()	       Checks whether a value is an integer
isNaN()	            Checks whether a value is Number.NaN
isSafeInteger()	      Checks whether a value is a safe integer
MAX_SAFE_INTEGER      Returns the maximum safe integer in JavaScript.
MIN_SAFE_INTEGER      Returns the minimum safe integer in JavaScript
MAX_VALUE	           Returns the largest number possible in JavaScript
MIN_VALUE	           Returns the smallest number possible in JavaScript
NaN	                Represents a "Not-a-Number" value
NEGATIVE_INFINITY	Represents negative infinity (returned on overflow)
POSITIVE_INFINITY	Represents infinity (returned on overflow)
parseFloat()	     Parses a string an returns a number
parseInt()	          Parses a string an returns a whole number
prototype	          Allows you to add properties and methods to an object
toExponential(x)	    Converts a number into an exponential notation
toFixed(x)	          Formats a number with x numbers of digits after the decimal point
toLocaleString()	     Converts a number into a string, based on the locale settings
toPrecision(x)	    Formats a number to x length
toString()	         Converts a number to a string
valueOf()	         Returns the primitive value of a number

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

- Built-in JavaScript Constructors

new String()    // Create a new String object
new Number()    // Create a new Number object
new Boolean()   // Create a new Boolean object
new Object()    // Create a new Object object
new Array()     // Create a new Array object
new RegExp()    // Create a new RegExp object
new Function()  // Create a new Function object
new Date()      // Create a new Date object


As you can see above, JavaScript has object versions of the primitive data types String, Number, and Boolean. But there is no reason to create complex objects. Primitive values are much faster:
Use string literals "" instead of new String().
Use number literals 50 instead of new Number().
Use boolean literals true / false instead of new Boolean().
Use object literals {} instead of new Object().
Use array literals [] instead of new Array().
Use pattern literals /()/ instead of new RegExp().
Use function expressions () {} instead of new Function().
        
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        
    
- JavaScript date reference
    > constructor	             Returns the function that created the Date object's prototype
    > getDate()	               Returns the day of the month (from 1-31)
    > getDay()	               Returns the day of the week (from 0-6)
    > getFullYear()	           Returns the year
    > getHours()	             Returns the hour (from 0-23)
    > getMilliseconds()	       Returns the milliseconds (from 0-999)
    > getMinutes()	           Returns the minutes (from 0-59)
    > getMonth()	             Returns the month (from 0-11)
    > getSeconds()	           Returns the seconds (from 0-59)
    > getTime()	               Returns the number of milliseconds since midnight Jan 1 1970, and a specified date
    > getTimezoneOffset()	     Returns the time difference between UTC time and local time, in minutes
    > getUTCDate()	           Returns the day of the month, according to universal time (from 1-31)
    > getUTCDay()	             Returns the day of the week, according to universal time (from 0-6)
    > getUTCFullYear()	       Returns the year, according to universal time
    > getUTCHours()	           Returns the hour, according to universal time (from 0-23)
    > getUTCMilliseconds()	   Returns the milliseconds, according to universal time (from 0-999)
    > getUTCMinutes()	         Returns the minutes, according to universal time (from 0-59)
    > getUTCMonth()	           Returns the month, according to universal time (from 0-11)
    > getUTCSeconds()	         Returns the seconds, according to universal time (from 0-59)
    > now()	                   Returns the number of milliseconds since midnight Jan 1, 1970
    > parse()	                 Parses a date string and returns the number of milliseconds since January 1, 1970
    > prototype	               Allows you to add properties and methods to an object
    > setDate()	               Sets the day of the month of a date object
    > setFullYear()	           Sets the year of a date object
    > setHours()	             Sets the hour of a date object
    > setMilliseconds()	       Sets the milliseconds of a date object
    > setMinutes()	           Set the minutes of a date object
    > setMonth()	             Sets the month of a date object
    > setSeconds()	           Sets the seconds of a date object
    > setTime()	               Sets a date to a specified number of milliseconds after/before January 1, 1970
    > setUTCDate()	           Sets the day of the month of a date object, according to universal time
    > setUTCFullYear()	       Sets the year of a date object, according to universal time
    > setUTCHours()	           Sets the hour of a date object, according to universal time
    > setUTCMilliseconds()	   Sets the milliseconds of a date object, according to universal time
    > setUTCMinutes()	         Set the minutes of a date object, according to universal time
    > setUTCMonth()	           Sets the month of a date object, according to universal time
    > setUTCSeconds()	         Set the seconds of a date object, according to universal time
    > toDateString()	         Converts the date portion of a Date object into a readable string
    > toISOString()	           Returns the date as a string, using the ISO standard
    > toJSON()	               Returns the date as a string, formatted as a JSON date
    > toLocaleDateString()	   Returns the date portion of a Date object as a string, using locale conventions
    > toLocaleTimeString()	   Returns the time portion of a Date object as a string, using locale conventions
    > toLocaleString()	       Converts a Date object to a string, using locale conventions
    > toString()	             Converts a Date object to a string
    > toTimeString()	         Converts the time portion of a Date object to a string
    > toUTCString()	           Converts a Date object to a string, according to universal time
    > UTC()	                   Returns the number of milliseconds in a date since midnight of January 1, 1970, according to UTC time
    > valueOf()	               Returns the primitive value of a Date object
   
    
- La clase Date: Seguramente en algún momento necesitemos manipular fechas dentro de los datos que manejamos. Para esto, JavaScript posee la clase Date diseñada para representar fechas.
  ~ Date: Instanciar un objeto Date nos genera la fecha y tiempo actual
    console.log(new Date())  //Fri Dec 17 2021 11:35:08 GMT-0300 (hora estándar de Argentina
    
  ~ Constructor: El constructor de la clase Date nos permite crear objetos date confechas diferentes. Puede recibir parámetros en el orden año, mes, día, hora, minutos, segundos, milisegundos (todos tipo number).
    La convención con la que trabaja Javascript para construir fechas cuenta los meses a partir del 0 (0 = enero, 11 = diciembre) y los días a partir del 1:
    
    console.log(new Date(2020, 1, 15)) // Sat Feb 15 2020 00:00:00 GMT-0300 (hora estándar de Argentina)
    const casiNavidad = new Date(2021, 11, 25, 23, 59, 59)
    console.log(casiNavidad) // Sat Dec 25 2021 23:59:59 GMT-0300 (hora estándar de Argentina)

    El constructor de la clase Date nos permite crear objetos date con fechas diferentes. Puede recibir parámetros en el orden año, mes, día, hora, minutos, segundos, milisegundos (todos tipo number).
    
    const casiNavidad = new Date("December 25, 2021 23:59:59" )
    console.log(casiNavidad) // Sat Dec 25 2021 23:59:59 GMT-0300 (hora estándar de Argentina)
    
  ~ Obtener un valor singular de la fecha: Instanciado un objeto Date, podemos aplicar distintos métodos que nos evuelven determinados valores de la misma. 
    + getMonth(); nos retornará el number que representa el mes (entre 0 y 11)
    + getFullYear(); nos devolverá el number que representa el año creado
    + getDay(); nos retornará el number que representa el día creado (1 = lunes, 7 = domingo)
      
      const hoy = new Date("December 17, 2021")
      console.log(hoy.toDateString()) // Fri Dec 17 2021
      console.log(hoy.toLocaleString()) // 17/12/2021 00:00:00
      console.log(hoy.toLocaleDateString()) // 17/12/2021
      console.log(hoy.toTimeString()) // 00:00:00 GMT-0300 (hora estándar de Argentina)
      
  ~ Diferencias entre fechas: ;os resultados de las diferencias entre fechas se generan en milisegundos. Si quisiera calcular la diferencia de días entre dos fechas habría que generar cálculos adicionales sobre esta diferencia en 
    milisegundos. Por suerte, existen librerías que solucionan estos problemas de forma eficiente y rápida, pero las trabajaremos en clases posteriores.
    
    const navidad = new Date("December 25, 2021")
    const hoy = new Date("December 17, 2021")
    console.log( navidad - hoy ) // 691200000
    const milisegundosPorDia = 86400000
    console.log( (navidad - hoy ) / milisegundosPorDia) // 8
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
-  Sets and Map Methods

   ~ Map: Un Map es una colección de pares tipo clave-valor (como un objeto) donde la clave puede ser de cualquier tipo, siendo la principal diferencia con un objeto, además de ciertos métodos que permiten una simple manipulación proveyendo 
      una forma eficiente de buscar y obtener datos. Además un Map permite que se agreguen datos de forma dinámica. Además Map incluye algunos métodos que te permiten iterar sobre los elementos del mismo, estos métodos retornan un tipo 
      MapIterator que permite el uso de loops for-of o forEach directamente.
      
      Si bien son estructuras de datos similares hay ciertos momentos para decantar por uno u otro usa Map cuando:
        1) Necesitas almacenar información en donde las claves no son siempre strings.
        2) Necesitas una estructura de datos donde los objetos pueden ser ordenados.
        3) Necesitas realizar búsquedas eficientes en los datos (sin utilizar librerías externas).
        
   ~ Set: Es una colección de elementos unicos (no se pueden repetir los mismos valores) que pueden ser de cualquier tipo, muy similar a un arreglo. Esta también es una colección ordenada de elementos. Puedes crear e inicializar un Set 
      usando new. Al igual que Map, Set también tiene métodos que te permiten agregar o eliminar elementos del mismo. Set también cuenta con el método Set.has(element) para saber si un element está o no en un set, además del método 
      Set.delete(element) para eliminar un elemento. 
      Para iterar sobre un Set puedes usar el método Set.values() que retorna un SetIterator, sobre este iterador puedes utilizar forEach o for-of. Set y Array son similarres y puedes convertirlos entre sí utilizando el operador spread.
   
   

    > new Set()	       Creates a new Set
    > add()	           Adds a new element to the Set
    > delete()	       Removes an element from a Set
    > has()	           Returns true if a value exists
    > clear()	       Removes all elements from a Set
    > forEach()	       Invokes a callback for each element
    > values()	       Returns an Iterator with all the values in a Set
    > keys()	       Same as values()
    > entries()	       Returns an Iterator with the [value,value] pairs from a Set

    > new Map()	      Creates a new Map object
    > set()	       Sets the value for a key in a Map
    > get()	       Gets the value for a key in a Map
    > clear()	       Removes all the elements from a Map
    > delete()	       Removes a Map element specified by a key
    > has()	       Returns true if a key exists in a Map
    > forEach()	       Invokes a callback for each key/value pair in a Map
    > entries()	      Returns an iterator object with the [key, value] pairs in a Map
    > fromEntries()    method creates an object from iterable key / value pairs.
    > keys()	       Returns an iterator object with the keys in a Map
    > values()	      Returns an iterator object of the values in a Map
    
    
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
    
-  Métodos de los STRINGS

    > charAt()	            Returns the character at a specified index (position)
    > charCodeAt()	        Returns the Unicode of the character at a specified index
    > concat()	            Returns two or more joined strings
    > constructor	        Returns the string's constructor function
    > endsWith()	            Returns if a string ends with a specified value
    > fromCharCode()	      Returns Unicode values as characters
    > includes()	           Returns true or false if a string contains a specified value
    > indexOf()	            Returns the index (position) of the first occurrence of a value in a string
    > lastIndexOf()	        Returns the index (position) of the last occurrence of a value in a string
    > length	            Returns the length of a string
    > localeCompare()	       Compares two strings in the current locale
    > match()	            Searches a string for a value, or a regular expression, and returns the matches
    > padStart()            method pads a string from the start. And also pads a string with another string (multiple times) until it reaches a given length.
    > padEnd()              method pads a string at the end. And also pads a string with another string (multiple times) until it reaches a given length.
    > prototype	            Allows you to add properties and methods to an object
    > repeat()	            Returns a new string with a number of copies of a string
    > replace()	            Searches a string for a value, or a regular expression, and returns a string where the values are replaced
    > replaceAll()	       Searches a string for a pattern and returns a new string where all matches are replaced
    > search()	            Searches a string for a value, or regular expression, and returns the index (position) of the match
    > slice()	            Extracts a part of a string and returns a new string
    > split()	            Splits a string into an array of substrings. Returns the new array, does not change the original string. If (" ") is used as separator, the string is split between words.
    > startsWith()	        Checks whether a string begins with specified characters
    > substr()	            Extracts a number of characters from a string, from a start index (position)
    > substring()	        Extracts characters from a string, between two specified indices (positions)
    > toLocaleLowerCase()	  Returns a string converted to lowercase letters, using the host's locale
    > toLocaleUpperCase()	 Returns a string converted to uppercase letters, using the host's locale
    > toLowerCase()	        Returns a string converted to lowercase letters
    > toString()	             Returns a string or a string object as a string
    > toUpperCase()	        Returns a string converted to uppercase letters
    > trim()	            Returns a string with removed whitespaces
    > trimEnd()	            Returns a string with removed whitespaces from the end
    > trimStart()	        Returns a string with removed whitespaces from the start
    > valueOf()	            Returns the primitive value of a string or a string object
    
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        
       

- Métodos y propiedades de las ARRAYS

    > at()        	Returns an indexed element of an array

    > concat()	      Joins arrays and returns an array with the joined arrays. Mediante el método concat podemos combinar dos Arrays en un único Array resultante. se usa para unir dos o más arrays. Este método no cambia los arrays 
                      existentes, sino que devuelve un nuevo array. Tambien se puede usar para unir ya sea un numero y un array, por ejemplo: 1 y [2] daria como resultado [1,2].
   
    > constructor     Returns the function that created the Array object's prototype
   
    > copyWithin()    Copies array elements within the array, to and from specified positions
   
    > entries()	      Returns a key/value pair Array Iteration Object
   
    >* every()	      Checks if every element in an array pass a test
   
    > fill()	      Fill the elements in an array with a static value   array.fill(value, start, end)
    
    > flat()	      Concatenates sub-array elements
    
    > flatMap()	      Maps all array elements and creates a new flat array
    
    >* filter()	      Creates a new array with every element in an array that pass a test. Consiste en filtrar uno o más elementos (un subconjunto) de una colección más grande de elementos (un superconjunto) basándose en alguna 
                      condición/preferencia. Recibe, al igual que find(), una función comparadora por parámetro, y retorna un nuevo array con todos los elementos que cumplan esa condición, o bien, que sean true. Si no hay coincidencias, 
                      retornará un array vacío. Toma una función callback y llama a esa función para cada elemento sobre el que itera dentro del arreglo de destino. La función callback de llamada puede tomar los siguientes parámetros:
                      1- valorActual: Es el elemento del arreglo sobre el que se está iterando actualmente. 
                      2- indice: Es la posición del índice del valorActual dentro del arreglo. 
                      3- arreglo: Representa el arreglo de destino(final) junto con todos sus elementos. Este método crea un nuevo arreglo y devuelve todos los elementos que pasan la condición especificada en la llamada en el callback.
                      
    >* find()	      Returns the value of the first element in an array that pass a test. Recibe una función de comparación por parámetro. Captura el elemento que se está recorriendo y retorna true o false según la comparación ejecutada, o 
                      bien el objeto donde se encuentra lo que estamos buscando. El método retorna el primer elemento que cumpla con esa condición enviada, de ahí que podemos almacenarlo en una variable o usarlo de referencia para otro 
                      proceso. Si no hay ninguna coincidencia en el array, el método find retorna undefined.
                      Toma una función de callback y llama a esa función para cada elemento que recorre dentro del arreglo al que está vinculado. Cuando encuentra una coincidencia (en otras palabras, la función callback devuelve true), el 
                      método devuelve ese elemento particular del arreglo e inmediatamente rompe el bucle. Así que el método find() devuelve el primer elemento dentro de un arreglo que satisface la función callback. 
                      La función callback puede tomar los siguientes parámetros: 1- currentItem: Es el elemento del arreglo sobre el que se está iterando actualmente. 2- index: Esta es la posición de índice de currentItem dentro del arreglo. 
                      3- array: Representa el arreglo de destino junto con todos sus elementos.

    >* findIndex()    Returns the index of the first element in an array that pass a test. It executes a function for each array element. It returns the index (position) of the first element that passes a test. It returns -1 if no match is 
                      found. It does not execute the function for empty array elements. It does not change the original array.
    
    >* forEach()	      Calls a function for each array element. Itera sobre el array y por cada elemento ejecuta la función que enviemos por parámetro, la cual recibe a su vez el elemento del array que se está recorriendo. 
                      Es muy similar al for of, pero con la diferencia de que aqui no podemos salir de la iteracion, mientras qu con for of si.
                      Este a diferencia del map, sirve para ejecutar instrucciones en una iteracion, mientras que el map devuelve un array en cada vuelta.
    
    > for in          Loops through the properties of an object Permite acceder a todas las propiedades del objeto, obteniendo una propiedad por cada iteración. (Solo sirve para iterar objetos). Iterates over all enumerable string properties 
                      of an object (ignoring properties keyed by symbols), including inherited enumerable properties.
    
    > for of          Loops through the values of an iterable object. Permite recorrer un array ejecutando un bloque de código por cada elemento del objeto. (Solo sirve para iterar arrays). It executes a loop that operates on a sequence of 
                      values sourced from an iterable object. Iterable objects include instances of built-ins such as Array, String, TypedArray, Map, Set, NodeList (and other DOM collections), the arguments object, generators produced by 
                      generator functions, and user-defined iterables. 
    
    
    > from()	      Creates an array from an object from any object with a length property, or from any iterable object.
    
    > includes()	      Check if an array contains the specified element. Permite saber si un elemento que recibo por parámetro existe o no dentro de un array, retornando un valor booleano en caso afirmativo o negativo.
   
    > indexOf()	      Search the array for an element and returns its position. El método indexOf() nos permite obtener el índice de un elemento en un array. Recibe por parámetro el elemento que queremos buscar en el array y, en caso de 
                      existir, nos retorna su índice. Si el elemento no existe nos retornará como valor: -1
   
    > isArray()	      Checks whether an object is an array
   
    > join()	      Joins all elements of an array into a string. Sirve para generar un string con todos los elementos del array, separados por el valor que pasamos por parámetro
   
    > keys()	      Returns a Array Iteration Object, containing the keys of the original array
   
    > lastIndexOf()   Search the array for an element, starting at the end, and returns its position
    
    > length	      Sets or returns the number of elements in an array. Al igual que en un String, la propiedad length nos sirve para obtener el largo de un Array, es decir, para identificar cuántos elementos tiene. Es común utilizarlo 
                      para definir el límite de una iteración sobre un array, ya que la propiedad length me permite saber explícitamente la longitud del mismo.
    
    >* map()	      Creates a new array with the result of calling a function for each array element. El método map() crea un nuevo array con todos los elementos del original transformados según las operaciones de la función enviada por 
                      parámetro. Tiene la misma cantidad de elementos pero los almacenados son el return de la función. En el ejemplo, la función retorna la propiedad nombre de cada elemento y eso es lo que se almacena en el nuevo array 
                      nombres. Map() se utiliza mucho para transformación de arrays. Este a diferencia del for each, es que devuelve un array en cada vuelta, mientras que el foreach solo sirve para ejecutar instrucciones.
                      En REACT, debemos incluir en cada elemento la propiedad key, que marque la identidad del elemento. Esto ayudará a react a optimizar el rendering ante cambios en el array. De no tenerla podemos auto-generarla con el 
                      index provisto por el segundo parámetro de map, pero sólo optimizará si hay adiciones al final del array.
    
    > pop()	      Removes the last element of an array, and returns that element. Si queremos eliminar el último elemento, el método pop().
   
    > prototype	      Allows you to add properties and methods to an Array object
    
    > push()	      Adds new elements to the end of an array, and returns the new length. Para sumar un elemento a un Array ya existente, se utiliza el método push, pasando como parámetro el valor (o variable) a agregar.
   
    >* reduce()	      Reduce the values of an array to a single value (going left-to-right). Permite obtener un único valor tras iterar sobre el array. Funciona como un método que resume el array a un único valor de retorno. Este recibe dos 
                      parámetros: 
                      1.El primero es la función que ordena qué queremos resumir del array. Recibe un parámetro que funciona como acumulador, y el elemento del array que iteramos. 
                      2.El segundo es el valor inicial del acumulador.
                      3. El tercer parametro pertenece a la inicializacion. Puede ser opcional su uso y debe ir despues del afuncion
    
   
    > reduceRight()   Reduce the values of an array to a single value (going right-to-left)
    
    > reverse()	      Reverses the order of the elements in an array. Invierte el orden de los elementos dentro de un array. (es destructivo, o sea que modifica el array original, al igual que los métodos para agregar o quitar elementos).
    
    > shift()	      Removes the first element of an array, and returns that element. Si queremos eliminar el primer elemento del array utilizamos el método shift();
    
    > slice()	      Devuelve una copia de una parte del Array dentro de un nuevo Array (no se modifica el original), empezando por el inicio hasta fin (fin no incluído). 
                      Si usamos slice(1), decimos que el array se crea a partir de esa posicion, y si usamos slice(1, 4), el 4 indica el limite, que va de derecha a izquierda, contrario al primer parametro que va de izquierda a derecha.
                      Si elegimos un valor negativo, por ejemplo (1, -2), se lee como "Empiza en la posicion 1 y los ultimos dos valores no los considera". O bien, si tenemos (-2), quiere decir que tomamos los ultimos dos valores del array.
                      Si elegimos dos valores negativos, por ejemplo (-4, -1), se lee como "Empieza en la posicion 4 de derecha a izquierda, y el ultimo valore no se considera (tambien de derecha a izquierda)".
                      
    >* some()	      Checks if any of the elements in an array pass a test. Es igual que el find() recibiendo una función de búsqueda. En vez de retornar el elemento encontrado, retorna true o false según el resultado de la iteración. 
                      Analiza cada elemento de un array a partir de la función que le pasemos. Como su nombre indica, este método nos devolverá el resultado true cuando alguno de los elementos del array cumpla la condición insertada. De 
                      manera lógica, este método nos devolverá el resultado false solo si ninguno de los elementos del array cumple con la condición. Para usar el método some, insertamos el mismo comando de cualquier método array.método. 
                      Luego, entre sus paréntesis, insertamos la función que queremos usar como condición a analizar. Para usar una función como parámetro, podemos insertar su operación directamente o llamarla por su nombre.
    
    >* sort()	      Sorts the elements of an array. Permite reordenar un array según un criterio que definamos. Recibe una función de comparación por parámetro que, a la vez, recibe dos elementos del array. La función 
                      retorna un valor numérico (-1, 1, 0) que indica qué elemento se posiciona antes, después o se mantieneigual. Este método es destructivo, es decir, modifica el array sobre el cual se llama. Para ordenar números, basta 
                      con restar uno al otro, y el orden indica si será ordenado de forma ascendente o descendente. Para ordenar un array por algún string, debemos definir una función comparadora que retorne un valor numérico de referencia, 
                      según queramos el orden ascendente o descendente. No se necesita crear una variable cuando utilicemos este metodo, puesto que el array original mismo es el que se modifica.
    
    > splice()	      Adds/Removes elements from an array. Permite eliminar uno o varios elementos de un array en cualquier posición. Este modifica el array original pero con o sin los elementos establecidos. 
                      Funciona con 2 parámetros: el primero es el índice donde se ubica el método para trabajar, y el segundo es  la cantidad de elementos a eliminar desde esa posición.
                      Si creamos una varaible y la igualamos a un arreglo que utiliza splice(), entonces obtendremos NO el array, sino los elementos eliminados o agregados.
                      splice returns an array. When you push an array into an array, you get an array of arrays. By adding the [0], you push the first element of the array instead    -->  array.splice(0, 1)[0];
                      
    > split()	      Splits a string into an array of substrings. Returns the new array, does not change the original string. If (" ") is used as separator, the string is split between words.
                      
    > toString()	      Converts an array to a string, and returns the result
    > typeof:         You can use the typeof operator to find the data type of a JavaScript variable. The typeof operator can return one of two complex types: function and object.
                      The typeof operator returns "object" for objects, arrays, and null. The typeof operator does not return "object" for functions.
    > unshift()	      Adds new elements to the beginning of an array, and returns the new length. Agrega elementos al inicio del array.
    > valueOf()	      Returns the primitive value of an array
    
    > for in vs for of        En el caso de for in, este devuelve un numero (indice) y se usa generalmente en objetos, y el for of conseguimos el valor que hay en esa posicion.
    
    > arrays vs objetos       Los objetos no son iterables mientras que las arrays sí lo son. Los objetos tienen keys de cualquier valor, los arrays tienen keys numéricos y por estricto orden
    
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
   
                                                                                                           JSON & storage
                                                                                                           
   > storage: El objeto Storage (API de almacenamiento web) permite almacenar datos de manera local en el navegador sin necesidad de realizar ninguna conexión con el servidor. De esta manera, cada cliente puede preservar información de la 
     aplicación. El navegador nos ofrece dos tipos de storage: localStorage y sessionStorage.
   > localstorage.Setitem(); Los datos almacenados en localStorage (variable global preexistente) se almacenan en el navegador de forma indefinida (o hasta que se borren los datos de navegación del browser). La información persiste reinicio 
     de navegador y hasta del sistema operativo.
   > Clave-valor: La información almacenada en el Storage se guarda en la forma de clave-valor. Similar al tratamiento de objetos, definimos claves en el storage donde almacenamos valores.
   > localstorage.getItem(); Podemos acceder a la información almacenada en localStorage utilizando getItem. Las claves y valores de Storage se guardan en formato de cadena de caracteres (DOMString).
   > localstorage.setItem(); La información almacenada en sessionStorage (variable global preexistente) se almacena en el navegador hasta que el usuario cierra la ventana. Solo existe dentro de la pestaña actual del navegador. Otra pestaña 
     con la misma página tendrá otro sessionStorage distinto, pero se comparte entre iframes en la pestaña (asumiendo que tengan el mismo origen).
   > sessionStorage.getItem(); Podemos acceder a la información almacenada en sessionStorage utilizando getItem. Las claves y valores de Storage se guardan siempre en formato de cadena de caracteres
   > Recorriendo el storage: Es posible obtener todos los valores almacenados en localStorage o sessionStorage con un bucle. Pero no podemos usar for of porque no son objetos iterables, ni for in porque obtenemos otras propiedades del 
     objeto que no son valores almacenados.
   > Eliminar datos del storage: Podemos eliminar la información almacenada en sessionStorage o localStorage usando el método removeItem o clear. 
     ~ localStorage.removeItem(); 
     ~ sessionStorage.removeItem();
     ~ localStorage.clear(); //elimina toda la información
     ~ sessionStorage.clear(); //elimina toda la información
     
   > Almacenar objetos en storage Si queremos almacenar la información de un objeto en un storage, hay que tener en cuenta que tanto la clave como el valor se almacenan en strings. Ante cualquier otro tipo a guardar, como un número o un 
     objeto, se convierte a cadena de texto automáticamente. Entonces, al buscar almacenar un objeto sin una transformación previa, guardamos [object Object], la conversión por defecto de objeto a string. Para guardar la información 
     correctamente hay que transformar el objeto a JSON.
   > Acceso tipo objeto Dado que localStorage y sessionStorage son objetos globales, es posible crear y acceder a las claves como si fueran propiedades. Pero esto no es recomendable, porque hay eventos asociados a la modificación del storage 
     cuando se emplea getItem o setItem.
         
   > Conversiones de/hacia JSON: Cuando sea necesario enviar un objeto Javascript al servidor o almacenarlo en storage, será necesario convertirlo a un JSON (una cadena) antes de ser enviado.
     Cuando sea necesario enviar un objeto Javascript al servidor o almacenarlo en storage, será necesario convertirlo a un JSON (una cadena) antes de ser enviado. Para eso usamos los siguientes métodos:
     
     ~ JSON.stringify(); acepta un objeto como parámetro, y devuelve la forma de texto JSON equivalente. Podemos transformar un objeto JavaScript a un string en formato JSON. 
       Los parametros que existen en esta funcion son:            JSON.stringify(value, replacer, space);
       + value: The value to convert to a JSON string
       + replacer: function that alters the behavior of the stringification process, or an array of strings and numbers that specifies properties of value to be included in the output. If replacer is an array, all elements in this array that 
         are not strings or numbers (either primitives or wrapper objects), including Symbol values, are completely ignored. If replacer is anything other than a function or an array (e.g. null or not provided), all string-keyed properties 
         of the object are included in the resulting JSON string.
       + space: A string or number that's used to insert white space (including indentation, line break characters, etc.) into the output JSON string for readability purposes. If this is a number, it indicates the number of space characters 
         to be used as indentation, clamped to 10 (that is, any number greater than 10 is treated as if it were 10). Values less than 1 indicate that no space should be used.
         If this is a string, the string (or the first 10 characters of the string, if it's longer than that) is inserted before every nested object or array. If space is anything other than a string or number (can be either a primitive or a 
         wrapper object) — for example, is null or not provided — no white space is used.
         
       This static method converts a JavaScript value to a JSON string, optionally replacing values if a replacer function is specified or optionally including only the specified properties if a replacer array is specified.

     ~ JSON.parse(); recibe un texto JSON como parámetro, y devuelve el objeto JavaScript correspondiente. Podemos transformar string en formato JSON a objeto JavaScript. 
       Los parametros que existen en esta funcion son:            JSON.parse(text, reviver);    
        + text: The string to parse as JSON. See the JSON object for a description of JSON syntax.
        + reviver: If a function, this prescribes how each value originally produced by parsing is transformed before being returned. Non-callable values are ignored. The function is called with the following arguments: key and value.
       
       This static method parses a JSON string, constructing the JavaScript value or object described by the string. An optional reviver function can be provided to perform a transformation on the resulting object before it is returned.

   
   > Recuperar datos: Muchas veces usamos el Storage para recuperar datos relacionados a la última navegación del usuario. Por ejemplo, su última sesión de login o el último estado de su carrito de compras. Para esto, pensamos en inicializar 
     las variables de la app consultando el Storage en el momento de inicio.
     
     
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


- Propiedades del objeto WINDOW

    > closed	        Returns a boolean true if a window is closed.
    > console	        Returns the Console Object for the window.
    > document	        Returns the Document object for the window.
    > frameElement	   Returns the frame in which the window runs.
    > frames	        Returns all window objects running in the window.
    > history	        Returns the History object for the window.
    > innerHeight	    Returns the height of the window's content area (viewport) including scrollbars
    > innerWidth	         Returns the width of a window's content area (viewport) including scrollbars
    > length	        Returns the number of <iframe> elements in the current window
    > localStorage	   Allows to save key/value pairs in a web browser. Stores the data with no expiration date
    > location	        Returns the Location object for the window.
    > name	             Sets or returns the name of a window
    > navigator	        Returns the Navigator object for the window.
    > opener	        Returns a reference to the window that created the window
    > outerHeight	    Returns the height of the browser window, including toolbars/scrollbars
    > outerWidth	         Returns the width of the browser window, including toolbars/scrollbars
    > pageXOffset	    Returns the pixels the current document has been scrolled (horizontally) from the upper left corner of the window
    > pageYOffset	    Returns the pixels the current document has been scrolled (vertically) from the upper left corner of the window
    > parent	        Returns the parent window of the current window
    > screen	        Returns the Screen object for the window
    > screenLeft	        Returns the horizontal coordinate of the window relative to the screen
    > screenTop	        Returns the vertical coordinate of the window relative to the screen
    > screenX	        Returns the horizontal coordinate of the window relative to the screen
    > screenY	        Returns the vertical coordinate of the window relative to the screen
    > sessionStorage	   Allows to save key/value pairs in a web browser. Stores the data for one session
    > scrollX	        An alias of pageXOffset
    > scrollY	        An alias of pageYOffset
    > self	              Returns the current window
    > top	             Returns the topmost browser window

- Métodos del objeto WINDOW

    > addEventListener()         Attaches an event handler to the window
    > alert()	                 Displays an alert box with a message and an OK button
    > atob()	                 Decodes a base-64 encoded string
    > blur()	                 Removes focus from the current window
    > btoa()	                 Encodes a string in base-64
    > clearInterval()            Clears a timer set with setInterval()
    > clearTimeout()             Clears a timer set with setTimeout()
    > close()	                 Closes the current window
    > confirm()	                 Displays a dialog box with a message and an OK and a Cancel button
    > focus()	                 Sets focus to the current window
    > getComputedStyle()	      Gets the current computed CSS styles applied to an element
    > getSelection()             Returns a Selection object representing the range of text selected by the user
    > matchMedia()               Returns a MediaQueryList object representing the specified CSS media query string
    > moveBy()	                 Moves a window relative to its current position
    > moveTo()	                 Moves a window to the specified position
    > open()	                 Opens a new browser window
    > print()	                 Prints the content of the current window
    > prompt()	                 Displays a dialog box that prompts the visitor for input
    > removeEventListener()	 Removes an event handler from the window
    > requestAnimationFrame()	 Requests the browser to call a function to update an animation before the next repaint
    > resizeBy()	                 Resizes the window by the specified pixels
    > resizeTo()	                 Resizes the window to the specified width and height
    > scrollBy()	                 Scrolls the document by the specified number of pixels
    > scrollTo()	                 Scrolls the document to the specified coordinates
    > stop()	                 Stops the window from loading
     
 

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$    
   
                                                                                                    Operadores logicos avanzados

Operador ternario ?:  	               a ? b : c	                Si a es true, devuelve b, sino devuelve c.
Operador unario lógico NOT	               !a	   
Operador de asignación lógica nula ??=    a ??= b	                Es equivalente a   a ?? (a = b)

Operador lógico AND                       a && b	                     Devuelve a si es false, sino devuelve b.
Operador lógico OR                        a || b	                     Devuelve a si es true, sino devuelve b.
Operador lógico Nullish coalescing        a ?? b	                     Devuelve b si a es null o undefined, sino devuelve a.  funciona igual que el Operador OR ( || ), con la diferencia que admite más valores como ‘verdaderos’.
Operador de encadenamiento opcional ?.    data?.name                 Permite intentar acceder a una propiedad, aunque su padre no exista. Si intentamos acceder a un objeto que no existe naturalmente obtendremos un error en consola. Pero, si 
                                                                     usamos el operador ?. sobre la referencia de un objeto para condicionar su acceso podemos tener un mejor control de errores en la ejecución. En este caso, en caso de que 
                                                                     algo no exista, en lugar de tirar un error en consola, obtendremos un undefinded
                                                                     
  > Desestructuración Es decir, los nombres de las variables deben coincidir exactamente con los nombres de las propiedades que queremos obtener del objeto. En el ejemplo anterior, podemos desestructurar el objeto de la siguiente forma:
  
    const usuario = {nombre: "John Doe", edad: 32}
    const { nombre, edad } = usuario
    console.log(nombre) // "John Doe"
    console.log(edad) // 32
    
    Si intentamos desestructurar una propiedad inexistente en el objeto, obtendremos undefined. Cada propiedad que queramos desestructurar del objeto las declaramos separadas por comas. Recordemos que en este caso y en los anteriores, 
    estamos declarando variables con los nombres nombre, edad, y teléfono; por lo que luego las referenciamos con este nombre.
    Si queremos acceder a propiedades más internas dentro de un objeto, es decir desestructurar alguna propiedad que sea a la vez un objeto, es posible hacerlo siguiendo el mismo patrón. 
    En este caso, como teléfono es un objeto, desestructuramos la propiedad trabajo de éste, dentro de la desestructuración de usuario. Nótese que finalmente se terminan declarando dos variables, nombre y trabajo. 
    Recordar que siempre se deben utilizar las mismas variables cuando desestructuramos un objeto, pero en un array SI se pueden cambiar.
    
    const usuario = { nombre: "John Doe", edad: 32, telefono: {cel: 113334444, casa: null, trabajo: 113325555} }
    const { nombre, telefono: {trabajo} } = usuario; 
    console.log(nombre); // "John Doe"
    console.log(trabajo); // 113325555
    
  > Alias: Para que la desestructuración funcione debe haber coincidencia con los nombres de las propiedades del objeto.
    Sin embargo a veces puede que los nombres de las propiedades no sean muy descriptivos para el uso que queremos darle, y por ello podemos desestructurarlas con un alias, es decir declarar la variable con un nombre alternativo tras haber 
    desestructurado el objeto. Esto lo hacemos simplemente con el operador : luego del nombre de la propiedad. En este caso desestructuramos todas las propiedades de item, pero lo almacenamos en variables denominadas id, nombre, precio, a 
    través del alias que indicamos para cada una.
    
    const item = {item_id: 432, product_name: "Some product", price_per_unit: 5600}
    const {item_id: id, product_name: nombre, price_per_unit: precio} = item
    console.log(id) // 432
    console.log(nombre) // "Some product"
    console.log(precio) // 5600
    
  > Desestructuración en parámetros: Si en una función recibimos objetos por parámetros, también es posible desestructurarlos directamente en el llamado, definiendo esto al declarar la función. Por ejemplo, supongamos una función que recibe 
    un objeto producto por parámetro y debe trabajar con sus propiedades id y nombre
    
  > Desestructuración de arrays: Es posible desestructurar arrays de forma similar, usando corchetes [] en vez de llaves. La diferencia con la desestructuración de objetos es que la de arrays es posicional. Es decir, declaramos las 
    variables en orden y estas almacenan los valores de las mismas posiciones del array de referencia:   
    No funciona aquí la coincidencia por nombres, sino que se toman los valores según la posición. Las dos primeras variables que declaramos tomarán los valores de los dos primeros elementos del array. Si queremos acceder a otras 
    posiciones, o mejor dicho omitir las primeras, podemos hacerlo dejando espacios vacíos con comas:
    
  > Operador Spread: Spread (...) es una herramienta que nos permite, como su nombre indica, desparramar un array u objeto. En otras palabras, cambiar la forma en la que presentamos este array u objeto. Esta se puede utilizar para crear 
    copias de un objeto o array sin necesidad de alterar o modificar los valores principales de esos elementos. Se le conoce como copia por valor. 
     
  > Spread de arrays: Lo que hace el spread (...) al aplicarse sobre un array, es enviar todos sus elementos como parámetros individuales. Esto es útil cuando tenemos datos ordenados dentro de una colección pero trabajamos con funciones 
    que no funcionan recibiendo arrays sino una serie de parámetros individuales, como pueden ser Math.max() o Math.min(). Con spread podemos solucionar esto ya que Math.max() recibirá cada elemento del array como un parámetro individual:
    También podemos hacer spread de un array dentro de otras estructuras que lo admitan. Esto nos permite, por ejemplo, replicar el contenido de un array dentro de otra estructura al desparramar su contenido dentro. 
    Si lo hacemos dentro de un objeto veremos algo interesante, que cada propiedad toma como nombre el índice de los elementos.
         
  > Spread de objetos:  Se puede hacer spread de objetos también, pero debe hacerse dentro de una estructura que lo permita, como otro objeto.
    Un spread aplicado sobre un objeto presentaría cada par de clave-valor separado por comas, y ésto en una función no sería admisible, pero sí puede serlo dentro de otro objeto.
    Esto suele ser útil cuando queremos replicar o modificar estructuras de objetos, ya que nos permite primero listar todas sus propiedades y valores y luego modificar/agregar las que queramos.
       
  > Rest parameters El operador spread también puede utilizarse dentro de la declaración de una función para indicar que queremos recibir una cantidad indeterminada de parámetros. Supongamos que quiero tener una función para sumar 
    cualquier cantidad de números ue reciba por parámetro. Puedo hacer esto con el operador spread definiendo rest parameters, lo que significa que mi función va a recibir una cantidad indeterminada de parámetros, pero los va a agrupar 
    dentro de un array con el nombre que defina, y con eso trabajará dentro.
    

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        


                                                                                                                   Almacenamiento de archivos


- Storage API: The Storage object of the Web Storage API provides access to the session storage or local storage for a particular domain. This allows you to read, add, modify, and delete stored data items.
   > localStorage:   The localStorage object stores the data with no expiration date. The data will not be deleted when the browser is closed, and will be available the next day, week, or year.
   > sessionStorage: The sessionStorage object is equal to the localStorage object, except that it stores the data for only one session. The data is deleted when the user closes the specific browser tab.
   > getItem()	     Returns the value of the specified key name. Podemos acceder a la información almacenada en localStorage utilizando getItem. Las claves y valores de Storage se guardan en formato de cadena de caracteres (DOMString).
   > setItem()	     Adds a key to the storage, or updates a key's value if it already exists. Los datos almacenados en localStorage (variable global preexistente) se almacenan en el navegador de forma indefinida (o hasta que se borren 
                     los datos de navegación del browser). La información persiste reinicio de navegador y hasta del sistema operativo. Solo existe dentro de la pestaña actual del navegador. Otra pestaña con la misma página tendrá otro 
                     sessionStorage distinto, pero se comparte entre iframes en la pestaña (asumiendo que tengan el mismo origen)
   > clear()	     Empty all key out of the storage
   > key(            Returns the name of the nth key in the storage. Es posible obtener todos los valores almacenados en localStorage o sessionStorage con un bucle for convencional unicamente y colocando localStorage.key(i);
   > length	     Returns the number of data items stored in the Storage object
   > removeItem()    Removes a key from the storage    
    
- JSON: It is a format for storing and transporting data. JSON is text, and text can be transported anywhere, and read by any programming language.   
   > JSON.parse();          Parses a JSON string and returns a JavaScript object. Recibe un texto JSON como parámetro, y devuelve el objeto JavaScript correspondiente. Podemos transformar string en formato JSON a objeto JavaScript.
   > JSON.stringify();      Convert a JavaScript object to a JSON string. acepta un objeto como parámetro, y devuelve la forma de texto JSON equivalente. Podemos transformar un objeto JavaScript a un string en formato JSON. 
   
- fs en Nodejs: fs es la abreviación utilizada para FileSystem, el cual, como indica el nombre, es un sistema de manejador de archivos que nos proporcionará node para poder crear, leer, actualizar o eliminar un archivo, sin tener que hacerlo 
     nosotros desde cero. Así, crear un archivo con contenido será tan fácil como escribir un par de líneas de código, en lugar de tener que lidiar con los datos binarios y transformaciones complejas y de un nivel más bajo en la computadora.
     fs existe desde el momento en el que instalamos Nodejs en nuestro computador, por lo que, para utilizarlo, podemos llamarlo desde cualquier archivo que tengamos de nuestro código con la siguiente línea:
                                                                                   
                                                                                   const fs = require("fs");
                                                                                   
     De ahí en adelante todo el módulo de FileSystem estará contenido en la variable fs. Sólo debemos utilizarlo llamando sus métodos como una clase. Esto podremos hacerlo de 3 formas: síncrono, con callbacks o con promesas.                                                                                   
     Para utilzar de forma adecuada el fs, sólo utilizaremos la palabra Sync después de cada operación que queramos realizar. Las principales operaciones que podemos hacer con fs síncrono son:
       ✓ writeFileSync = Para escribir contenido en un archivo. Si el archivo no existe, lo crea. Si existe, lo sobreescribe.
       ✓ readFileSync = Para obtener el contenido de un archivo.
       ✓ appendFileSync = Para añadir contenido a un archivo. ¡No se sobreescribe!
       ✓ unlinkSync = Es el “delete” de los archivos. eliminará todo el archivo, no sólo el contenido.
       ✓ existsSync = Corrobora que un archivo exista!
       
- fs con callbacks: Funciona muy similar a las operaciones síncronas. Sólo que al final recibirán un último argumento, que como podemos intuir, debe ser un callback. Según lo vimos en las convenciones de callbacks de la clase pasada, el 
    primer argumento suele ser un error. Esto permite saber si la operación salió bien, o si salió mal. Sólo readFile maneja un segundo argumento, con el resultado de la lectura del archivo.
    Por último: el manejo por callbacks es totalmente asíncrono, así que cuidado dónde lo usas. Las principales operaciones que podemos hacer con fs con callbacks son:
      ✓ writeFile = Para escribir contenido en un archivo. Si el archivo no existe, lo crea. Si existe, lo sobreescribe. Al sólo escribir, su callback sólo maneja: (error)=>
      ✓ readFile = Para obtener el contenido de un archivo. Como pide información, su callback es de la forma: (error, resultado)=>
      ✓ appendFile = Para añadir contenido a un archivo. ¡No se sobreescribe!, al sólo ser escritura, su callback sólo maneja: (error)=>
      ✓ unlink = Es el “delete” de los archivos. eliminará todo el archivo, no sólo el contenido. Al no retornar contenido, su callback sólo es (error)=>
      
     Si queremos utilizar promesas, entonces qudarian como:
      ✓ fs.promises.writeFile
      ✓ fs.promises.readFile
      ✓ fs.promises.appendFile
      ✓ fs.promises.unlink    


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        


                                                                                                                   Asincronia
                                                                                                                   
    > setInterval()              Calls a function or evaluates an expression at specified intervals (in milliseconds).
                                 setInterval funciona como setTimeout, la diferencia radica en que éste reiniciará el conteo y ejecutará la tarea nuevamente cada vez que se cumpla dicho intervalo de tiempo. Un timer devuelve un apagador el 
                                 cual permite detener el intervalo cuando se cumpla cierta operación. Suele utilizarse mucho para poner tiempos límites en alguna página para llenar formularios (Hay ciertas páginas que te dan tiempo límite 
                                 para hacer la operación, O TE BOTAN).
    > setTimeout()               Calls a function or evaluates an expression after a specified number of milliseconds. 
                                 setTimeout se utiliza para establecer un temporizador que ejecute una tarea después de un determinado tiempo. permite entender en un par de líneas la idea del asincronismo. A diferencia de una operación 
                                 síncrona, podremos notar como setTimeout inicia su ejecución, y una vez que haya transcurrido el tiempo, veremos el resultado, aun cuando el resto de las operaciones hayan terminado. 
                                                                                                                  
                                                                                                                   
  
  > setTimeout: Es una función que permite realizar acciones asincrónicamente. La función recibe dos parámetros: Una función de callback y un valor numérico que representa milisegundos. Así, la función que pasamos por primer parámetro se 
    ejecuta luego de que transcurra el tiempo definido en el segundo parámetro. Por ejemplo:
    
    setTimeout(()=> {
       console.log("Proceso asincrónico" )
    }, 3000);
    
  > CALL STACK (PILA): Es una lista donde se apilan las distintas tareas a ejecutar por nuestro programa. Javascript es un lenguaje single threaded, o de un único hilo, lo que significa que tiene un único stack o pila de ejecución. De ahí 
    que la ejecución es implícitamente sincrónica. Cuando se está a punto de ejecutar una función, ésta es añadida al stack. Si la función llama a la vez, a otra función, ésta es agregada sobre la anterior. Es igual a llamar a una funcion 
    dentro de otra funcion, ya que esta primera funcion queda pendiente su ejecucion y al termina de emplearse la segunda funcion, entonces esta desaparece y continua terminandose la primera funcion.
  
  > Callbacks: Una función callback es una función de primer nivel que se pasa a otra función como variable y ésta es ejecutada en algún punto de la ejecución de la función que la recibe.
    
  > EVENT LOOP: Muchas funciones asincrónicas se ejecutan en un stack diferente. El Event Loop es la herramienta que permite la sincronización entre nuestro call stack con estas tareas asincrónicas que funcionan en un thread aparte. Si el 
    stack está vacío, el Event Loop envía la primera función que esté en la callback queue al call stack y comienza a ejecutarse.
    
  > setInterval: Tiene la misma sintaxis que setTimeout, pero la unidad de tiempo es un intervalo para la repetición de la función asociada: Permite ejecutar funciones de manera reiterativa tras los milisegundos indicados hasta que 
    indiquemos su detención o se cierre la aplicación
    
    setInterval(() => {
       console.log("Tic")
    }, 1000)
   
  > ClearInterval & clearTimeout: En caso de querer remover un Intervalo, utilizamos la función clearInterval ().También podemos detener la ejecución de un setTimeout invocando clearTimeout ().
    Cuando llamamos un setInterval() éste retorna una referencia al intervalo generado, el cual podemos almacenar en una variable. Es esta referencia la que debemos pasar a la función clearInterval para que la limpieza tenga efecto.
    Funciona igual con los timeout. Si guardamos en una variable la referencia al timeout generado, podemos usarla para removerlo luego. En el siguiente caso, el timeout generado nunca llega a ejecutarse
    
  > Promesas (promise): Es un objeto de Javascript que representa un evento a futuro y permite representar y seguir el ciclo de vida de una tarea/operación (función). Es una acción asincrónica que se puede completar en algún momento y 
    producir un valor, y notificar cuando esto suceda. Una promesa cuenta con tres estados posibles: pending, fulfilled y rejected. Las promesas pueden ser resueltas o rechazadas.
    Podemos crear promesas a través de su constructor new Promise. Su sintaxis es algo compleja, ya que recibe una función por parámetro que a su vez recibe por parámetro las funciones de resolve y reject
    
    new Promise( (resolve, reject) => {
       //cuerpo de la promesa
    })
    
    En contra de lo que se suele pensar, la sincronicidad o asincronicidad de una promise depende de qué tarea le demos. Por defecto y diseño, lo único que ocurre de manera asincrónica es la entrega del resultado.
    Las funciones callback nunca serán llamadas previo a la terminación de la ejecución actual del bucle de eventos en JavaScript.
    Las funciones callback añadidas con .then serán llamadas después del éxito o fracaso de la operación

  
  > Resolve & Reject: En principio, una promesa se retorna con estado pending, entendiendo que el valor a generar aún no fue resuelto: 
  Esta función retorna una promesa que no se resuelve. Por lo tanto, veremos que el valor que genera es un objeto Promise con estado pendiente.

  const eventoFuturo = () => {
     return new Promise( (resolve, reject) => {
        //cuerpo de la promesa
     })
  }
  console.log( eventoFuturo() ) // Promise { <pending> }
   
  El valor de retorno de la promesa se define a través del llamado a las funciones de resolve o reject:
    ✓ Si el cuerpo de la promesa llama a resolve(), la promesa cambiará su estado a fulfilled, con el valor enviado a resolve().
    ✓ Si la promesa llama a reject(), cambiará su estado a rejected con el valor enviado al reject(). Aqui decidimos que la promesa retornara un valor que se interpreta como error y se muestra en la consola en rojo y con una x.  
       
  > Then & Catch: Al llamado de una función que retorne una promesa, podemos concatenar el método .then() o .catch(), los cuales reciben una función por parámetro con la cual se captura el valor de la promesa:
    ✓ .then():    Si la promesa es resuelta, su valor de retorno se captura dentro del .then(), recibiendo por parámetro de su función ese valor. Siempre que coloquemos un return dentro de un .then, automáticamente el resultado se convierte 
                  en otra promesa y puede ser encadenada con otro .then, y así sucesivamente hasta finalizar el proceso. Si en alguno de los .then algo llegara a salir mal, sólo se necesita un catch para atraparlo.
    ✓ .catch():   Si la promesa es rechazada, su valor se captura dentro de un .catch() siguiendo la misma lógica
    ✓ .finally() es un método que recibe una función la cual se ejecutará siempre al finalizar la secuencia, sin importar si se haya resuelto o no la promesa.
   
    Como una promesa puede tener varios estados posibles, se puede concatenar varios .then() o .catch() en un mismo llamado, y caeremos en el caso que corresponda según cómo se haya resuelto la promesa. Para cada promesa podemos definir una 
    estructura para trabajar los distintos casos posibles. Cada promesa sólo puede resolverse o rechazarse una única vez. Es un mecanismo de control claro y ordenado para trabajar la asincronía y los posibles valores a recibir.   
   
   > Try-catch: This statement is comprised of a try block and either a catch block, a finally block, or both. The code in the try block is executed first, and if it throws an exception, the code in the catch block will be executed. The code 
     in the finally block will always be executed before control flow exits the entire construct.
   
   > Try-catch-throw:
     If you use the keyword 'throw' in an async function, the function will call the 'reject()' function behind the scenes and the promise will get rejected...
     However, when using try...catch block inside an async function and an error occurs in some function that returns a promise (like fetch) or if you use the 'throw' keyword yourself, the code execution will stop and move to the first 
     available catch block. So try...catch block gives you control to handle errors manually and internally and then decide how to proceed.
     For example, you could handle 10 different errors in a single or multiple try...catch blocks withing the async function and decide to reject the promise only for major errors, but still resolve it manually for smaller errors.
     The bottom line is that try...catch block gives you more control over error handling. So if you only have 1 possible error message like we do here, then you don't need the try/catch block in getJSON function nor loadRecipe function and
     the promises those functions return will normally reject/resolve based on what happened with the promises inside
   
   > fetch: Sirve para hacer peticiones HTTP a algún servicio externo. Como estas peticiones son asincrónicas, convenientemente el método fetch() trabaja con promesas. El método recibe un primer parámetro que es la URL a la cual hacer la 
     petición, y un segundo parámetro opcional de configuración: fetch(url, config). Al final, fetch retorna una nueva promesa.
     Por defecto el método fetch hace peticiones del tipo GET. Según la documentación, para obtener una lista de posts debemos hacer una petición del siguiente tipo.
     Podemos hacer un request de manera simple, utilizando Fetch API.
     Esta nos provee con una promesa, que se resuelve al terminar el request.
     Esta respuesta es una promise, que nos permite acceder a la respuesta.
       
   > Response: Llamar a fetch() retorna una promesa que resuelve en un objeto Response que contiene información sobre la respuesta del servidor, como su código de estado y headers. Para acceder al contenido de la respuesta debemos dar un 
     paso adicional, y por eso es que se ven dos .then() concatenados. Generalmente, se transfieren datos en formato JSON. Por lo tanto, para obtener el contenido de la respuesta debemos aplicar el método .json() a ese objeto. Éste retorna 
     a su vez una Promesa, por lo que capturamos su contenido (los datos enviados por la API) en un segundo .then(): 

         fetch('https://jsonplaceholder.typicode.com/posts')
           .then( (resp) => resp.json() )
           .then( (data) => {
            console.log(data)
         });
         
       En el parámetro data tenemos el contenido de la respuesta de nuestra petición. En este caso, la API nos responde con un array de 100 elemento donde cada elemento es un post.
         
  > async & await: Trabajar con promesas facilita mucho el control de los procesos asincrónicos Sin embargo, en procesos extensos se puede dificultar el trabajo escribiendo todo dentro de varios .then(). 
       Por suerte, los desarrolladores de JS ya pensaron en esto y nos ofrecen una herramienta que nos permite trabajar las promesas como si escribiéramos código sincrónico : async await.
       El método fetch retorna una promesa. De forma sincrónica, si guardamos esta promesa en una variable veremos la promesa pendiente, porque esto sucede sincrónicamente.

       const resp = fetch('https://jsonplaceholder.typicode.com/posts' ); console.log(resp) // Promise {<pending>}
       
    Significa que el console.log() no espera a que se resuelva la promesa de la línea anterior para ejecutarse.

    ✓ async: Se colocará al inicio de una función, indicando que todo el cuerpo de esa función deberá ejecutarse de manera asíncrona 
      Esta palabra reservada sirve para declarar una función como asincrónica, y se agrega como prefijo a la función. Así, dentro de una función async podemos utilizar la sentencia await vista previamente. Esto nos permite esperar a 
      que se resuelvan las promesas vistas para continuar con la instrucción siguiente.
      Lo que hace await es detener la ejecución y no continuar. Se espera a que se resuelva la promesa, y hasta que no lo haga, no continua. A diferencia del fetch(), tenemos un código bloqueante.
      
    ✓ await: servirá (como indica su nombre) para esperar por el resultado de la promesa y extraer su resultado. Al ser operaciones que podrían salir bien, PERO TAMBIÉN MAL, es importante encerrar el cuerpo en un bloque try {} catch {} 
      Nos permite establecer un punto de espera en el código. Aplicado como prefijo a una promesa (en este caso, el return del fetch) se bloquea la ejecución de la siguiente instrucción hasta que la promesa se resuelva.     
      Lo malo es que await sólo puede utilizarse dentro de una función asincrónica. Aquí es donde entra la sentencia async. Ésta palabra reservada sirve para declarar una función como asincrónica, y se agrega como prefijo a la función.             
      Así, dentro de una función async podemos utilizar la sentencia await vista previamente. Esto nos permite esperar a que se resuelvan las promesas vistas para continuar con la instrucción siguiente. 

   > micro-tasks queue: 

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Express

- Express js es un framework minimalista que permitirá desarrollar servidores más complejos. Éste nos facilitará:
   ✓ Utilizar diferentes rutas para las peticiones.
   ✓ Mejorar la estructura de nuestro proyecto.
   ✓ Manejar funcionalidades más complejas y utilización de middlewares. 
  
  + Paso 1: npm init -y                                                                                                                   
    Express no es nativo de nodejs, por lo tanto, necesitaremos primero contar con un package.json para gestionar las dependencias a instalar. 
    Una vez que tenemos package.json en nuestra carpeta, podemos continuar instalando dependencias.
  
  + Paso 2: npm install express 
    Procedemos a instalar de manera local express js. Al ejecutar este comando, notaremos cómo se genera una carpeta node_modules, que es donde se encuentra almacenado express.
    A partir de este punto, ya contamos con la estructura elemental instalada, el resto es más “flexible”.

  + Paso 3: Estructurar el proyecto 
    Se recomienda tener una carpeta src, donde vivirá todo nuestro código, dentro del cual crearemos un archivo con el nombre “app.js”
    Finalmente, el archivo app.js ya puede importar la dependencia instalada de express js, ya sea por commonjs:   const express = require ("express");
    o bien por module (recordar colocar el type:”module” en package.json):   import express from "express";                                           
  
  + Ejemplo de una consulta en Express
     ✓ Estructurar un servidor basado en express, el cual escuche peticiones en el puerto 8080
     ✓ Realizar una función para el método GET en la ruta ‘/saludo’, el cual responderá con “¡Hola a todos, pero ahora desde express!”
     ✓ Ejecutar con nodemon (npm install -g nodemon) y probar en el navegador el endpoint generado.
     
- Método GET: Método del protocolo HTTP que permite indicar al servidor que deseamos hacer na consulta de obtención de datos.       .get() 
- Metodo POST: Sirve para “crear” recursos, POST se utiliza para operaciones donde no necesitamos  obtener un recurso, sino añadir uno. Algunos de los casos donde se utilizan son:
    ✓ Registrar un usuario
    ✓ Loguear un usuario
    ✓ Crear un producto
    ✓ Crear una mascota
    ✓ Crear un carrito de compra
    ✓ Enviar información para un correo electrónico.
  Se apoya del recurso req.body, donde elbody representa la información que el cliente envía para crear.
- Método PUT: Sirve Para poder trabajar con PUT, no sólo enviamos el body en el request, sino que demás mandamos por params el id, nombre,  cualquier identificador para que el servidor epa qué recurso específicamente debe ctualizar.
  Hay dos formas de actualizar un recurso: actualizar sólo los campos requeridos, o bien mandar a actualizar el objeto completo, ambas formas son válidas cuando hablamos de actualización, y dependerá del contexto.
- Método DELETE: Como bien lo indica el nombre, este método lo utilizamos cuando queremos eliminar algún recurso. Aquí no es necesario enviar nada desde el body, sin embargo, sí es importante indicar en el req.params el identificador para 
  que el servidor reconozca qué recurso debe eliminar.
  
  
- Metodos en express js
  > // app.set(name, value); is used to assign the setting name to value. You may store any value that you want, but certain names can be used to configure the behavior of the server. 

      
- Objeto request: Objeto usado dentro de los servicios de express para poder realizar consultas más complejas.
  The req object represents the HTTP request and has properties for the request query string, parameters, body, HTTP headers, and so on. In this documentation and by convention, the object is always referred to as req (and 
  the HTTP response is res) but its actual name is determined by the parameters to the callback function in which you’re working.  
  
  > req.query: Como su nombre lo indica, query refiere a las múltiples consultas que se pueden hacer a un determinado endpoint, basta conque en la url coloquemos el símbolo ? , entonces express reconocerá que hay que meter información al 
    objeto req.query para poder utilizarlo en el endpoint. Cuando buscamos algo en nuestro navegador, llamamos a un endpoint haciendo un determinado query. Se expresa como:    ?key=valor
    
    Conforme incrementa el dinamismo en las urls, es importante configurar el servidor para que reciba datos complejos desde la url, por ello hay que utilizar la línea:
                   app.use(express.urlencoded({ extended: true }));
    La línea anterior permitirá que el servidor pueda interpretar mejor los datos complejos que viajen desde la url, y mapearlos correctamente en el req.query.
    Es decir, cuando hagamos una peticion POST, cuando lleguen, que podamos recivir esos datos. Sino, llegara un objeto vacio. 
    
    Tambien tenemos la siguiente linea que dice que, cuando nosotros hagamos peticiones por POST, lleguen. O de lo cotrario, nos llegarian como undefined.
                   app.use(express.json());
  
  > req.params: Se utiliza cuando necesitamos obtener elementos dinámicos desde la ruta que está llamando el cliente. para poder definir un “parámetro” dentro de la ruta a trabajar, basta con colocar el símbolo de dos puntos (:) antes del 
    parámetro, de esta manera, express reconoce que queremos que ese elemento sea dinámico.
    
  > ¿Qué diferencia hay con params? 
    La principal diferencia que hay entre req.params y req.query, es que en req.query puedo meter la cantidad de consultas que yo así desee, ya que las queries no vienen inmersas en la ruta, sino que son un elemento aparte.
    Así, si desconozco el número de cosas que se van a consultar en mi ruta, la mejor opción es utilizar queries, mientras que, si sólo necesito un número específico y reducido de parámetros, habría que optar por params
    Al final, no hay una mejor que otra, sirven para casos diferentes e incluso podemos utilizar ambas en la misma consulta. 
    
  > req.body:  
  
  > next(): Esta funcion representa un parametro en adicional a req y res (req, res, next) y se usa en middlewares, generalmente cuando se manejan errores. Si el middleware no presentan ningun inconveniente, la funcion next() no tendra 
    ningun parametro, es decir, no hay error que enviar. Pero en caso de haberlo, entonces se debera mandar ese error dentro de los parentesis.
        
- Router en Express: Un router en express nos permitirá separar los endpoints “comunes” en entidades separadas que fungirán como “mini aplicaciones”, las cuales tomarán peticiones que concuerden con dicho endpoint y así redireccionarse a 
  esta mini aplicación. De esta manera, nuestro código resultará más organizado, y las diferentes entidades tendrán aislado el comportamiento interno, como configuraciones, middlewares, etc.
  
  > ¿Cómo aplicar un router? Primero recordemos la estructura de nuestro proyecto, hasta el momento, sabemos que la estructura básica de nuestro proyecto consiste en la distribución como lo indica la imagen: una carpeta donde vive el 
    proyecto, dentro una carpeta src donde vivirá nuestro código, y nuestro servidor dentro.
    Despues, agregaremos una carpeta “routes” donde vivirán nuestros diferentes routers (Nota que app.js se queda fuera de routes, pero sigue dentro de src).

- Servicio de archivos estáticos con Express: 
   ✓ Nuestro servidor tiene la posibilidad de alojar recursos que pueden ser visibles para el cliente de manera directa.
   ✓ Podemos configurar una carpeta para que el usuario pueda acceder y ver dichos recursos de manera directa sólo con acceder a la ruta donde se encuentra ubicada.
   ✓ En este curso y en proyectos profesionales podrás encontrar estos archivos en la carpeta “public”, haciendo referencia como dice el nombre, a recursos públicos de fácil acceso para el cliente.
  
  Los dos casos principales para los cuales encontrarás el uso de esta carpeta “public” para archivos estáticos son:
   ✓ Cuando necesitemos alojar imágenes y servirlas directamente al cliente.
   ✓ Cuando necesitemos alojar una página web en todos sus sentidos: html, css, js. En esta clase haremos una página sencilla para mostrar el alcance de public.

- ¿Cómo convertir una carpeta en un recurso estático? 
  Para poder utilizar los recursos de una carpeta de manera estática, basta conque en el servidor especifiquemos como “express.static” dicha carpeta con la siguiente sintaxis: 
                                                               app.use(express.static('public'));
  Indicamos que, todo lo que viva en la carpeta public, podrá ser accedido directamente desde la carpeta public. A continuación podemos cargar los archivos que queramos en el directorio public:
  http://localhost:3000/hello.html
  http://localhost:3000/images/kitten.jpg
  Nota: Express busca los archivos relativos al directorio estático, por lo que el nombre del directorio estático no forma parte del URL.
  
  > Prefijo virtual: Para crear un prefijo virtual (donde el path de acceso no existe realmente en el sistema de archivos) para los archivos servidos por express.static, debemos especificar un path de acceso de montaje para el directorio 
    estático:  app.use('/static', express.static('public'));
    Así podemos cargar los archivos que hay en el directorio public desde el prefijo /static.
    http://localhost:3000/static/hello.html
    http://localhost:3000/static/images/kitten.jpg
    
  > Path absoluto: El path que se proporciona a la función express.static es relativo al directorio desde donde inicia el proceso node. Por eso si ejecutamos la aplicación Express desde cualquier otro directorio, es más seguro utilizar el 
    path absoluto del directorio al que desea dar servicio:   app.use('/static', express.static(__dirname + '/public'))
    
- middleware: Operación intermedia que ocurre entre la petición a la base de datos y la entrega del documento o los documentos correspondientes. 
  Funciones que se colocan en medio de la ruta y el callback (req, res) que se ejecutarán antes de comenzar a procesar la petición.
  Cada vez que utilizamos un app.use estamos utilizando un middleware. Éstas son operaciones que se ejecutan de manera intermedia entre la petición del cliente, y el servicio de nuestro servidor.
  Como lo indica el nombre: “middleware” hace referencia a un intermediario, siempre se ejecuta antes de llegar al endpoint que corresponde. los middlewares se ejecutan EN ORDEN, eso quiere decir que, si algún middleware depende de que se 
  haya realizado otra operación ejecutada por un middleware previo, los coloquemos en cascada según prioridad. Podemos utilizar un middleware para:
    ✓ Dar información sobre las consultas que se están haciendo (logs) 
    ✓ Autorizar o rechazar usuarios antes de que lleguen al endpoint (seguridad) 
    ✓ Agregar o alterar información al método req antes de que llegue al endpoint (formato) 
    ✓ Redireccionar según sea necesario (router) 
    ✓ En ciertos casos, finalizar la petición sin que llegue al endpoint (seguridad)
    
- Tipos de middleware: Una aplicación Express puede utilizar los siguientes tipos de middleware:
  ✓ Middleware a nivel de aplicación
  ✓ Middleware a nivel endpoint
  ✓ Middleware a nivel del Router
  ✓ Middleware de manejo de errores
  ✓ Middleware incorporado
  ✓ Middleware de terceros
  
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        
                                                       
                                                                                                                   Multer  

- Middleware de carga de archivos: MULTER Middleware desarrollado para poder realizar carga de archivos dentro de las peticiones, con el fin de que el cliente pueda manejar archivos como imágenes, vídeos o documentos; dentro de una petición.
  En ocasiones el cliente necesitará subir una imagen, un vídeo o un archivo, según sea nuestra aplicación, ello nos lleva a configurar nuestro servidor para soportar estos archivos y poder almacenarlos en donde nosotros le indiquemos. Al
  ser de terceros, necesitaremos instalarlo para poder utilizarlo. 
    1) MULTER es una dependencia de terceros, de manera que, al igual que express, necesitaremos instalarlo dentro de nuestro package.json
    2) Una vez que tenemos MULTER instalado, podemos importarlo en nuestro proyecto y configurarlo donde lo necesitemos (puede ser directamente en app, o bien se recomienda hacerlo en un archivo al mismo nivel de app llamado “utils”) Contar 
       con un uploader externo a app.js, brindará más dinamismo al momento de utilizarlo, ya que podemos colocarlo en el router que necesitemos y no necesariamente instanciarlo a nivel general
    3) Una vez que nuestro uploader está listo para utilizarse, podemos importarlo en el router que necesitemos y colocarlo en la ruta donde lo necesitemos, recuerda que, al ser un middleware, éste va enmedio de la ruta y de la función 
       callback (req,res).    app.post("/", uploader.single("file"), function(request, response){}
     
       Podemos utilizar el uploader de dos formas principalmente:
         ✓ uploader.single(‘nombre del campo’): permitirá subir un único archivo, su resultado estará en req.file
         ✓ uploader.array(‘nombre de campos’): permitirá subir múltiples archivos, su resultado estará en req.files
   
   Cuando subimos un archivo (imagen, vídeo, etc), estamos hablando de un flujo de datos. lo cual no puede plasmarse en un JSON. Cuando enviamos información a un endpoint donde sabemos que utilizamos MULTER, debemos enviarlo como FormData, 
   no como JSON.
   
   
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Redux

- configureStore();
- createSlice();
- useSelector: Read data from the store with the useSelector hook
- useDispatch: Get the dispatch function with the useDispatch hook, and dispatch actions as needed                                                                                                                   
                                                                                                                   
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Websocket
                                                                                                                   
- Websocket: es un protocolo de comunicación basado en TCP para poder establecer esa conexión entre el cliente y el servidor, justo como sabemos, es el mismo objetivo que cubre HTTP.  
  A pesar de que websocket y HTTP son protocolos como lo mencionamos anteriormente, websocket tiene una característica muy importante: Su protocolo TCP establece dos endpoints de comunicación, a cada endpoint se le conoce como socket.
  El contar con estos dos sockets permitirá establecer una comunicación bidireccional entre el cliente y el servidor. La comunicación bidireccional implica: 
   ✓ Que el cliente puede obtener recursos del servidor cuando lo solicite (como en HTTP).
   ✓ Que el servidor pueda entregar información al cliente sin necesidad de que el cliente haga una petición.                      
   
  Websockets es un protocolo excelente para esta situación ya que:  
   ✓ El cliente no tendrá que estar actualizando la página constantemente 
   ✓ En cuanto el servidor reciba una actualización de una nueva puja, actualizará a todos los clientes conectados, permitiendo dar información en tiempo real
   ✓ Una vez que termina la subasta, el socket se cierra y el servidor deja de notificar innecesariamente al cliente.

- Hanshake: Acuerdo entre cliente y servidor que permite establecer una conexión abierta entre ambos puntos.      
   
- Funcionamiento de un Websocket: Primero, el cliente tiene que enviar una solicitud HTTP llamada Handshake (apretón de manos). Este apretón de manos será un “acuerdo” o “contrato” de confianza para que el servidor pueda actualizar al 
  cliente sin que éste se lo pida. El servidor recibe la petición de Handshake y procede a “responderle el saludo”, a esto se le llama “Abrir conexión”.
  A partir de este punto, el canal queda abierto de manera bidireccional, por lo que el cliente se puede comunicar con el servidor cuando quiera y viceversa. La comunicación es “persistente” hasta que alguno de los dos lados decida cerrar el 
  canal de comunicación.
   
- El protocolo Websocket: principios   
  ✓ Websocket permitió por primera vez acceder a una web de forma dinámica en tiempo real.
  ✓ Basta con que el cliente establezca una conexión con el servidor, que se confirma ediante el llamado apretón de manos o Websocket Protocol Handshake.
  ✓ Con él, el cliente envía al servidor todos los datos de identificación necesarios para el intercambio de información.
  ✓ El canal de comunicación queda “abierto” tras el handshake.
  ✓ El servidor puede activarse por sí mismo y poner toda la información a disposición del cliente, sin que este tenga que pedírselo. Si dispone de nueva información, se lo comunica al cliente, sin necesidad de recibir una solicitud 
    específica para ello.
  ✓ Las notificaciones push de las páginas web funcionan según este principio.
  
- Websocket y comparación con HTTP: HTTP no es reemplazo de Websocket, ni websocket es reemplazo de HTTP. Ambos son complementos que se pueden utilizar en conjunto, con el fin de hacer sistemas completos y complejos.
  HTTP --> Son peticiones al servidor que esperan una respuesta. Como un walkie talkie. 
  Websocket --> Es un canal abierto entre servidor y cliente. Como una llamada telefónica.
  HTTP --> Se solicita información y se espera una respuesta. Ej: un formulario de login
  Websocket --> Se usa para comunicación en tiempo real. Ej: un chat
  HTTP --> Se usa para consumir APIs y recursos web Se usa para escuchar información en tiempo real
  Protocolo HTTP Es un protocolo de comunicación
  HTTP --> Conexión de una sola vía 
  Websocket --> Conexión de doble vía
  HTTP --> No sustituye a WebSockets 
  Websocket --> No sustituye a HTTP

- Socket.io: 
  ✓ Es una biblioteca de Javascript para poder implementar los sockets anteriormente mencionados.
  ✓ Debido al funcionamiento que hemos visto en clase. socket.io debe instanciarse tanto de lado del cliente, como del servidor.
  ✓ Permite utilizar todo el potencial mencionado de los websockets, y cuenta con una API casi idéntica para cliente y para servidor. 
  ✓ Socket.IO utiliza principalmente el protocolo Websocket proporcionando la misma interfaz.
  ✓ Se puede usar como un contenedor para Websocket aunque proporciona muchas más funciones, incluida la transmisión a múltiples sockets, el almacenamiento de datos asociados con cada cliente y E/S asíncronas.
  ✓ Se puede instalar con npm.
  ✓ Fiabilidad: Las conexiones se establecen incluso en presencia de:
  ✓ proxies y balanceadores de carga.
  ✓ firewall personal y software antivirus.
  ✓ Soporte de reconexión automática: A menos que se le indique lo contrario, un cliente desconectado intentará siempre volver a conectarse, hasta que el servidor vuelva a estar disponible.
  ✓ Detección de desconexión: Se implementa un mecanismo de heartbeat, lo que permite que tanto el servidor como el cliente sepan cuando el otro ya no responde.
  ✓ Soporte binario: Se puede emitir cualquier estructura de datos serializable, que incluye:
  ✓ ArrayBuffer y Blob en el navegador
  ✓ ArrayBuffer y Buffer en Node.js


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   MONGODB
                                                                                                                   
- Usar mongodb en la terminal: 
  1) correr .\mongod.exe  en powershell
  2) Abrir otra ventana de powershell y copiar el siguiente link --> cd 'C:\Program Files\MongoDB\Server\7.0\bin'
  3) Despues ejecutar --> .\mongos.exe                                                                                                            

- Base de datos: Una base de datos no es más que una recopilación organizada de datos. Dichos datos deben compartir algún contexto y son almacenados con poder convertirse posteriormente en información útil para utilizarse dentro de algún
  sistema. La base de datos sólo se encargará de almacenar dichos datos.
  Algunas de las cosas que podemos señalar sobre la utilidad de una base de datos son:
   ✓ Almacenamiento más seguro: Los datos que viven en una base de datos no son modificables directamente, por lo que éstos no pueden ser cambiados tan fácilmente.
   ✓ Segmentación de datos: Podemos separar los datos en “contextos”, permitiendo así tener separados los datos de interés. 
     ○ Separar clientes potenciales de clientes sólo interesados. 
     ○ Separar productos existentes de productos fuera de stock 
     ○ Separar diferentes usuarios por género, nacionalidad, plan, etc.
   ✓ Gestión sencilla una vez configurada: Una vez que hemos definido los esquemas principales de nuestra base de datos, podremos realizar operaciones sobre estos datos como:
   ✓ Filtrar
   ✓ Ordenar
   ✓ Buscar datos específicos.
   ✓ Actualizar un conjunto de datos sin afectar o tocar otros datos.

- Modelo relacional: Gestión de datos que consiste en representar éstos como tablas relacionadas con el fin de brindar una estructura de relación sólida entre ellos.
- Modelo no relacional: Gestión de datos flexible que sustituye las tablas relacionadas, por colecciones, garantizando facilidad y dinamismo en el manejo de los datos.
- Base de datos relacional: se refiere a estructura, elación, dependencia y de cambio controlado.
- Base de datos no relacional:  refiere a algo enos estructurado, con relaciones y ependencias más flexibles, y de cambios umamente rápidos.

- Inconsistencia de datos

- CRUD: es un acrónimo que hace referencia a las cuatro operaciones fundamentales de una base de datos:
  ✓ C : Create (Crear un dato, insertarlo en la base de datos)
  ✓ R : Read (Leer un dato, mostrarlo al cliente)
  ✓ U : Update (Actualizar un dato, cambiar su información interna)
  ✓ D : Delete (Eliminar un dato, removerlo de nuestra colección.
  
  
- Comandos de apoyo
  ✓ show dbs : Muestra las bases de datos existentes.
  ✓ use <db name>: Crea una nueva base de datos (en caso de no existir) y se posiciona sobre ella
  ✓ db: Muestra en qué base de datos estamos posicionado.
  ✓ show collections: Muestra todas las colecciones disponibles en la base de datos posicionada.
  ✓ db.createCollection(name): Crea una colección en la base de datos posicionada.
  ✓ db.dropDatabase(): Elimina la base de datos actual.
  ✓ db.collection.drop(): Elimina la colección de la base de datos posicionada.

- Primeros comandos CRUD: CR
  ✓ db.collection.insertOne(doc) : Agrega un nuevo documento a la colección seleccionada.
  ✓ db.collection.insertMany(docs): Agrega múltiples documentos a la colección seleccionada (dado un arreglo de documentos).
  ✓ db.collection.findOne(opt): Busca un elemento que cumpla con los criterios de búsqueda (opt), devuelve el primer documento que cumpla con dicho criterio.
  ✓ db.collection.find(opt):Devuelve todos los documentos que cumplan con dicho criterio.
  ✓ db.collection.find(opt).pretty(): Añadido para hacer más presentables los resultados de un find()    

- Conteo de datos: Los comandos de conteo para determinar el número de documentos en una colección son
  ✓ db.collection.estimatedDocumentC count() Cuenta el estimado más próximo al número de documentos según su metadata.
  ✓ db.collection.countDocuments(opt) Cuenta los documentos que cumplan con el criterio definido en las opciones (opt).
  
- opt (options): agregando opciones
  En muchas consultas encontramos el elemento (opt), esto hace referencia a las opciones de filtros de búsqueda que podemos realizar al momento de buscar un valor, la sintaxis elemental de un opt es: {propiedad:valor}
                                                                             db.users.find({gender: "M})
        
- Filtros: Las búsquedas del mundo real no siempre requieren que un valor sea igual a otro. En ocasiones necesitamos que sea menor, mayor, diferente de, entre otras cosas. Los filtros pueden agregarse dentro de los elementos de criterio 
  (opt) con ayuda del símbolo $, además, podemos agregar más de un filtro para asegurarnos que el documento se ajuste a criterios muy específicos. Entonces, la sintaxis general será:
                                                                             db.coll.find( {key: {$operator: val}} )
                                                                             
- MongoDB: Operadores para Filtros de Query
  ✓ $and: Realiza operación AND -> sintaxis: {$and: [ {},{} ] }
  ✓ $or: Realiza operación OR -> sintaxis: {$or: [ {},{} ] }
  ✓ $lt: Coincide con valores que son menores que un valor especificado.
  ✓ $lte: Coincide con valores menores o iguales a un valor especificado.
  ✓ $gt: Coincide con valores mayores a un valor especificado.
  ✓ $gte: Coincide con valores mayores o iguales a un valor especificado.
  ✓ $ne: Coincide con valores que no son iguales a un valor especificado.
  ✓ $eq: Selecciona los documentos que son iguales a un valor especificado.                                                                                        
  ✓ $exists: Selecciona los documentos según la existencia de un campo.
  ✓ $in: Selecciona los documentos especificados en un array. sintaxis: {key:{$in: [array of values] } }
  ✓ $nin: Coincide con ninguno de los valores especificados en un array.
  ✓ $size: Coincide con el número de elementos especificados.
  ✓ $all: Coincide con todos los valores definidos dentro de un array.
  ✓ $elemMatch: Coincide con algún valor definido dentro del query.                                                                                             
  
- MongoDB: Búsqueda Avanzada
  ✓ db.coll.distinct( val ) devuelve un array con los distintos valores que toma un determinado campo en los documentos de la colección.
  ✓ db.coll.find({doc.subdoc:value}) Se utiliza para filtrar subdocumentos.
  ✓ db.coll.find({name: /^Max$/i}) filtra utilizando expresiones regulares
  
- Proyecciones: En ocasiones no necesitamos toda la información de un documento. Si tenemos un documento con 100 propiedades, podemos definir sólo las propiedades que queremos obtener.
  Una proyección se incluye al momento de hacer una búsqueda, (siempre como segundo argumento) y es el equivalente a decirle a la base de datos: “sólo necesito ésto”
  Así, podríamos decir db.users.find({},{name:1}); Lo cual indica que, el campo “name” es el único que necesitamos obtener por parte del documento, ahorrándonos espacio y complejidad en el resultado
  
- Sort: Sirve para poder hacer un ordenamiento de la información. El ordenamiento se define con 1 o -1 para hacer el ordenamiento ascendente o descendente respectivamente.
  La sintaxis es: db.collection.find().sort({val_A:1,val_B:-1})
  La razón por la cual podemos agregar múltiples valores de ordenamiento, es en caso de que dos documentos tengan el mismo valor, podamos ordenarlos bajo otro criterio  
  
- Skip: Omite el número de documentos indicados:Podemos usarlo cuando hagamos paginaciones, cuando necesitemos ignorar un valor que sabemos que es innecesario, etc. Su sintaxis es: .skip(offset)
- Limit: Limita el número de documentos devueltos. De manera que podamos hacer diferentes niveles de paginación (Tu página puede devolver 5 elementos por página, o bien 100, tú decides). Su sintaxis es: .limit(num)  
  
- CRUD (update): Las operaciones Update se pueden realizar de dos maneras: Actualizar un documento, o actualizar múltiples documentos.
  ✓ db.collection.updateOne(query,update,option)
  ✓ query: sirve para filtrar qué elementos actualizar (usa los filtros iguales al find)
  ✓ update: Apartado para indicar qué actualizar de los documentos que cumplen con el filtro. Update tiene sus propios operadores como $set, $unset, $inc, $rename, $mul, $min, $max
  ✓ option: Opciones a tomar en cuenta para la actualización (como upsert, que inserta el valor en caso de que el documento a actualizar ni siquiera exista).
  ✓ db.collection.updateMany(query,update,options) Actualiza múltiples documentos que cumplan con el criterio.
  
- CRUD (Delete): Nuestra última operación es para eliminar datos, si bien hay muchas variantes de una eliminación, sólo veremos las dos principales.
✓ db.collection.deleteOne({key:val}) : Elimina sólo el primer elemento que cumpla con el criterio, se usa principalmente para encontrar identificadores específicos. Se recomienda no utilizar si somos conscientes de que el valor a buscar no 
   es repetido.
✓ db.collection.deleteMany({key:val}) : Elimina todos los documentos que cumplan con el criterio, se usa cuando sabemos que más de un valor va a contar con ese valor y necesitamos hacer una limpieza general.  

- Mongoose (indexing): Técnica utilizada para colocarse en una propiedad de un documento, permite realizar búsquedas más rápidas cuando se involucra a dicha propiedad
  Es un recurso utilizado en MongoDB para poder hacer consultas mucho más rápidas. Éste nos permitirá tener una referencia previa al momento de buscar un documento, con el fin de evitar recorrer toda la colección, 
  documento por documento, hasta encontrar dicho valor. El índice se asocia a un atributo del documento y permite que las búsquedas se hagan desde puntos específicos, evitando el recorrido completo de la colección.
  
  > Tipos de indices: Prever un buen plan de indexación evitará problemas de lentitud en las consultas y se considera una práctica necesaria a nivel enterprise, al momento de configurar los schemas de nuestros distintos modelos.
     ✓ compound: Se utiliza cuando requerimos utilizar más de una indexación y queremos definir el orden con el cual se realiza el ordenamiento (ordenando con 1 para ascendente y -1 para descendente, igual que un sort: {campo: 1 , campo: -1}
     ✓ multikey: Se utiliza cuando requerimos hacer una indexación de valores que se encuentran de manera interna en un array.
     ✓ text: Se utiliza para poder basarse en búsquedas de palabras “específicas” con el fin de poder tomar referencia de un texto a partir de dichas palabras.
     ✓ geospatial: Se utiliza para almacenar data geoespacial de dos coordenadas, utiliza una esfera 2d para poder trabajar los datos. 

  > population: Operación que permite transformar la referencia de un documento en su documento correspondiente en la colección indicada.
    Una population implica obtener un documento referenciado dentro de otro documento, con el fin de obtener ambos en una sola búsqueda. Consiste en almacenar el id de un documento, como propiedad de otro documento. A esto se le     
    conoce como “referencia”. Populate hace referencia a “poblar” de un id a un documento completo. (referencia a la población humana).
    Algunas cosas a considerar antes de comenzar con su uso:
      ✓ populate es un método propio de mongoose, por lo que tenemos que instalarlo.
      ✓ Hay que tener siempre claro el nombre de la propiedad dentro del objeto, así también como la referencia de la colección, para poder hacer un populate efectivo.
      ✓ Recuerda no guardar directamente el valor a referenciar en el _id, sino asignarle otro nombre (se profundizará en el ejemplo)

  > Configurando una population por default: Para poder “poblar” el resultado de la operación find() del estudiante y obtener los cursos, fue necesario llamar a “populate” después de la operación. Sin embargo, tener que colocar el populate 
    puede resultar molesto si utilizamos constantemente el modelo de estudiante. Mongoose tiene la posibilidad de definir “middlewares” para sus documentos y modelos con el fin de automatizar operaciones que consideremos recurrentes. 

    En esta ocasión utilizaremos un middleware conocido como “pre”. ¿Qué hacer antes de devolver la data?
    Middleware utilizado para realizar una operación “antes” de devolver el resultado de la operación principal. Se ejecutará antes de finalizar el procesado y entrega de la operación. Éste es compatible con la operación find que 
    acostumbramos utilizar, y se entenderá como: ¿Qué deseo que se haga con este documento antes de devolver el resultado de la búsqueda? En nuestro caso particular, lo que buscamos es realizar una population antes de recibir el documento. 
    

- Mongoose (aggregation): Consiste en la realización de múltiples operaciones, eneralmente sobre múltiples documentos. ueden utilizarse para:              https://stackoverflow.com/questions/24714166/full-text-search-with-weight-in-mongoose
    ✓ Agrupar documentos con base en un criterio específico.
    ✓ Realizar alguna operación sobre dichos documentos, con el fin de obtener un solo resultado.
    ✓ Analizar cambios de información con el paso del tiempo.

  > Funcionamiento: Los aggregation pipelines consistirán en un conjunto de pasos (stages), donde cada paso corresponderá a una operación a realizar. Podemos definir tantas stages como necesitemos con el fin de llegar a los resultados 
    esperados. Los documentos resultantes de la stage que finalice, se utilizan como “input” de la siguiente stage, y así sucesivamente hasta llegar al final. 
    Un ejemplo de un pipeline de aggregation puede ser: 
    1. Primero filtra los documentos que tengan un valor x mayor a 20 2. Luego ordénalos de mayor a menor 3. Luego en un nuevo campo devuelve el valor máximo 4. Luego en un nuevo campo devuelve el valor mínimo 5. Luego en un nuevo campo 
       devuelve la suma total de todos los documentos

  > Principales stages disponibles en un aggregation pipeline
    ✓ $count : Cuenta el número de documentos disponibles que se encuentren en la stage actual.
    ✓ $group: Permite agrupar los documentos disponibles en nuevos grupos según un criterio especificado. cada grupo cuenta con un _id nuevo, además de los valores acumulados \
    ✓ $limit: Limita el número de documentos que saldrán de dicha stage.
    ✓ $lookup: Permite realizar un “left join” (combinación de campos), de una colección de la misma base de datos a los documentos de la stage actual.
    ✓ $set / $addFields : Agregan una nueva propiedad a los documentos que se encuentren en dicha stage.
    ✓ $skip: Devuelve sólo los documentos que se encuentren después del offset indicado.
    ✓ $sort: Ordena los documentos en la stage actual.
    ✓ $match -->  Devuelve sólo los documentos que cumplan con un criterio de búsqueda, podemos colocar filtros comunes aquí. Filters the document stream to allow only matching documents to pass unmodified into the next pipeline stage. 
      It uses standard MongoDB queries. For each input document, outputs either one document (a match) or zero documents (no match).
    ✓ $group --> Groups input documents by a specified identifier expression and applies the accumulator expression(s), if specified, to each group. Consumes all input documents and outputs one document per each distinct group. The output 
       documents only contain the identifier field and, if specified, accumulated fields.
    ✓ $sum --> Returns a sum of numerical values. Ignores non-numeric values.
    ✓ $first --> Returns the result of an expression for the first document in a group of documents. Only meaningful when documents are in a defined order.
    ✓ $sort ---> Reorders the document stream by a specified sort key. Only the order changes; the documents remain unmodified. For each input document, outputs one document.
    ✓ $push --> returns an array of all values that result from applying an expression to documents.
    ✓ $$ROOT --> significa los resultados del stage anterior
    ✓ $project --> Reshapes each document in the stream, such as by adding new fields or removing existing fields. For each input document, outputs one document. Takes a document that can specify the inclusion of fields, the suppression of 
       the _id field, the addition of new fields, and the resetting of the values of existing fields. Alternatively, you may specify the exclusion of fields.
    ✓ $merge --> Escribe los resultados del pipeline en una colección. Debe ser la última stage del pipeline para poder funcionar.
       Writes the resulting documents of the aggregation pipeline to a collection. The stage can incorporate (insert new documents, merge documents, replace documents, keep existing documents, fail the operation, process documents with a 
       custom update pipeline) the results into an output collection. IT MUST BE USED BY USING A $project BEFORE.    
    
    
- Mongoose (Paginate): Pagination is the process of separating print or digital content into discrete pages. For print documents and some online content, pagination also refers to the automated process of adding consecutive numbers to 
  identify the sequential order of pages.                                  https://stackoverflow.com/questions/5539955/how-to-paginate-with-mongoose-in-node-js
  
  > mongoose-paginate-v2 is a pagination library having a page wrapper. The main usage of the plugin is you can alter the return value keys directly in the query itself so that you don't need any extra code for transformation.                                    

  > Model.paginate([filter], [options], [callback])
    ✓ docs: Los documentos devueltos en la página
    ✓ totalDocs: Los documentos totales de la consulta realizada.
    ✓ limit: Límite de resultados por página.
    ✓ page: Página actual en la que nos encontramos
    ✓ totalPages: Páginas totales que pueden ser solicitadas en la búsqueda.
    ✓ hasNextPage: Indica si es posible avanzar a una página siguiente.
    ✓ nextPage: Página siguiente en la búsqueda
    ✓ hasPrevPage: Indica si es posible retroceder a una página anterior.
    ✓ prevPage: Página anterior en la búsqueda.
    ✓ pagingCounter: Número de documento en relación con la página actual      
    

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Cookies, auth, JWT
    
    
- Cookies: Cuando desarrollamos un sitio web, tenemos que contemplar que la forma de interactuar de un cliente suele ser diferente, entonces es importante tener algún recurso para saber información sobre ciertos detalles de información y 
  comportamiento de un cliente, para que el servidor pueda usar eso a su favor. Para seguir un rastro de los clientes de nuestro sitio web y poder obtener un poco más de información de contacto y/o de comportamiento sobre los clientes que 
  nos visitan, se utilizan las cookies.
  Una cookie es un pequeñísimo archivo de texto donde podremos almacenar información dentro del navegador, de manera que pueda viajar entre las peticiones y sirva como un ligero contenedor de información necesaria para poder procesar ciertas 
  peticiones. Las cookies viven en el navegador, por lo que son fácilmente accesibles por múltiples elementos externos. Por ningún motivo guardamos información sensible en una cookie. Nunca guardamos información de métodos de pago, 
  contraseñas, ni cualquier dato que pudiera comprometer la seguridad del cliente. Algunos de los datos que se suelen guardar en una cookie son:
    ✓ Nombres de usuario
    ✓ IDs de sesiones (que abarcaremos más adelante)
    ✓ Preferencias de navegación para tu página. 
  
  > Rastros que suele dejar un usuario al navegar en la web:
    ~ El cliente hace login --> La cookie almacena el id de la sesión
    ~ El cliente pone el fondo de la página en modo “obscuro” --> La cookie almacena: ✓ Id de sesión ✓ preferencias de configuración en página 
    ~ El cliente busca --> productos específicos --> La cookie almacena: ✓ Id de sesión ✓ preferencias de configuración en página ✓ Búsquedas recientes
    
  > Caracteristicas: 
     ✓ A las cookies se les puede configurar un tiempo de vida. Una vez finalizado el mismo, la cookie se elimina del navegador.
     ✓ Al almacenarse del lado del cliente, el espacio con el que se cuenta es limitado, por lo que se recomienda elegir de forma adecuada lo que se vaya a guardar como cookie.
     ✓ Podemos asignarles claves secretas para poder aumentar la seguridad
     ✓ Viven en el navegador, así que no guardamos datos sensibles
  
  > Firmar una cookie: Como las cookies son almacenadas en el navegador, pueden llegar a ser alteradas mucho más fácilmente que si ésta viviera en el servidor. Se necesita agregar un factor de seguridad para que la cookie se “invalide” en 
    caso de que haya sido modificada. No podemos evitar que alguien externo altere la cookie, pero sí podemos indicar que, en caso de que la cookie ya no sea exactamente idéntica a la generada, entonces la pase como cookie inválida.

  > Session: Una sesión es un vínculo que se genera cuando el cliente conecta con un servidor, este vínculo se representa por una sessionId, la cual se guarda en el navegador como identificador de la sesión. 
  > Storage: Lugar donde se almacenan las sesiones del lado del servidor. Es donde se consultan y comparan las sessionId.
  > MemoryStorage : Almacenamiento por defecto de sesiones por express-session. Si el servidor cae, las sesiones caen.
  > FileStorage: Almacenamiento alternativo que permite guardar las sesiones en archivos en una carpeta indicada. Cuando el servidor cae, aún puede consultar las sesiones de los archivos después.
  > MongoStorage: Almacenamiento alternativo de sesión que permite guardar las sesiones en una base de datos. Es más accesible ya que tiene un sistema de autogestión que permite limpiar las sesiones expiradas.    
    
- Autorizacion: Es el proceso por el cual el servidor decide si, a pesar de las credenciales que tienes, tienes permitido acceder a un recurso o no. Es decir, que autorizar no hace referencia a que el servidor no sepa quién eres.  

- Autenticación: Para que un cliente pueda autenticarse, debe existir un registro previo almacenado en algún lado. El cliente envía un identificador (como un email) y el servidor lo buscará en su base de datos para saber si sí existe 
  previamente. En caso de que sí, podrá responder con sus credenciales completas (no sensibles). En caso de que un cliente intente autenticarse antes de haber generado un registro, el servidor no lo encontrará en la base y no habrá 
  credenciales por devolverle.
    
- Passport: Generador de estrategias de autenticación y autorización, para mantener un código limpio, estructurado y altamente configurable. Se puede utilizar y configurar múltiples estrategias de autenticación y autorización con passport  
    ✓ Passport local siempre requerirá dos cosas: username y password. Si passport no encuentra alguno de estos dos elementos, devolverá un error y no permitirá proceder con la estrategia
    ✓ Podemos cambiar el campo “username” para que tome el campo que nosotros queramos tomar como identificador, en este caso a nosotros no nos interesa nuestro username, realmente nos interesa el correo electrónico, así que podemos 
      alterarlo con {usernameField: ‘valor’}
    ✓ Passport utiliza un callback “done”, el cual se resuelve de la siguiente manera:
      ○ El primer parámetro de done es el error, si pasamos done(null) indicamos que no hay error.
      ○ El segundo parámetro debe ser el usuario generado, por lo tanto, para devolver un usuario, hacemos done(null, user).
      ○ Si pasamos done(null, false) indicamos que no hay error, pero el usuario no estará disponible.
    ✓ Cada estrategia que queramos configurar en passport es un middleware por sí solo, así que utilizaremos el elemento passport.use() para configurar diferentes middlewares/estrategias

  > Serializar y deserializar: //Estas funciones permiten a Passport.js manejar la información del usuario durante el proceso de autenticación, serializando y deserializando los usuarios para almacenar y recuperar información de la sesión. 
    Son esenciales cuando se implementa la autenticación de usuarios en una aplicación Node.js utilizando Passport.js
    ✓ Para restaurar el estado de autenticación a través de solicitudes HTTP, Passport necesita serializar usuarios y deserializarlos fuera de la sesión. Esto se hace de modo que cada solicitud subsiguiente no contenga las credenciales del 
      usuario anterior.
    ✓ Se suele implementar proporcionando el ID de usuario al serializar y consultando el registro de usuario por ID de la base de datos al deserializar. 
    ✓ Los métodos que proporciona Passport para esto son serializeUser y deserializeUser.
    ✓ El código ejemplo de ambos métodos se muestra a continuación.
    ✓ Se puede ver que el método serializeUser utiliza el ID del usuario y el deserializeUser utiliza el objeto de usuario, como lo mencionamos antes.
    
- JsonWebToken (JWT): Es un estándar que soluciona el problema de consultas y escalabilidad que presenta session. Este se basa en encriptar la información del usuario en un token que se guardará del lado del cliente, y el cliente lo enviará 
    al servidor en cada consulta, para poder desencriptar y obtener la información de usuario interna.
    Es mecanismo para poder propagar entre dos partes, y de forma segura, la identidad de un determinado usuario, además con una serie de claims o privilegios. Estos privilegios están codificados en objetos de tipo JSON, que se incrustan 
    dentro de del payload o cuerpo de un mensaje que va firmado digitalmente. Un token tres partes:
    ~ Header: encabezado dónde se indica, al menos, el algoritmo y el tipo de token, que en el caso del ejemplo anterior era el algoritmo HS256 y un token JWT.
    ~ Payload: donde aparecen los datos de usuario y privilegios, así como toda la información que queramos añadir, todos los datos que creamos convenientes. (tanto el Header como el Payload son texto plano que se codificara, pero No se 
      encriptara)
    ~ Signature: una firma que nos permite verificar si el token es válido, y aquí es donde radica el quid de la cuestión, ya que si estamos tratando de hacer una comunicación segura entre partes y hemos visto que podemos coger cualquier 
      token y ver su contenido con una herramienta sencilla. This is typically a hash of the header and payload sections of the JWT. The algorithm which is used to create the signature is the same algorithm mentioned in the header section of 
      the JWT. Signature is used to validate that the JWT token wasn’t modified or changed during transit. It can also be used to validate the sender. The header and Payload section of the JWT is always Base64 encoded.
      
    Es una implementación sin estado para poder mantener el ciclo de vida de la sesión de un usuario, sin el almacenamiento que este implica. Funciona de una manera diferente en session:
      ✓ El servidor generará un token con la información del usuario y la enviará al navegador.
      ✓ El navegador (front) almacenará dicho token y procederá a enviarlo en cada request por medio de los headers.
      ✓ El servidor recibe las peticiones, busca el token de jwt en los headers. Si lo encuentra, podrá proceder, si no, entonces requerirá autenticación nuevamente.
   
   La necesidad de almacenar las sesiones de lado del servidor o de una base de datos genera conflictos:
     ✓  Almacenamiento innecesario: Almacenar por miles, cientos de miles, o millones de usuarios, puede ser problemático a nivel almacenamiento.
     ✓ Tráfico saturado: Al vivir en una base de datos, session debe conectar con ella siempre que haya que consultar una sesión. Puede implicar detalles de rendimiento o requerir particiones de más. 
   
   JWT delega responsabilidad a cada cliente: Para aligerar el peso de la operación, el servidor puede otorgar el token de acceso al cliente y éste almacenarlo dentro del navegador en una cookie . Así, el cliente tiene la responsabilidad de 
   enviar sus credenciales con los datos de la sesión a manera de stateless. El servidor solo necesita descifrar el token para poder acceder a las credenciales del usuario . Esto le permite al servidor ser más ágil.
   
  > Working principle: When a user logs in or attempts to access a protected resource, the server generates a JWT after successful authentication. The client then stores this token, usually in local storage or a cookie. For every subsequent 
    request that requires authentication, the client sends the JWT in the request headers. The server validates the token by checking the signature and decoding the payload to ensure the user’s authenticity and authorization.
    
  > Secret key: The secret key is combined with the header and the payload to create a unique hash. You are only able to verify this hash if you have the secret key. Secret key used for signing and verifying JWTs. It must be replaced with a 
   strong secret key in production
   
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Process & Child Process
                                                                                                                   
- Sobre los entornos: Seguramente, a estas alturas del desarrollo entenderás que un código no puede simplemente hacerse y llegar al cliente. Para que un código esté listo para llegar al cliente, es necesario que pase por diferentes fases.
  Sin embargo, para que estas fases se encuentren aisladas de las otras fases (no queremos que la fase de desarrollo tenga datos de producción, o que haya datos de producción en staging), necesitaremos crear entornos específicos para estas 
  fases. Nuestras variables cambiarán según el entorno.
  El primer uso radica en que una variable cambie según el entorno donde se esté corriendo, esto permite que pueda apuntar a una base de datos prueba o a una base de datos productiva con sólo cambiar el apuntador de dónde se está corriendo.
  Otro factor importante es el factor seguridad. Con las variables de entorno podemos ocultar la información sensible de nuestro código, como credenciales, claves de acceso, tokens, secrets, etc.                                                                                                                   
                                                                                                                   
- process: Cada vez que corremos un proceso en nodejs, éste genera un objeto llamado process, el cual contiene información referente a todo lo implicado con el proceso, cosas como:
    ✓ Uso de memoria 
    ✓ Id del proceso en el sistema operativo 
    ✓ En qué sistema operativo o plataforma está corriendo
    ✓ En qué entorno está corriendo. 
    ✓ Qué argumentos tiene el entorno.

 > Algunos elementos importantes de process
    ✓ process.cwd() : Directorio actual del proceso.
    ✓ process.pid : id del proceso en el sistema
    ✓ process.MemoryUsage() :
    ✓ process.env : Accede al objeto del entorno actual
    ✓ process.argv : Muestra los argumentos pasados por CLI (Los argumentos permiten iniciar la ejecución de un programa a partir de ciertos elementos iniciales)
    ✓ process.version : Muestra la versión del proceso (node en este caso)
    ✓ process.on() : Permite setear un listener de evento. Permitirá poner a nuestro proceso principal a la escucha de algún evento para poder ejecutar alguna acción en caso de que algo ocurra. (Listeners)
      ~ process.on('exit'); // Para ejecutar un código justo antes de la finalización del proceso.
      ~ process.on('uncaughtException'); //  Para atrapar alguna excepción que no haya sido considerada en algún catch
      ~ process.on('message'); // para poder comunicarse con otro proceso

    ✓ process.exit() : Permite salir del proceso. Cuando ejecutamos una salida con process.exit() como argumento, podemos enviar un código que sirve como identificador para el desarrollador sobre la razón de la salida
      Hay que conocer los códigos de salida para aber cómo utilizarlos. También podemos rear nuestros propios códigos. Algunos de los códigos importantes son:
        0 : proceso finalizado normalmente. 
        1 : proceso finalizado por excepción fatal 
        5 : Error fatal del motor V8. 
        9 : Para argumentos inválidos al momento de la ejecución.
     
 > arguments (commander): Commander es una librería para el manejo de argumentos. Permite realizar funciones como:
    ✓ Convertir flags directamente en booleanos
    ✓ Limitar sólo las flags configuradas (cualquier otra impide el procesamiento del programa)
    ✓ Colocar argumentos predeterminados.
      
- Child process: Existen casos en los que un proceso de node necesitará crear otro proceso para poder resolver una función de gran complejidad. Algunas operaciones requieren mucho procesamiento, como:
    ✓ Lectura de archivos enormes
    ✓ Consultas a bases muy complejas 
  Por lo que, para no bloquear las tareas actuales de, un servidor, por ejemplo, ocupamos separar esa tarea en otro subproceso.
  Existen diferentes formas para que un proceso de node pueda ejecutar otro proceso, hay cuatro operadores que pueden ser utilizados y manipulados de diferentes formas 
  https://www.freecodecamp.org/news/node-js-child-processes-everything-you-need-to-know-e69498fe970a/
    > fork(): 
    > spawn():
    > exec():
    > execFile():
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                                   Arquitectura de capas

- Definicion de aquitectura de capas: Es un patrón de diseño donde los módulos contemplados dentro de nuestro aplicativo son separados por “capas”. El nombre “capa” hace referencia a cada rol que debe cumplirse dentro de todo el aplicativo.                                                                                                                   

  > Responsabilidades: Cuando trabajamos con capas, entendemos que cada archivo debe cumplir una función específica, permitiendo así que, si llegase a ocurrir algún “error” o si llegase a requerirse modificación en algún punto, tengamos más 
    claro dónde debemos atacar esos cambios.
  > Capas base: En un sistema que trabaje con este modelo, es necesario contar con tres capas base:
     ✓ Capa de Modelo o Persistencia: Esta capa tiene por principal objetivo la conexión directa con el modelo de persistencia a trabajar, es decir, debe saber conectar con la persistencia en memoria, en archivos o en bases de datos. Todo 
       dependendiendo de cómo haya sido programada la capa. La capa de persistencia no debería realizar validaciones ni operaciones más allá del CRUD que corresponde a una capa de persistencia. Para modelos más complejos como Persistencias 
       en bases de datos, también es posible configurar operaciones transaccionales y Agregaciones en este mismo punto. 
     ✓ Capa de Vista o Renderización: La capa de renderizado o Vista, como indica su nombre, sólo tiene la función de tomar datos para poder ser renderizados. Esta capa es una de las más subjetivas en la arquitectura, pues si bien TODOS los 
       modelos requieren renderizar contenido, se hace de maneras muy diferentes. Renderizado, según sea el enfoque del equipo, también puede acceder a Persistencia sin necesidad de pasar por negocio, siempre y cuando ésta tenga como fin 
       único el de mostrar la información correspondiente. En ocasiones, también se suele contemplar la capa de renderizado fuera de la arquitectura interna y usar algún aplicativo externo (como enviar la info a React para que él la 
       renderice, que es lo más habitual).
     ✓ Capa de Controlador o Negocio: Esta capa tiene por principal objetivo la conexión directa con el modelo de persistencia a trabajar, es decir, debe saber conectar con la persistencia en memoria, en archivos o en bases de datos. Todo 
       dependendiendo de cómo haya sido programada la capa. La capa de persistencia no debería realizar validaciones ni operaciones más allá del CRUD que corresponde a una capa de persistencia. Para modelos más complejos como Persistencias 
       en bases de datos, también es posible configurar operaciones transaccionales y Agregaciones en este mismo punto. 
    Sin estas tres capas, el modelo se volvería inconsistente y la comunicación entre los módulos sería débil y generaría muchos problemas.
  > Capa de routing:  La capa de routing contendrá todos los archivos de tipo “router” que, como estamos ya acostumbrados, es una capa basada en redireccionamientos hacia puntos específicos de nuestra API. Actualmente, con el uso de motores 
    de plantillas, nuestra capa de routing está estrechamente conectada con la capa derenderización (al utilizar un views router). Sin esta capa, todas nuestras rutas de todas nuestras entidades se encontrarían en un mismo archivo, 
    complicando la lectura del código posteriormente.
  > Capa de servicio: La capa de servicios es una capa intermedia entre el controlador y la persistencia, en esencia, un servicio tiene la capacidad de servir como “tunel” de conexión, para que el controlador pueda acceder de manera más 
    homologada a la persistencia. Contar con una capa de servicio impide que los accesos a persistencia se hagan descontroladamente, con argumentos erróneos, etc. Además, son el punto clave para aplicar un patrón repository. No confundir una 
    capa de servicio con la capa de negocio, solo es un punto intermedio de conexión.

- Analisis del flujo y capas del proyecto: En ella se deben seguir los pasos adecuados para una mejor actitectura. Los cuales son:
  > Inicio: capa de vista, presentación o renderizado: Como es de esperarse, todo comienza desde el cliente, cuando este carga una página, aprieta un botón o desea buscar un dato, está haciendo una petición al servidor. Para ello, desde esta 
    capa se hace un “consumo”, el cual hará una operación de solicitud para obtener los datos.
  > Primer contacto (capa de ruteo): La petición tuvo que realizarse a partir de un endpoint, el cual entra a la capa de ruteo y designa cuál de todas las rutas corresponden a la acción que desea realizar el cliente.
  > Segundo contacto (capa de controlador): Cada ruta está relacionada con algún método o función de un controlador, así, cuando el router reconoce adónde está apuntando el cliente, sabe llevarlo a la función adecuada.
  > Tercer contacto (Capa de Servicio): Para poder obtener, un grupo de usuarios, la función perteneciente a estos usuarios requerirá acceder a un punto intermedio entre el controlador y entre la capa de persistencia para obtener la info.
  > Cuarto contacto (Capa de Persistencia): El punto intermedio mencionado arriba sabe que debe acceder a usuarios, el detalle es ¿de qué persistencia? ¿Memoria, archivos, base de datos? El servicio sabrá a qué persistencia conectar y 
    obtendrá los datos
  > Regreso (vuelta de datos y envío al cliente): Una vez obtenidos los datos a partir de la persistencia, el controlador termina de procesarlos y puede finalmente enviarlos al cliente para terminar el procesamiento de esa petición.
    

                                                                                                                   Patrones de diseño reconocidos en Expressjs
                                                                                                                   
> Cadena de responsabilidades: Permite que, cuando algún elemento envía información (sender) y existe alguien que lo reciba (receiver), a esa petición puedan recibirla y procesarla múltiples objetos (o funciones). Esto permite tener un mejor 
  control de la petición, agregar filtros y reenviar el objeto con sus respectivas alteraciones.   
  Express popularizó enormemente el concepto de un Middleware, que al final es una variante de la inyección de dependencias, donde al recibir un request, éste puede pasar por diferentes lógicas en cada middleware, al final, un middleware 
  responde para recibirse por otro middleware, y así sucesivamente hasta llegar al endpoint principal.
  
> Decorador: Permite mantener un objeto inicial genérico para poder procesar información, pero al ser utilizado éste está abierto a ser transformado a lo largo del flujo del proceso. De no querer que un objeto tenga añadiduras nuevas, 
  podemos congelar el objeto con “Object.freeze()”, sin embargo, rompería con el patrón decorador al no permitir que se le cambie.
  Cuando recibimos un request, el objeto request está predefinido con ciertas propiedades, sin embargo, podemos procesar n middlewares para transformar el request. Al usar multer, por ejemplo, a nuestro endpoint llega una propiedad req.file 
  o req.files, cosa que no teníamos antes del middleware.
  
> Proxy: También conocido como Proxy routing o simplemente Routing pattern, implica tener un sustituto (surrogate), el cual reciba una petición y controlar el acceso hacia otro objeto (subject). El sustituto recibirá todas las peticiones, 
  para después corroborar a quién debería corresponder dicha petición y enviársela. El sustituto y el objeto final deben contar con la misma interfaz. Cuando creamos un nuevo router en la aplicación principal de Express, y conectamos el 
  middleware de router con app.use(), éste se convierte en un sustituto que definirá a cuál router redirigir la información. Es el patrón más común que se puede reconocer en Express, pues son los primeros pasos que damos al comenzar a usarlo

> Patrón MVC: Es un patrón que ya se ha platicado ampliamente en las últimas clases, éste consistiendo en la separación de capas de modelo (persistencia), Vista (presentación) y Controlador (Negocio). Recordemos que al final el objetivo es 
  mantener un flujo con actividades bien delegadas y así poder tener mejor control sobre el código.

> Patrón Singleton: Es un patrón utilizado para tener una instancia global a nivel aplicación. En ocasiones, se requiere que la aplicación tenga una única instancia de dicha clase (Por ejemplo, al abrir una conexión en base de datos). El 
  patrón singleton corrobora si ya existe una instancia de esta clase. En caso de que sí, devolverá la instancia, caso contrario creará la instancia.


                                                                                                                   Arquitectura del servidor: Persistencia
                                                                                                                   
- Memoria: La información persiste sólo durante el ciclo de vida del programa, si se reinicia, la información desaparece.
- Archivos: La información se guarda en un fichero que permite persistir la información, aun cuando el programa se reinicie o apague.
- Base de datos: Permite que no solo se pueda almacenar información, sino también facilita la aplicación de un CRUD de manera rápida y segura. Es la persistencia por excelencia.

- El patrón DAO (persistencia aislada): consiste en separar la lógica de acceso a la fuente de datos en un archivo. Éste contará con métodos homologados de manera que, si en algún momento necesitamos cambiar el acceso a los datos, el DAO de 
  la nueva fuente de datos tenga exactamente el mismo nombre de métodos que el anterior, evitando así que haya conflictos al acceder a la información. Así, podemos tener un MemoryDAO, un fileDAO, un databaseDAO según sea el caso, e
  intercambiarlos sin problema.

- DAO: Se encargará de conectar con nuestra fuente de datos según la hayamos programado, habrá DAOs programados para hacer CRUD en memoria, DAOs para hacer CRUD en archivos, etc. Así, en la lógica de negocio sólo se necesita importar el DAO 
  a trabajar y utilizarlo. Si en algún momento necesitamos cambiar de persistencia, bastará con cambiar el DAO

- Patrón Factory: La idea del patrón Factory, es basarse en una variable de entorno o configuración por argumentos, la cual tomará para decidir qué tipo de persistencia manejar. Esta “Fábrica” se encargará de devolver sólo el DAO que 
  necesitemos acorde con lo solicitado en el entorno o los argumentos. 

- Data Transfer Object: DTOs or Data Transfer Objects are objects that carry data between processes in order to reduce the number of methods calls. The pattern’s main purpose is to reduce roundtrips to the server by batching up multiple 
  parameters in a single call. This reduces the network overhead in such remote operations. Another benefit is the encapsulation of the serialization’s logic (the mechanism that translates the object structure and data to a specific format 
  that can be stored and transferred). It provides a single point of change in the serialization nuances. It also decouples the domain models from the presentation layer, allowing both to change independently.


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        


                                                                                                                   Data Modeling
                                                                                                                   
- Data Modeling: Data modeling refers to the organization of data within a database and the links between related entities. Data in MongoDB has a flexible schema model, which means: 
    + Documents within a single collection are not required to have the same set of fields. 
    + A field's data type can differ between documents within a collection. 
  Generally, documents in a collection share a similar structure. To ensure consistency in your data model, you can create schema validation rules.
  
  > Use Cases: The flexible data model lets you organize your data to match your application's needs. MD is a document database, meaning you can embed related data in object and array fields. A flexible schema is useful according to:
     + Your company tracks which department each employee works in. You can embed department information inside of the employee collection to return relevant information in a single query.
     + Your e-commerce application shows the five most recent reviews when displaying a product. You can store the recent reviews in the same collection as the product data, and store older reviews in a separate collection because the older 
       reviews are not accessed as frequently.
     + Your clothing store needs to create a single-page application for a product catalog. Different products have different attributes, and therefore use different document fields. You can store all of the products in the same collection.
  
  > Link Related Data: When you design your data model in MongoDB, consider the structure of your documents and the ways your application uses data from related entities. To link related data, you can either: 
    + Embed related data within a single document.
    + Store related data in a separate collection and access it with a  reference.

- Denormalization: Denormalization is used to combine multiple table data into one so that it can be queried quickly. It is a process of storing the join of higher normal form relations in the form of base relation that is in a lower normal 
  form. The primary goal of denormalization is to achieve the faster execution of the queries.
  In the process of denormalization, the data is integrated into the same database. Denormalization is mainly used where joins are expensive and queries are executed on the table very frequently. However, there is a drawback of 
  denormalization, that is, a small wastage of memory.

- Normalization: Normalization is used to remove redundant data from the database and to store non-redundant and consistent data into it. It is a process of converting an unnormalized table into a normalized table. Database normalization is 
  an important process because a poorly designed database table is inconsistent and may create issues while performing operations like insertion, deletion, updating, etc. 
  The process of Normalization involves resolution of database anomalies, elimination of data redundancy, data dependency, isolation of data, and data consistency. Normalization in databases provides a formal framework to analyze the 
  relations based on the key attributes and their functional dependencies. It reduces the requirements of restructuring of tables.
    > Child referencing: The Child References pattern stores each tree node in a document; in addition to the tree node, document stores in an array the id(s) of the node's children. Each node contains a reference array to its children
    > Parent referencing: The Parent References pattern stores each tree node in a document; in addition to the tree node, the document stores the ID of the node's parent. Each node contains a reference to its parent.
    
- Difference between Normalization and Denormalization: The following table highlights the important differences between Normalization and Denormalization
  > Normalization
    + Implementation: Normalization is used to remove redundant data from the database and to store non-redundant and consistent data into it.	
    + Focus: Normalization mainly focuses on clearing the database from unused data and to reduce the data redundancy and inconsistency.	
    + Number of Tables: During Normalization, data is reduced, so there will be a decrease in the number of tables.	
    + Memory consumption: Normalization uses optimized memory and hence faster in performance.	
    + Data integrity: Normalization maintains data integrity, i.e., any addition or deletion of data from the table will not create any mismatch in the relationship of the tables.	
    + Where to use: Normalization is generally used where a number of insert/update/delete operations are performed and joins of those tables are not expensive.	
  
  > Denormalization
    + Implementation: Denormalization is the process of adding some redundant data to a database that has been normalized, so as to improve the read performance (execution time) of the database
    + Focus: The real goal of denormalization is to achieve the faster execution of the queries by introducing redundancy.
    + Number of Tables: During Denormalization, data is integrated into the same database and hence there will be an increase in the number of tables.
    + Memory consumption: Denormalization introduces some sort of wastage of memory.
    + Data integrity: Denormalization does not maintain any data integrity.
    + Where to use: Denormalization is used where joins are expensive and frequent queries are executed on the tables.

- Embedded Documents: Embedded documents store related data in a single document structure. A document can contain arrays and sub-documents with related data. These denormalized data models allow applications to retrieve related data in a 
  single database operation. For many use cases in MongoDB, the denormalized data model is optimal.
  Embedded documents are stored as children inside a parent document. This means they are all stored under one collection, and whenever you retrieve the parent document, you also retrieve all its embedded documents
  For example, if you had a user document, it may contain a list of embedded documents detailing that user’s addresses. In JSON format, it may look something like this:
    
        {
          "_id": 1,
          "name": "Ashley Peacock",
          "addresses": [
            {
              "address_line_1": "10 Downing Street",
              "address_line_2": "Westminster",
              "city": "London",
              "postal_code": "SW1A 2AA"
            },
            {
              "address_line_1": "221B Baker Street",
              "address_line_2": "Marylebone",
              "city": "London",
              "postal_code": "NW1 6XE"
            }
          ]
        }
     By storing our addresses as embedded documents, we’re only persisting a single document.
        
- References: References store relationships between data by including links, called references, from one document to another. For example, a customerId field in an orders collection indicates a reference to a document in a customers 
  collection. Applications can resolve these references to access the related data. Broadly, these are normalized data models.
  Unlike embedded documents, referenced documents are stored in a separate collection to their parent document. Therefore, it’s possible to retrieve the parent document without retrieving any of its referenced documents.

        // Stored in the user collection
        {
          "_id": 1,
          "name": "Ashley Peacock",
          "addresses": [
            1000,
            1001
          ]
        }
        // Stored in the address collection
        {
          "_id": 1000,
          "address_line_1": "10 Downing Street",
          "address_line_2": "Westminster",
          "city": "London",
          "postal_code": "SW1A 2AA"
        }
        // Stored in the address collection
        {
          "_id": 1001,
          "address_line_1": "221B Baker Street",
          "address_line_2": "Marylebone",
          "city": "London",
          "postal_code": "NW1 6XE"
        }
        
  In storing our addresses using references, we’re storing 3 separate documents. If we want to retrieve a user’s addresses along with the user, we must effectively run 2 queries: the first to retrieve the user, the second to retrieve 
  their addresses. This is because MongoDB, unlike SQL, has no performant concept of a join. It does provide a lookup operation, but it’s not typically performant enough to use in a real time production environment — both in terms of 
  speed and resources. Instead, we should look to better design our schemas to suit MongoDB, which is what we’ll cover next. 
  It’s worth noting we can choose how we model the relationship when using references. We can decide, as we have above, to store a list of references on the parent document. If the list of references is likely to become large, it’s 
  usually better to store the ID of the parent document (user in this case) in any related documents (in the address in this case). Otherwise, each time we add a new address, we have to update the user document to add the new reference.
     
- How To Choose Between Embedded Or Referenced Documents: Generally speaking, we should look to use embedded documents when both the parent document and its related documents are either read or written at the same time. Furthermore, we 
  should prioritise based on whether the collection is read or write heavy. For example, consider the following document:
        {
          "_id": 1,
          "name": "Ashley Peacock",
          "account_balance": 150
          "stocks": [
            {
              "code": "AMZN",
              "amount": "3",
              "value": "1478.22"
            }
          ],
          "orders": [
            {
              "order_id": 1,
              "order_value": 102.5,
              "order_items": [...]
            }
          ]
        }
        
  We have two embedded documents: stocks and orders. Should they be embedded, though? To answer that question, we need a little more context — here’s what the fictional stock trading application looks like in terms of how we interact with 
  our user collection: 
     + Once logged in, the user ID is stored in the web session.
     + Stocks contain the stocks the user currently owns. They are shown on almost every page of the website, and must be retrieved from the database each time a page is rendered for compliance and accuracy reasons. Stocks are updated 
       infrequently when compared to how often they are read.
     + The account balance is also shown on every page.
     + Orders are only shown on the orders page, and only updated when an order is placed.
     
  In this case, I would store the stocks as embedded documents because whenever we render a page we need both the account balance and the list of stocks. If we stored them separately, we’d have to execute two separate queries — one to get 
  the user, another to get their stocks. Considering this data is shown on every page, we’d be doubling the number of queries per page load if we referenced them.
  Moving on to the orders, I would store these as referenced documents, as they are only used on specific pages. Furthermore, we can query for orders, and add new orders, simply by using the user ID stored in the web session — without 
  querying the user collection at all.
  A user could have 100’s of orders. If we stored them as embedded documents, the amount of data returned for the user query would grow significantly over time. Additionally, it would return a large amount of data that isn’t used on the 
  majority of the website. To add a new order, we would need to read the entire user document, append the new order, and then re-write the entire document.
  Using referenced documents however, we can simply insert a new document into the orders collection, tied to the user ID, and we don’t have to read the user collection at all (or any other orders!).


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$        

                                                                                                       Conceptos y definiciones
                                                                                                                   
- Callback function: Aseguran que una función no se va a ejecutar antes de que se complete una tarea, sino que se ejecutará justo después de que la tarea se haya completado. Nos ayuda a desarrollar código JavaScript asíncrono y nos 
  mantiene a salvo de problemas y errores. Una función callback es aquella que es pasada como argumento a otra función para que sea "llamada de nuevo" (call back) en un momento posterior. Una función que acepta otras funciones como 
  argumentos es llamada función de orden-superior (High-Order), y contiene la lógica para determinar cuándo se ejecuta la función callback. Es la combinación de estas dos la que nos permite ampliar nuestra funcionalidad. La forma de crear 
  una función callback es pasándola como parámetro a otra función, y luego llamarla de vuelta justo después de que haya ocurrido algo o se haya completado alguna tarea.
  
  A callback function is a function passed into another function as an argument, which is then invoked inside the outer function to complete some kind of routine or action.
  Callbacks make sure that a function is not going to run before a task is completed but will run right after the task has completed. It helps us develop asynchronous JavaScript code and keeps us safe from problems and errors.
  In JavaScript, the way to create a callback function is to pass it as a parameter to another function, and then to call it back right after something has happened or some task is completed. 

- fetch: Fetch is the retrieval of data by a software program, script, or hardware device. After being retrieved, the data is moved to an alternate location or displayed on a screen.

- Hoisting: Es el proceso de mover todas las declaraciones de variables a la parte superior de la función o del entorno. El concepto de hoisting de JavaScript determina que el valor de una variable declarada con var puede subir al 
  principio del scope de la función dentro de la que está declarada. Esto puede ser peligroso, porque puedes terminar con un valor de tipo undefined a pesar de haberle otorgado valor a tus variables. Es decir, la palabra clave var a veces 
  nos sorprende con valores indefinidos en variables definidas. El hoisting de JavaScript raras veces genera este comportamiento en variables declaradas con const y con let. Aunque puede suceder, el desarrollador web casi que tiene que 
  generar este comportamiento a propósito para que suceda.  
  
- Asincrónia: La programación asíncrona nos da la capacidad de “diferir” la ejecución de una función a la espera de que se complete una operación, normalmente de I/O (red, disco duro, …), y así evitar bloquear la ejecución hasta que se haya 
  completado la tarea en cuestión. Esto es posible gracias a que las funciones son ciudadanos de primer nivel (first-class citizens) y pueden ser pasadas como argumentos de otras funciones tal cual lo haríamos con las variables.                                                                                                                   
  
-  Node JS: Node.js es un entorno de ejecución de JavaScript, que le permite al código en js ser ejecutado en nuestra computadora. Podemos darle a node un archivo de js y éste puede ejecutarlo, y darle acceso a recursos de nuestra 
   computadora (IO, Network, Etc). El “Node” de java es conocido como la JVM.
   
-  NPM (Node Packager Manager): Cuando usamos Node.js, rápidamente tenemos que instalar módulos nuevos (librerías), ya que al ser un sistema fuertemente modular viene prácticamente “vacío”. Por lo tanto, para utilizar una funcionalidad de 
   alguna librería publicada, deberemos instalar módulos adicionales. Esta operación se realiza de forma muy sencilla con la herramienta npm (Node Package Manager).
   Esta herramienta funciona de dos formas:
     ✓ Como un repositorio ampliamente utilizado para la publicación de proyectos Node.js de código abierto.
     ✓ Como una herramienta de línea de comandos. Esta utilidad ayuda a instalar y desinstalar paquetes, gestionar versiones y gestionar dependencias necesarias para ejecutar un proyecto.

- JSON (JavaScript Object Notation): It is a format for storing and transporting data. JSON is text, and text can be transported anywhere, and read by any programming language. Es un formato basado en texto plano de intercambio de datos 
  totalmente independiente del lenguaje de programación, para representar datos estructurados con la sintaxis de objetos de JavaScript. Es comúnmente utilizado para enviar y almacenar datos o información estructurada en aplicaciones web, 
  entre un servidor y un cliente. Aunque es muy parecido a la sintaxis de JavaScript, puede ser utilizado independientemente de JavaScript, y muchos entornos de programación poseen la capacidad de leer (convertir; parsear) y generar JSON. 
  JSON es un string con un formato específico. Otros puntos a tener en cuenta son:
  
     ~ Los datos contenidos en un archivo en formato JSON deben estructurarse por medio de una colección de pares con nombre y valor o deben ser una lista ordenada de valores. Sus elementos tienen que contener:
        + Clave: corresponde al identificador del contenido. Por eso, debe ser una string delimitada por comillas.
        + Valor: representa el contenido correspondiente y puede contener los siguientes tipos de datos: string, array, object, number, boolean o null.
     ~ Las datos en formato JSON se pueden almacenar en archivos externos .json. Exemplo: datos.json 
     ~ JSON es sólo un formato de datos - contiene sólo propiedades, no métodos.
     ~ A diferencia del código JavaScript en que las propiedades del objeto pueden no estar entre comillas, en JSON sólo las cadenas entre comillas pueden ser utilizadas como propiedades.
     ~ JSON es solo un formato de datos.
     ~ Requiere usar comillas dobles para las cadenas y los nombres de propiedades. Las comillas simples no son válidas. 
     ~ Puede tomar la forma de cualquier tipo de datos que sea válido para ser incluido en un JSON, no solo arreglos u objetos. Así, por ejemplo, una cadena o un número único podrían ser objetos JSON válidos.
     ~ A diferencia del código JavaScript, en el que las propiedades del objeto pueden no estar entre comillas, en JSON solo las cadenas entre comillas pueden ser utilizadas como propiedades.
      
  La transferencia de datos entre aplicaciones es realizada por medio de API —Application Programming Interface— que, entre otros formatos, utiliza la notación JSON para estructurar la información enviada.
  El archivo JSON también se usa para realizar requisiciones AJAX en sitios web, en que se hacen diferentes interacciones con bancos de datos, como el MySql, para realizar operaciones como consulta, inclusión y exclusión de registros.
  
  Principales casos de uso para JSON:
     ~ Generación de un objeto JSON a partir de datos generados por el usuario: JSON es perfecto para el almacenamiento de datos temporales. Por ejemplo, los datos temporales pueden ser generados por el usuario, como un formulario enviado en 
       un sitio web. JSON también se puede utilizar como formato de datos para cualquier lenguaje de programación a fin de incrementar el nivel de interoperabilidad.
     ~ Tansferencia de datos entre sistemas: Una base de datos de sitio web tiene la dirección postal de un cliente, pero la dirección debe verificarse a través de una API para garantizar su validez. Envío de los datos de dirección en 
       formato JSON a la API de servicio de validación de direcciones.
     ~ Configuración de datos para aplicaciones: Al desarrollar aplicaciones, cada aplicación necesita las credenciales para conectarse a una base de datos, así como una ruta de acceso al archivo log. Las credenciales y la ruta de acceso al 
       archivo se pueden especificar en un archivo JSON que sea legible y que esté siempre disponible.
     ~ Simplificación de modelos de datos complejos: JSON simplifica los documentos complejos hasta los componentes que se han identificado como significativos mediante la conversión del proceso de extracción de datos en un archivo JSON 
       predecible y legible por humanos.
     
- API (Application Programming Interfaces): que en español significa interfaz de programación de aplicaciones. Es una aplicación web construida en base a la arquitectura API REST, a la cual podemos solicitar y enviar información desde el 
  cliente. Tambien, se define como un conjunto de definiciones y reglas que permiten que dos equipos puedan integrarse para trabajar juntos. La mejor analogía que hay para comprender ésto es que una API funge como un “contrato” entre el 
  front y el back. La API permite entonces que se respondan preguntas como:
    ✓ ¿A qué endpoint debo apuntar para la tarea que necesito?
    ✓ ¿Qué método debo utilizar para ese recurso?
    ✓ ¿Qué información debo enviar para realizar correctamente mi petición? 
    
  1) REST: Ya tenemos las reglas para comunicarse, ¿Pero qué tal la estructura del mensaje? Cuando hacemos una petición o cuando recibimos una respuesta, ésta debe tener un formato. REST (REpresentational State Transfer) permite definir la 
     estructura que deben tener los datos para poder transferirse. La API respondía a preguntas sobre cómo comunicarse correctamente, sin embargo, REST define cómo debe ser el cuerpo del mensaje a transmitir. (puedes llegar a hablar con el 
     presidente si cumples con el protocolo (HTTP) y las reglas (API), pero ¿de qué nos servirá si la forma en que estructuramos nuestro mensaje (REST) no es correcta?).
     Los dos formatos más importan tes son JSON y XML. La utilización de la estructura dependerá de las necesidades del proyecto. Nosotros utilizaremos JSON. Como otarás, ¡un JSON parece un objeto! así que es mucho más amigable la sintaxis.
  2) API REST es: Un modelo completo para tener perfectamente estipulados los protocolos, las reglas, e incluso la estructura de la información, con el fin de poder hacer un sistema de comunicación completo entre las computadoras.
  3) Características debe tener una API REST: Estas son las caracteristicas mas importantes de una API REST
     a) Arquitectura Cliente-Servidor sin estado: 
        ~ Cada mensaje HTTP contiene toda la información necesaria para comprender la petición. 
        ~ Como resultado, ni el cliente ni el servidor necesitan recordar ningún estado de las comunicaciones entre mensajes.
        ~ Esta restricción mantiene al cliente y al servidor débilmente acoplados: el cliente no necesita conocer los detalles de implementación del servidor y el servidor se “despreocupa” de cómo son usados los datos que envía al cliente.
     b) Cacheable: 
        ~ Debe admitir un sistema de almacenamiento en caché.  
        ~ La infraestructura de red debe soportar una caché de varios niveles. 
        ~ Este almacenamiento evita repetir varias conexiones entre el servidor y el cliente, en casos en que peticiones idénticas fueran a generar la misma respuesta.
     c) Operaciones comunes:
        ~ Todos los recursos detrás de nuestra API deben poder ser consumidos mediante peticiones HTTP, preferentemente sus principales (POST, GET, PUT y DELETE).
        ~ Con frecuencia estas operaciones se equiparan a las operaciones CRUD en bases de datos (en inglés: Create, Read, Update, Delete, en español: Alta, Lectura, Modificación, y Baja).  
        ~ Al tratarse de peticiones HTTP, éstas deberán devolver con sus respuestas los correspondientes códigos de estado, informando el resultado de las mismas. 
     d) Interfaz uniforme: 
        ~ En un sistema REST, cada acción (más correctamente, cada recurso) debe contar con una URI (Uniform Resource Identifier), un identificador único.  
        ~ Ésta nos facilita el acceso a la información, tanto para consultarla, como para modificarla o eliminarla, pero también para compartir su ubicación exacta a terceros.
     e) Utilización de hipermedios: 
        ~ Cada vez que se hace una petición al servidor y este devuelve una respuesta, parte de la información devuelta pueden ser también hipervínculos de navegación asociada a otros recursos del cliente.
        ~ Como resultado de esto, es posible navegar de un recurso REST a muchos otros, simplemente siguiendo enlaces sin requerir el uso de registros u otra infraestructura adicional
     
  
  Generalmente, nos comunicamos con aplicaciones de este tipo y es la tendencia actual de desarrollo. La ventaja de este modelo es que está orientado a recursos y define métodos claros para solicitar y enviar información. Una API
  suele tener una URL base (el dominio donde está alojada la aplicación) y luego puede tener varios endpoints, es decir, distintas secciones a las que podemos acceder. A la vez, se pueden hacer peticiones con distintos métodos al mismo 
  endpoint y obtener distintos resultados. Generalmente, similar a cuando queremos incorporar una librería, al momento de consumir una API debemos revisar su documentación. Allí se definen los distintos endpoints disponibles, los métodos a 
  utilizar para hacer una petición y qué se nos ofrecerá en respuesta.
  Se trata de un conjunto de definiciones y protocolos que se utiliza para desarrollar e integrar el software de las aplicaciones, permitiendo la comunicación entre dos aplicaciones de software a través de un conjunto de reglas. Así pues, 
  podemos hablar de una API como una especificación formal que establece cómo un módulo de un software se comunica o interactúa con otro para cumplir una o muchas funciones. Todo dependiendo de las aplicaciones que las vayan a utilizar, y de 
  los permisos que les dé el propietario de la API a los desarrolladores de terceros.
  
  Una de las principales funciones de las API es poder facilitarle el trabajo a los desarrolladores y ahorrarles tiempo y dinero. Por ejemplo, si estás creando una aplicación que es una tienda online, no necesitarás crear desde cero un 
  sistema de pagos u otro para verificar si hay stock disponible de un producto. Podrás utilizar la API de un servicio de pago ya existente, por ejemplo PayPal, y pedirle a tu distribuidor una API que te permita saber el stock que ellos 
  tienen. Con ello, no será necesario tener que reinventar la rueda con cada servicio que se crea, ya que podrás utilizar piezas o funciones que otros ya han creado. Imagínate que cada tienda online tuviera que tener su propio sistema de 
  pago, para los usuarios normales es mucho más cómodo poder hacerlo con los principales servicios que casi todos utilizan. También son útiles para cuando lo único que se quiere es utilizar deliberadamente las funciones de determinado 
  servicio para ofrecer ventajas a sus usuarios o atraer a los usuarios de ese servicio a que utilicen tu aplicación.
  
- Peticiones HTTP: El mecanismo por el cual se piden y proveen datos a través de internet es HTTP (Hypertext Transfer Protocol). Cuando emitimos una orden al navegador, hace una petición (o request) HTTP a algún servidor. Luego, la recibirá, 
  procesará y nos devolverá una respuesta con información que utilizaremos en la aplicación. Estas peticiones que debemos hacer están definidas por varias partes
  
  > Una URL o dirección: Cuando nos comunicamos con un servidor para pedir información lo hacemos a través de una URL, ya que éste es un programa alojado en algún host y nos comunicamos con él a través de la dirección correcta
  
  > MÉTODO (method): Un método es una definición que forma parte del protocolo HTTP, el cual nos sirve para canalizar el tipo de petición queestoy realizando sobre un cierto endpoint. De esta manera, el cliente puede llamar al mismo 
    endpoint, pero con diferentes métodos, indicando qué operación quiere realizar con dicho recurso.
    Cada petición que hacemos está acompañada por un verbo que indica al servidor cuál es nuestra intención. El servidor tiene la capacidad de escuchar distintas peticiones en la misma URL, decidir a cuál responder y cómo.     
    Son 4 los verbos más utilizados, aunque hay muchos más: Get, Post, Put & Delete. Las peticiones de tipo POST y PUT van acompañadas de un body (cuerpo de la request) donde se definen los datos o información a enviar al servidor. GET o 
    DELETE, por su parte, no tienen body ya que no necesitan enviar datos adjuntos.
   
    ~ GET: Para obtener información (o recurso) del servidor. Suelen ser las más utilizadas.
   
    ~ POST: Para enviar información al servidor para crear algún recurso.  Significa que el método de la petición será POST Si no lo modificamos será de tipo GET por defecto. Sirve para “crear” recursos, POST se utiliza para operaciones 
      donde no necesitamos obtener un recurso, sino añadir uno. Algunos de los casos donde se utilizan son: Registrar un usuario: Loguear un usuario, Crear un producto, Crear carrito de compra, Enviar información para un correoelectrónico. 
      Se apoya del recurso req.body, donde el body representa la información que el cliente envía para crear. 
    
    ~ PUT: Para crear o modificar algún recurso en el servidor. En este caso se deben mandar todos los elementos contenidos en el objeto aunque solo se desee modificar unos solo. 
      
    ~ PATCH: quiero alterar parcialmente. Aqui, unicamente se puede enviar un elemento de todos los contenidos en el objeto. 
    
    ~ DELETE: Para eliminar algún recurso en el servidor
    
    Estos verbos Nos permiten definir una manera de explicarle al servidor la dirección y nuestras intenciones. Ningún verbo representa una seguridad y/u obligación. Pero si el servidor y el consumidor los respetan, se pueden lograr algunas 
    mejoras como por ejemplo: El navegador sabe que un POST no debería ser cacheado, si hacemos un GET y fuera cacheable el navegador podrá cachearlo, pero nunca lo hará con un recurso con verbo POST
    
    ~ BODY: Es el espacio en la petición donde se definen los datos a enviar al servidor. Aquí se adjuntan los datos a enviar al servidor. En este caso se envía un objeto con la forma { title, body, userId }. 
      El body debe enviarse en formato JSON, por eso lo vemos envuelto en un JSON.stringify(). Se utiliza para transferir piezas de información entre el cliente y el servidor.
      
    ~ HEADERS: Las cabeceras (headers) HTTP permiten al cliente y servidor enviar información sobre la petición y la respuesta. Los headers incluyen información sobre la petición para establecer una transferencia segura y clara, y de ser 
      necesario se pueden modificar para agregar datos adicionales. No debemos confundir información sobre la petición (headers) con los datos que la petición puede transferir (body).
      En este caso se agrega una propiedad ‘Content-type’, con el valor que nos indica la documentación de la API Si no se agrega la petición sería rechazada por el servidor.
      Headers: Se usan para: Definir las respuestas soportadas, requeridas o preferidas. Agregar información extra. Auth tokens, cookies. Lenguaje preferido. Si acepta contenido cacheado. Lo que quieras en forma de texto.
      
    ~ Parámetros (Query Params o URL Params): Para especificar una petición, se puede enviar información adicional en la forma de parámetros a través de la URL. Tenemos dos formas de definir parámetros a través de la URL: 
      ● Query params: Permite adjuntar en la URL una serie de parámetros en la forma de pares clave-valor. Por ejemplo, si queremos buscar algo por google, debemos enviarle un valor de búsqueda por el parámetro q, a través de la url. Se 
        utiliza el símbolo ? para indicar el final de la parte de la dirección de la url y el comienzo del query. A partir de ahi, se escriben parámetros con la Forma clave=valor, pudiendo definir varios separándolos con el signo (&).
      ● URL params: Esta sintaxis permite enviar parámetros directamente en la forma de segmentos de la URL, es decir separados por / . Por ejemplo, la PokeApi nos indica lo siguiente:     https://pokeapi.co/api/v2/pokemon/{id or name}/ 
        Significa que ese {id or name} es un parámetro, un valor dinámico que insertamos en la URL, en este caso para obtener información sobre un pokemon según su ID o nombre. Para obtener aquel con id = 1, haríamos una petición GET a la
        siguiente url:       https://pokeapi.co/api/v2/pokemon/1    
        
      Nos permiten incluir en la dirección información que se usa para especificarle al receptor parámetros para efectuar una búsqueda, son más comunes para buscar recursos que no tengo la seguridad de 
      que existan. Se puede leer como:
       + busca en google.com.ar
       + utilizando https…
       + el recurso search (resultados de búsqueda) …
       + que contengan la palabra (q = query) ‘coderhouse’
       + Se separa la URL de los parámetros utilizando un signo de pregunta ?
       + Cada parámetro tendra key=value & key2=value2
       + Cada parámetro se puede separar por &
       + http://url.com/find?type=order&id=1234
       
  > Principios
    ✓ Una aplicación RESTful requiere un enfoque de diseño distinto a la forma típica de pensar en un sistema: lo contrario a RPC
    ✓ RPC (Remote Procedure Calls, llamadas a procedimientos remotos) basa su funcionamiento en las operaciones que puede realizar el sistema (acciones, usualmente verbos). Ej: getUsuario()
    ✓ En REST, por el contrario, el énfasis se pone en los recursos (usualmente sustantivos), especialmente en los nombres que se le asigna a cada tipo de recurso. Ej. Usuarios.
    ✓ Cada funcionalidad relacionada con este recurso tendría sus propios identificadores y peticiones en HTTP.
       
     ~ URL Params: Son una convención para incluir el identificador del recurso dentro de la misma url, son más comunes cuando ya se conoce el recurso específico que se buscará.
     
     ~ RECURSOS/RESTFUL: Cuando se crea y provee un servicio basado y pensado en términos de recursos, y se respetan las convenciones de verbo/método y código de respuesta, estamos frente a un diseño arquitectural de tipo REST.
       Si además transferimos javascript o xml, es conocido como AJAX



- Query: Es una solicitud pero con ciertos parametros de busqueda. Se entiende por query o consulta cualquier petición de datos hacia un servicio que los devuelva, como puede ser una base de datos. Dentro de las bases de datos, Query hace 
  referencia a la repetición de datos que se encuentran almacenados. Por otra parte, Query también es el término de consulta que deriva en una SERP dentro de los buscadores. De esta manera, esta herramienta tiene como objetivo facilitar los 
  resultados arrojados a una solicitud. Query en bases de datos SQL y NoSQL es una técnica para obtener esos datos que se planea analizar. Por ejemplo, podrás pedir todos los datos del usuario y, además, podrás seleccionar la tabla o pedir 
  una hoja específica donde se encuentren las direcciones.
    
- AJAX (Asynchronous JavaScript and XML): Es un conjunto de técnicas de desarrollo que permiten que las aplicaciones web funcionen de forma asincrónica para procesar tareas en segundo plano. En consecuencia, cualquier app o web que emplee 
  AJAX puede enviar y recibir datos sin volver a cargar toda la página, evitando la interrupción de acciones realizadas por el usuario, añadiendo interactividad y dinamismo a nuestra aplicación. El objetivo principal de AJAX es hacer que los 
  sitios y las aplicaciones web sean más fáciles de usar, más rápidos y con mayor capacidad de respuesta. AJAX tiene ciertas ventajas indiscutibles como:
    > Facilita la navegación, ya que la información se actualiza continuamente y las interacciones entre el usuario y las páginas web se vuelven más rápidas.
    > Reduce la carga en el servidor, aumentando su velocidad y capacidad, porque no se genera la información de la página completa, sino de una sola parte que debe actualizarse.
    > Aumenta la interactividad porque los resultados de búsqueda aparecen inmediatamente, lo que optimiza el proceso de búsqueda y mejora la experiencia del usuario.

  El modelo práctico de uso de AJAX tiene los siguientes pasos:
    > Paso 1. En el navegador se crea una llamada de JavaScript que activa XMLHttpRequest.
    > Paso 2. En segundo plano el navegador web crea una solicitud HTTP que va al servidor.
    > Paso 3. El servidor recibe, recupera y manda los datos al navegador web.
    > Paso 4. Los datos se reciben por la web y aparecen en la página sin que se recargue.
    
  En el modelo tradicional se crea una solicitud HTTP que va al servidor. El servidor procesa la solicitud y carga la página HTML sin que el usuario interactúe con la aplicación web. En el caso de AJAX, JS permite que el usuario interactúe 
  con la aplicación web y modifique la página en segundo plano y solo sus partes necesarias. “En segundo plano” significa que mientras espera que se reciban los datos, el usuario puede hacer otras cosas en la página y optimizar este tiempo.
 
- Promesas (promise): Es un objeto de Javascript que representa un evento a futuro y permite representar y seguir el ciclo de vida de una tarea/operación (función). Es una acción asincrónica que se puede completar en algún momento y 
  producir un valor, y notificar cuando esto suceda. Una promesa cuenta con tres estados posibles: pending, fulfilled y rejected. Las promesas pueden ser resueltas o rechazadas.
  Podemos crear promesas a través de su constructor new Promise. Su sintaxis es algo compleja, ya que recibe una función por parámetro que a su vez recibe por parámetro las funciones de resolve y reject
  
 
- XML (Extensible Markup Language): es un lenguaje de marcado que define un conjunto de reglas para la codificación de documentos. El lenguaje de marcado es un conjunto de códigos que se pueden aplicar en el análisis de datos o la lectura de 
  textos creados por computadoras o personas. El lenguaje XML proporciona una plataforma para definir elementos para crear un formato y generar un lenguaje personalizado. XML admite el intercambio de información entre sistemas de 
  computación, como sitios web, bases de datos y aplicaciones de terceros. Las reglas predefinidas facilitan la transmisión de datos como archivos XML a través de cualquier red, ya que el destinatario puede usar esas reglas para leer los 
  datos de forma precisa y eficiente.
  Un archivo XML se divide en dos partes: prolog y body. La parte prolog consiste en metadatos administrativos, como declaración XML, instrucción de procesamiento opcional, declaración de tipo de documento y comentarios. La parte del body se 
  compone de dos partes: estructural y de contenido (presente en los textos simples). El diseño XML se centra en la simplicidad, la generalidad y la facilidad de uso y, por lo tanto, se utiliza para varios servicios web. Tanto es así que hay 
  sistemas  destinados a ayudar en la definición de lenguajes basados ​​en XML, así como APIs que ayudan en el procesamiento de datos XML - que no deben confundirse con HTML.

- Protocolo: Conjunto de estándares y normas que deben seguirse para poder llevar a cabo una comunicación correcta
    
- Servidor: Sistema que permite recibir peticiones de otras computadoras y devolver una respuesta a éstas.
  Es un equipo informático que forma parte de una red y provee servicios a otros equipos. Es un aparato informático que almacena, distribuye y suministra información. Los servidores funcionan basándose en el modelo “cliente-servidor”. 
  El cliente puede ser tanto un ordenador como una aplicación que requiere información del servidor para funcionar. Por tanto, un servidor ofrecerá la información demandada por el cliente siempre y cuando el cliente esté autorizado. Los 
  servidores pueden ser físicos o virtuales.
  > Servidor proxy: realiza un cierto tipo de funciones a nombre de otros clientes en la red para aumentar el funcionamiento de ciertas operaciones (p. ej., prefetching y depositar documentos u otros datos que se soliciten muy 
    frecuentemente), también proporciona servicios de seguridad, o sea, incluye un cortafuegos.
  > Servidor del acceso remoto (RAS): controla las líneas de módem de los monitores u otros canales de comunicación de la red para que las peticiones conecten con la red de una posición remota, responde llamadas telefónicas entrantes y 
    reconoce la petición de la red.
  > Servidor web: almacena documentos HTML, imágenes, archivos de texto, escrituras, y demás material Web compuesto por datos (conocidos colectivamente como contenido), y distribuye este contenido a clientes que la piden en la red.
  > Servidor de base de datos: provee servicios de base de datos a otros programas u otras computadoras, como es definido por el modelo cliente-servidor. También puede hacer referencia a aquellas computadoras (servidores) dedicadas a 
    ejecutar esos programas, prestando el servicio.
     
- codigo de estado: Cuando realizamos alguna petición al servidor mediante el protocolo HTTP, el servidor debe respondernos no sólo con información, sino con un estado del proceso. Este es un código que nos permitirá saber cómo se encuentra 
  el proceso, o cómo finalizó.    
  
- HTTP: Acrónimo para Hyper Text Transfer Protocol. Es el protocolo que nos permite comunicarnos a través de Internet  

- HTTPS

- TSL

- SSL
  
- DNS: 

- HTTP response status codes: HTTP response status codes indicate whether a specific HTTP request has been successfully completed. Cuando el servidor responde con un código de estado, esto permite saber qué ocurrió con la consulta que 
  estábamos haciendo, y da información al cliente sobre qué ha ocurrido.
  ✓ 1xx: Status “informativo”
  ✓ 2xx: Status “ok”. Indica que la petición se procesó correctamente. No hubo ningún tipo de inconveniente desde la consulta hasta la respuesta.
  ✓ 3xx: Status de redirección. Hace referencia a redirecciones, cuando un recurso se ha movido o necesitamos apuntar a otro servicio.
  ✓ 4xx: Status de error de cliente. Se utiliza cuando el cliente realiza alguna petición que no cumpla con las reglas de comunicación (una mala consulta, tal vez le faltó enviar un dato, o venía en un formato incorrecto).
  ✓ 5xx: Status de error en servidor.
  
  ~ 200: Indica que la petición se procesó correctamente. No hubo ningún tipo de inconveniente desde la consulta hasta la respuesta
  ~ 300: Hace referencia a redirecciones, cuando un recurso se ha movido o necesitamos apuntar a otro servicio.
  ~ 400: Se utiliza cuando el cliente realiza alguna petición que no cumpla con las reglas de comunicación (una mala consulta, tal vez le faltó enviar un dato, o venía en un formato incorrecto).
  ~ 401: Se utiliza cuando el cliente no se ha identificado con el servidor bajo alguna credencial, no puede acceder al recurso
  ~ 404: Se utiliza cuando el recurso no se ha encontrado, ya sea algún dato solicitado o incluso el endpoint mismo.
  ~ 500: Se utiliza cuando algo ocurrió en el servidor, no necesariamente un error del cliente, sino un error o “detalle” que no haya considerado el servidor al tratar con algún caso
    
- Cookies (definicion): Cookies (often known as internet cookies) are text files with small pieces of data — like a username and password — that are used to identify your computer as you use a network. Specific cookies are used to identify 
  specific users and improve their web browsing experience. Data stored in a cookie is created by the server upon your connection. This data is labeled with an ID unique to you and your computer. When the cookie is exchanged between your
  computer and the network server, the server reads the ID and knows what information to specifically serve you.
  Due to international laws, such as the EU’s General Data Protection Regulation (GDPR), and certain state laws, like the California Consumer Privacy Act (CCPA), many websites are now required to ask for permission to use certain cookies
  with your browser and provide you with information on how their cookies will be used if you accept.
  
  Type of cookies: 
  1. Magic cookies Magic cookies were originally used by Unix programmers to authenticate and track users in a system. Magic cookies are data tokens that allow servers and web browsers to communicate.
     HTTP cookies are a type of magic cookie used by websites to store information. The data stored in magic cookies are encrypted and, under normal circumstances, only the server that created the cookie can read the data.
  2. HTTP Cookies:  HTTP cookies, or internet cookies, are built specifically for web browsers to track, personalize and save information about each user’s session. A “session” is the word used to define the amount of time you spend on a 
     site. Cookies are created to identify you when you visit a new website. The web server — which stores the website’s data — sends a short stream of identifying information to your web browser in the form of cookies. This identifying 
     data (known sometimes as “browser cookies”) is processed and read by “name-value” pairs. These pairs tell the cookies where to be sent and what data to recall. So, where are the cookies are stored? It’s simple: your web browser will 
     store them locally to remember the “name-value pair” that identifies you. When you return to the website in the future, your web browser returns that cookie data to the website’s server, triggering the recall of your data from your 
     previous sessions. To put it simply, cookies are a bit like getting a ticket for a coat check:
     ~ You hand over your “coat” to the cloak desk. You connect/visit a website and a pocket of data is linked to you on the website’s server. This data can be your personal account, your shopping cart or even just what pages you’ve visited.
     ~ You get a “ticket” to identify you as the “coat” owner. The cookie (containing the data) is then given to you and stored in your web browser. It has a unique ID especially for you.
     ~ If you leave and return, you can get the “coat” with your “ticket”. When you revisit the website, your browser gives the website the cookie back. The website then reads the unique ID in the cookie to assemble your activity data,
       bringing you back to where you were when you first visited, as if you never left.
  3. First-party cookies: First-party cookies are from websites you directly visit in your browser and are used to improve your online user experience. They often store information relevant to the website such as what you’ve viewed in the 
    past or your settings preferences. As long as you are visiting authentic and reputable websites, first-party cookies are usually harmless and make it easier to browse your favorite websites.
  4. Third-party cookies: Third-party cookies are probably the most controversial type of cookie in terms of data privacy. They usually track your behavior for advertising purposes and aren't a direct part of the websites you visit. Instead, 
     they’re usually embedded in ads, videos, or web banners. Even a Facebook "like" button uses third-party cookies.
  5. Zombie cookies: Also known as supercookies, zombie cookies are a type of third-party cookie. However, they aren't stored in the same place as regular cookies. So even if a person deletes cookies, zombie cookies will rise from the dead 
     and reinstall themselves. They have gained a reputation for being notoriously difficult to remove.
  6. Session cookies:Session cookies work by storing information while you're browsing a website. This means it won't have to reauthenticate you for every web page you visit. Once you exit, your browser deletes all session cookies.
     Session cookies enable you to add an item to your shopping cart, browse multiple other pages, and then still keep track of your item in your cart. These are one of the most common types of cookies. 
  7. Persistent cookiesL: Persistent cookies are used to track and collect information about you. This particular cookie enables websites to remember if you're logged in and under what account. It's also used to build a profile on your 
     search history, so websites can recommend products, services, or content relevant to you. Most of these cookies usually have an expiration date. Persistent cookies are also a common type of cookie.
  8. Essential cookies: You're probably familiar with the banner or pop-up asking you for your cookie preferences for a website. Essential cookies are frequently an option to run only cookies necessary to run the website or for services you 
     have requested (such as remembering your login credentials). This means you remove third-party cookies from your website experience.
  9. Performance cookies: As the name suggests, performance cookies track your online movements and that data is used to improve the website. They measure analytics like how many times you visited a page, how much time you spent on a page, 
     or when you left the website. This is often a first-party cookie, but many websites use a third party to track these analytics.
  10. Functionality cookies: Functionality cookies allow you to use the fundamental features of a website. This could be anything from your language preference to displaying local news stories. They typically enhance a website's performance 
      and functionality. Some site features may not be available without functional cookies.    
  11. Advertising cookies: Third-party persistent cookies are often used for advertising purposes. Advertising cookies (also called targeting cookies) build a profile on you based on your interests, search history, and items you view. They 
      then share that information with other websites, so they can advertise relevant products and services to you.
    For example, maybe you searched for gym shoes recently. Don't be too surprised later when you see an ad on social media for gym shoes or relevant items such as socks.

      
   > What Are Cookies Used For: Websites use HTTP cookies to streamline your web experiences. Without cookies, you’d have to login every time you leave a site or rebuild your shopping cart if you accidentally closed the page. Making cookies 
     is an important part of the modern internet experience. To be more concise, cookies are intended to be used for:
      1. Session management: For example, cookies let websites recognize users and recall their individual login information and preferences, such as sports news versus politics.
      2. Personalization: Customized advertising is the main way cookies are used to personalize your sessions. You may view certain items or parts of a site, and cookies use this data to help build targeted ads that you might enjoy. They’re 
         also used for language preferences as well.
      3. Tracking: Shopping sites use cookies to track items users previously viewed, allowing the sites to suggest other goods they might like and keep items in shopping carts while they continue shopping on another part of the website. \
         They will also track and monitor performance analytics, like how many times you visited a page or how much time you spent on a page.
         
      While this is mostly for your benefit, web developers get a lot out of this set-up as well. Cookies are stored on your device locally to free up storage space on a website’s servers. In turn, websites can personalize content, whilst 
      saving money on server maintenance and storage costs.
      
   > What are the different types of HTTP Cookies: With a few variations (which we’ll discuss later), cookies in the cyber world essentially come in two types: session cookies and persistent cookies.
     Session cookies are used only while navigating a website. They are stored in random access memory and are never written on to the hard drive. When the session ends, session cookies are automatically deleted. They also help the "back"
     button work on your browser.
     Persistent cookies, on the other hand, remain on a computer indefinitely, although many include an expiration date and are automatically removed when that date is reached. Persistent cookies are used for two primary purposes:
      ~ Authentication. These cookies track whether a user is logged in and under what name. They also streamline login information, so users don't have to remember site passwords.
      ~ Tracking. These cookies track multiple visits to the same site over time. Some online merchants, for example, use cookies to track visits from particular users, including the pages and products viewed. The information they gain 
        allows them to suggest other items that might interest visitors. Gradually, a profile is built based on a user's browsing history on that site.      
  
  
- Application logic vs Business logic: 
  
- software architecture patterns: If you design software architectures, chances are that you come across the same goals and problems over and over again. Architectural patterns make it easier to solve these issues by providing repeatable 
  designs that address common situations.
 
   1) The circuit breaker pattern minimizes the effects of a hazard by rerouting traffic to another service. While it helps make systems more fault tolerant to prevent accidents, it also requires sophisticated testing and using an 
      infrastructure-management technology like service mesh.
   2) The client-server pattern is a peer-to-peer architecture that is comprised of a client, which requests a service, and a server, which provides the the service. Examples include banking, file sharing, email, and the World Wide Web. One 
      advantage of this pattern is that data and network peripherals are centrally managed, however, the server is expensive.
   3) The command query responsibility segregation (CQRS) pattern handles the situation where database queries happen more often than the data changes. It separates read and write activities to provide greater stability, scalability, and 
      performance, but it requires more database technologies and therefore may increase costs.
   4) The controller-responder pattern divides the architecture into two components: The controller handles the data and distributes workloads, and the responder replicates data from the controller and generates results. One advantage is 
      that you can read data from the responder without affecting the data in the controller, but if the controller fails, you may lose data and need to restart the application.
   5) The event sourcing pattern is good for applications that use real-time data. It sends a continuous stream of messages to a database, web server, log, or another target. It's very flexible but demands a highly efficient and reliable 
      network infrastructure to minimize latency.
   6) The layered pattern is good for e-commerce, desktop, and other applications that include groups of subtasks that execute in a specific order. The layered pattern makes it easy to write applications quickly, but a disadvantage is that 
      it can be hard to split up the layers later.
   7) The microservices pattern combines design patterns to create multiple services that work interdependently to create a larger application. Because each application is small, it's easier to update them when needed, but the complexity 
      means you need greater architectural expertise to make everything work correctly.
   8) The model-view-controller (MVC) pattern divides an application into three components. The model contains the application's data and main functionality; the view displays data and interacts with the user; and the controller handles user 
      input and acts as the mediator between the model and the view. This pattern enables the application to generate various views, but its layers of abstraction increase complexity.
   9) The pub-sub pattern sends (publishes) relevant messages to places that have subscribed to a topic. It's easy to configure but more challenging to test because interactions between the publisher and the subscriber are asynchoronous.
   10) The saga pattern is used for transactions with multiple steps, such as travel reservation services. A "saga" includes the various steps that must happen for the transaction to complete. This pattern enables transactions (ideally with 
       five or fewer steps) to happen in loosely coupled, message-driven environments, but it requires a lot of programming and can be complex to manage.
   11) The sharding pattern segments data in a database to speed commands or queries. It ensures storage is consumed equally across instances but demands a skilled and experienced database administrator to manage sharding effectively.
   12) The static content hosting pattern is used to optimize webpage loading time. It stores static content (information that doesn't change often, like an author's bio or an MP3 file) separately from dynamic content (like stock prices). 
       It's very efficient for delivering content and media that doesn't change often, but downsides include data consistency and higher storage costs.
   13) The strangler pattern is used when you're making incremental changes to a system. It places the old system behind an intermediary to support incremental transformation, which reduces risk compared to making larger changes. However, 
       you need to pay close attention to routing and network management and make sure you have a rollback plan in place in case things go wrong.
   14) The throttling (or rate-limiting) pattern controls how fast data flows into a target. It's often used to prevent failure during a distributed denial of service attack or to manage cloud infrastructure costs. To use this pattern 
       successfully, you need good redundancy mechanisms in place, and it's often used alongside the circuit breaker pattern to maintain service performance.

- Los principios SOLID: The SOLID principles of software architecture consist of a collection of guidelines that can help programmers build better software. These principles help developers build loosely coupled, cohesive systems that have 
  high cohesion and low coupling.
    > The Single Responsibility Principle (S): Per the Single Responsibility Principle, every class should not have more than one responsibility, (i.e., it should have one and only one purpose). If you have multiple responsibilities, the 
      functionality of the class should be split into multiple classes, with each of them handling a specific responsibility. Types with many responsibilities tend to be coupled with one another. This coupling can lead to fragile designs and 
      such classes become difficult to manage and maintain over time. If you adhere to this principle, here are the benefits of the Single Responsibility Principle:
       + Simplicity: The code is easier to understand since the functionality is not spread across multiple classes. This will help you keep your simple, manageable and clean.
       + Maintainability: This reduces the complexity and increases the maintainability of your code since each class has a single responsibility only.
       + Reusability: Since there are no dependencies between different parts of the system, you can reuse components across the application without worrying about breaking anything else.

    > The Open Closed Principle (O): According to the Open Closed Principle, classes should be open for extension, (i.e., they can be extended but closed for modification and they should not be modifiable). When classes are open for 
      extension but closed for modification, developers can extend the functionality of a class without having to modify the existing code in that class. In other words, programmers should make sure their code can handle new requirements 
      without compromising on the existing functionality. Bertrand Meyer is credited with introducing this principle in his book entitled “Object-Oriented Software Construction.” According to Meyer, “a software entity should be open for 
      extension but closed for modification.”
      The idea behind this principle is that it allows developers to extend software functionality while preserving the existing functionality. In practical terms, this means that new functionality should be added by extending the code of an 
      existing class rather than by modifying the code of that class. When code is extended rather than modified, there is less risk of introducing bugs. It can also make it easier to understand code since the structure of classes is not 
      changed when new functionality is added. Extending classes is not always possible or desirable, however. In some cases, creating a new class with the required functionality may be better, rather than extending an existing class.
      Here are the benefits of the Open Closed Principle at a glance:
       + You can add new features without changing existing code
       + Your application will be more flexible because it can evolve over time
       + It reduces the time and effort required to add new features to an application
       + It increases the maintainability of the source code

     > Liskov Substitution Principle (L): The Liskov Substitution Principle, or LSP, is a design principle that states that replaceable and interchangeable types should behave similarly. The principle, which Barbara Liskov introduced in her 
       1988 paper, “Data Abstraction and Hierarchy,” states that, if you have a type T and a subtype S of T, then objects of type S should be substitutable for objects of type T.
       It follows that if B is a subtype of A, then objects of type B can be used as substitutes for objects of type A. In other words, if you have a class A and a class B, with B being a subclass of A, then you can replace any instance of B 
       with an instance of A.
       It states that a child class should be able to be used in place of a parent class without any errors. This principle is essential for ensuring that software components are interchangeable and can be easily replaced without affecting 
       the rest of the code.
     
     > The Interface Segregation Principle (I): The Interface Segregation Principle is a design principle that says you should “write client-specific interfaces, and make sure clients don’t depend on methods of other interfaces.” This means 
       that, if you want to use an alternative implementation, you can do so without having to change any client code. In other words, an interface should be designed so that clients only have to know about the methods they need to use. This 
       principle is fundamental in object-oriented programming (OOP), where interfaces are used to define the contracts between objects. Adhering to the Interface Segregation Principle can make a developer’s code more flexible and 
       maintainable. This helps to prevent tight coupling between objects, which makes them easier to reuse and maintain. Here are the benefits of the Interface Segregation Principle at a glance:
        + Reduces coupling between components because they don’t share the same interface
        + Encourages loose coupling between components, which makes them easier to change, maintain and testable
        + Allows components to be replaced with alternative implementations
      
      > Dependency Inversion Principle (D): Per the Dependency Inversion Principle, high-level modules in an application should not rely on their low-level modules. Instead, both should rely on abstractions. While details should depend on 
        abstractions, the reverse is not implied. The Dependency Inversion Principle recommends abstractions over concretions. Here are several benefits to the Dependency Inversion Principle:
         + It makes code more flexible, reusable, modular, and easier to change
         + It makes code more testable since high-level modules can be mocked or stubbed out when testing low-level modules
         + It can make code more flexible since new low-level modules can be easily plugged in without having to make changes to high-level modules.
       One way to achieve dependency inversion is through the use of abstractions. Abstractions can be created using interfaces or abstract base classes. By depending on abstraction instead of a concrete implementation, high-level modules 
       can be easily changed to use different implementations without making any changes.
       Developers can also achieve dependency inversion by leveraging inversion of control containers. These containers manage the creation and lifetime of objects and provide a mechanism for resolving dependencies. Using an inversion of 
       control container allows high-level modules to be easily tested without worrying about dependencies. However, dependency inversion is not always easy to implement.

  These principles can help you build resilient, maintainable, and extendable applications. Some of the benefits of adhering to the solid principles of software architecture include:
   ~ More robust systems: By following solid principles, developers can create systems that are more resistant to change and less likely to break when modifications are made.
   ~ Better Reusability: By adhering to these principles, you can build reusable components.
   ~ Easier maintenance: Solid principle-based systems are typically easier to maintain and understand, making them less time-consuming and expensive to keep up-to-date.
   ~ Better scalability: Another advantage of using solid principles is that systems designed this way are often more scalable, meaning they can be extended over time if needed.

- Interpolation: 

- Proxy: 

- Proxy inverso: 

- Router & firewall: 

- Compresion: 

- Escalamiento vertical: Mi servidor necesita ser más potente y necesito mejorar el hardware para tener un servidor más potente. Básicamente, significa mejorar el hardware del servidor, para que sea más potente, mucho más rápido y pueda 
  atender una mayor cantidad de peticiones y, por lo tanto, mejorar el performance de los aplicativos. El escalamiento vertical requiere de grandes inversiones de recursos por parte de las empresas para poder contar con los equipos más 
  actualizados posibles en el mundo de la tecnología. Además, llegará un punto en el que alcanzaremos un tope tecnológico, y tendremos que esperar a que se desarrollen mejores soluciones de hardware para poder comprarlas (un tiempo de espera 
  que una empresa difícilmente puede contener).

- Escalamiento horizontal: Dividamos las tareas en multi-instancias de servidores que alojen el aplicativo y se apoyen en las tareas complejas. Este modelo es más complejo, pero mucho más interesante y eficiente. La escalabilidad horizontal 
  significa utilizar múltiples servidores, conocidos como nodos, los cuales trabajarán en equipo para resolver un problema en particular. A esta red de nodos trabajando juntos, se le conoce como cluster, haciendo referencia a que estos 
  múltiples servidores se encuentran en un contexto general donde todos conocen cómo ayudarse a las tareas más complejas. Así, la diferencia radica en que, cuando necesitamos más recursos, no hace falta tirar el servidor que ya tenemos a la 
  basura para comprar uno mejor, sino que podemos conectar otra instancia de otro servidor para que se una a la red de nodos y forme parte del cluster.
  
- Maquina virtual: 

- Kernel: 
  
- Docker: Docker es una plataforma gestora de contenedores. Nos permitirá entonces empaquetar en un contenedor nuestro aplicativo, y posteriormente compartirlo a algún lado, para que al momento en el que tenga que ejecutarse, este pueda 
  hacerlo dentro del contenedor aislado y asegurar que la ejecución será satisfactoria siempre. La lógica de Docker se basa en tres pasos generales: 
    1) Un dockerfile: Este cuenta con las instrucciones paso a paso para que nuestro proyecto genere una imagen
    2) Una imagen es el equivalente de una clase, pero con un proyecto completo. Cuando generamos la imagen de una aplicación, significa que podemos generar múltiples contenedores a partir de esa aplicación (como instancias) 
    3) Contenedor: El punto final en el que ejecutamos el aplicativo, pero esta vez desde un entorno cerrado.  

- Imagen base: Escribimos en nuestro código --> FROM node. Esto significa que estaremos tomand una imagen base del entorno de node, para poder configurar nuestra app. 

- Contenedor: Un contenedor es un entorno de ejecución para un aplicativo en particular, el cual tiene todas las dependencias que necesita dicha aplicación para poder correr sin problemas de compatibilidad. La clave de un contenedor es el 
  concepto del aislamiento, esto indicando que podemos tener múltiples contenedores, con diferentes entornos, con diferentes dependencias, y nunca habrá conflictos porque la instalación y uso de las dependencias se hace de manera interna. 
  Además, ya que el entorno no ocupa utilizar todo el sistema operativo (sólo el kernel), se vuelven realmente livianos en comparación con mover todo un sistema operativo en cada aplicativo.

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$





                                                                                                                   

                                                                                                                   
