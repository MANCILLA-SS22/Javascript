                                                                                                                   Redux-Toolkit & React-Redux

https://redux.js.org/usage/deriving-data-selectors
https://redux-toolkit.js.org/api/createSlice#reducers
https://redux-toolkit.js.org/rtk-query/usage/automated-refetching#definitions 
https://redux-toolkit.js.org/rtk-query/api/createApi#tagtypes
https://redux-toolkit.js.org/rtk-query/usage/queries#selecting-data-from-a-query-result
https://redux-toolkit.js.org/rtk-query/usage/mutations
https://redux-toolkit.js.org/rtk-query/usage/manual-cache-updates#optimistic-updates
https://redux-toolkit.js.org/rtk-query/api/created-api/hooks#usequery
https://redux-toolkit.js.org/rtk-query/api/createApi#basequery
https://redux-toolkit.js.org/rtk-query/api/fetchBaseQuery#baseurl
https://redux-toolkit.js.org/rtk-query/usage/queries
https://redux-toolkit.js.org/rtk-query/usage/customizing-queries

- Provider: The <Provider> component makes the Redux store available to any nested components that need to access the Redux store. Since any React component in a React Redux app can be connected to the store, most applications will render a 
  <Provider> at the top level, with the entire app’s component tree inside of it. Typically, you only need to pass <Provider store={store}>.
  
- ApiProvider: It simplifies data fetching and caching in your Redux applications. ApiProvider is a component that integrates with the store and provides context for the API services created using createApi. It sets up the necessary 
  middleware and manages the caching, invalidation, polling, and other aspects of data fetching.
    1. Context Provider: ApiProvider provides the context needed for RTK Query to function correctly. It ensures that the API service's hooks and other functionality are connected to the Redux store.
    2. Middleware Setup: When using ApiProvider, it automatically sets up the required middleware for handling API requests and responses, which includes caching, re-fetching, and more.
    3. Simplifies Configuration: Using ApiProvider simplifies the configuration needed to start using RTK Query. It abstracts away the manual setup of middleware and store enhancements required for API slices.

- store: The Redux store is like a giant container that holds all the data for your application.

- selector: It is a function used to extract and compute derived data from the Redux store state. Selectors help in selecting specific pieces of state and can also be used to transform or compute data based on that state. They play a crucial 
  role in ensuring that components only receive the data they need, thus improving performance and maintainability.
    > State Extraction: Selectors are primarily used to read and return a specific part of the Redux state.
    > Derived data: Selectors can compute derived data, meaning they can perform calculations or transformations on the state to produce new data that components might need.
    > Memoization: When created using "createSelector", selectors are memoized. This means they remember the previous inputs and outputs and only recompute the result if the inputs change, thus optimizing performance.
    > Reusability and composability: They can be composed from other selectors, promoting code reuse and modularity. They can be reused across different parts of the application, making it easier to maintain consistent data access patterns.

  It is any function that accepts the Redux state tree as an argument, and returns some extracted or derived data. They typically expect the entire Redux state object as an argument, while slice reducers only have access to a specific subset 
  of the entire Redux state

- action: An action is an object that describes what changes need to be made to the state of your application. It sends data from your application to the Redux store and serves as the only way to update the store. An action must have a 
  "type" property describing the action being performed. This "type" property is typically defined as a string constant to ensure consistency and avoid typos.
  In addition to the "type" property, an action can have a "payload" property. The "payload" property represents the data that provides additional information about the action being performed. For example, if an action type is ADD_TASK, the 
  payload might be an object containing a new task item's "id", "text", and "completed status". 
  "actions" doesn't allow to access the reducers methods to find up, but instead we get methods created automatically by Redux Toolkit, which when called will create action objects for us. These methods on the actions object which we can 
  call will create action objects for us. Therefore these methods are called action creators and they will create action objects for us where these objects already have a type property with a unique identifier per action. Automatically 
  created behind the scenes. So we don't have to worry about action identifiers. We don't have to create those action objects on our own. We can tap into this actions key into this actions object on our createSlice and execute these action 
  creator methods, which with their name match our reducer methods to dispatch actions, which will then ultimately trigger those different reducer methods.

- dispatch: dispatch is a function provided by the store that allows you to send an action to update the state of your application. When you call dispatch, the store runs an action through all of the available reducers, which in turn update 
  the state accordingly. You can think of dispatch as a mail carrier who delivers mail to different departments in a large company. Just like how the mail carrier delivers mail to different departments, dispatch delivers actions to various 
  reducers in your Redux store. Each reducer is like a department in the company that processes the mail and updates its own part of the company's data.

- reducer: A reducer is a function that takes in the current state of an application and an action as arguments, and returns a new state based on the action.
  Remember that reducer functions must be pure, side-effect free and synchronous. So your reducer functions should take some input in the case of the Redux reducer, the old state and the action, and then produce some output. And that's, by 
  the way not just the case for Redux reducer function. The reducer function you pass to use reducer, is react hook, works in the same way. It has nothing to do with redux, but it just general reducer concept that you have a pure, side 
  effects synchronous function that takes input and produces some output. And for the same input, for the same values, it will always produce the same output, without any side effects that happen along the way without any asynchronous code 
  that blocks it. No code of that kind must be part of your reducer functions.
    
- action creators and action types: These are fundamental concepts used to manage state in a Redux store. RTK simplifies and streamlines the process of working with these concepts compared to plain Redux.
    > action types: Action types are constants that represent the type of action being performed. They are typically defined as strings and are used to identify actions in the reducers. 
      In Redux Toolkit, you don't usually need to define these explicitly, as they are generated automatically when you create actions.
      Constants that represent the type of action being performed. In Redux Toolkit, they are usually generated automatically.
    > action creators: Action creators are functions that return action objects. An action object contains a type property (representing the action type) and an optional payload property 
      (containing any data needed to perform the action). Redux Toolkit simplifies the creation of action creators using functions like createAction and createSlice.
      Functions that return action objects. They can be created using createAction or automatically generated by createSlice.  
      
- thunk: It's a term that means "a piece of code that does some delayed work. So it's simply a function, that delays an action until later, until something else finished. We could write an action creator as a thunk, to write an action 
  creator, which does not immediately return the action object, but which instead, returns another function which eventually returns the action. So that we can run some other code before we then dispatch the actual action object that we did 
  want to create. 
  In RTK, a "thunk" is a middleware function that allows you to write action creators that return a function instead of an action. This function can then perform asynchronous operations, such as fetching data from an API or dispatching 
  multiple actions sequentially.
  In RTK, actions are usually plain objects, but when you need to perform asynchronous tasks, plain action objects are not sufficient. Thunks in Redux Toolkit enable you to manage asynchronous operations and complex synchronous logic 
  efficiently. By using thunks, you can keep your components clean and focus on handling side effects in a structured manner. Redux Toolkit’s createAsyncThunk further simplifies this process by automatically generating action types and 
  creators, making it easier to manage different states of asynchronous operations.
                                                                                                                   
- The "prepare" callback: It is a function used in createSlice to customize the payload and meta properties of an action. This is useful when you need to preprocess the action's payload or add additional metadata before the action is handled 
  by the reducer. It returns the action payload as it needs to be formatted. 
  If you need to customize the creation of the payload value of an action creator by means of a prepare callback, the value of the appropriate field of the reducers argument object should be an object instead of a function. This object must 
  contain two properties: reducer and prepare. The value of the reducer field should be the case reducer function while the value of the prepare field should be the prepare callback function.
  
- The "extraReducers" builder callback" notation: Sometimes a slice reducer needs to respond to other actions that weren't defined as part of the slices reducers, and that is like what happens when using "createAsyncThunk" or responding to 
  an action from another slice. It receives a builder object that has methods like addCase and addMatcher which are used to add additional reducers. And this builder parameter is an object that lets us definie additional case reducers that 
  run in response to the actions refined outside of the slice. However, unlike the reducers field, each individual case reducer inside of extraReducers will not generate a new action type or action creator. 
  If two fields from reducers and extraReducers happen to end up with the same action type string, the function from reducers will be used to handle that action type.
  We would use extraReducers when dealing with an action that we have already defined somewhere else. The extrareducers property in createSlice can be used as a function or as an object. extraReducers in Redux Toolkit provides a powerful way 
  to handle actions that are not defined within the slice itself. It is especially useful for managing the side effects of asynchronous actions and for ensuring that your slices remain decoupled and maintainable. By using extraReducers, you 
  can keep your action handling logic organized and clear, making your Redux store easier to manage and extend.

- Entity: It refers to a structured and normalized way of storing (or manage) collections of related items within the Redux state, in a normalized and efficient manner. This concept isused in conjunction with the createEntityAdapter utility, 
  which helps manage such collections efficiently.
  The term "Entity" is used to refer to a unique type of data object in an application. Entities are individual pieces of data, typically objects, that are identified by a unique key (usually an ID). Storing data as entities involves 
  normalizing the state, which means storing the data in a flat structure rather than deeply nested objects. This makes it easier to update, delete, and retrieve specific items without affecting other parts of the state.  
  For example, in a blogging application, you might have User, Post, and Comment data objects, with many instances of each being stored in the 
  client and persisted on the server. User is an "entity" - a unique type of data object that the application uses. Each unique instance of an entity is assumed to have a unique ID value in a specific field.

- Query: 

- Memoization: Storing the results of expensive function calls and returning the cached result when the same inputs occur again.
  Memoization in RTK Query refers to the process of caching the results of a function so that if the function is called again with the same arguments, the cached result is returned instead of recalculating the result. This is particularly 
  useful in reducing redundant network requests and improving performance by reusing previously fetched data. In the context of RTK Query (Redux Toolkit Query), memoization helps in the following ways:
    > Caching Requests: When a query is made, RTK Query caches the response. If the same query is requested again with the same parameters, RTK Query returns the cached response instead of making a new network request. This reduces 
      unnecessary API calls and speeds up the application.
    > Selective Refetching: RTK Query can be configured to refetch data only when specific conditions are met (e.g., after a certain time has passed or when the data becomes stale). This ensures that the application has the latest data 
      without overwhelming the server with requests.
    > Avoiding Recalculation: By memoizing query results, RTK Query avoids recalculating the data when the input parameters haven't changed. This leads to more efficient data management and rendering in the application.

-Tags: They are just a name that you can give to a specific collection of data to control caching and invalidation behavior for re-fetching purposes. It can be considered as a 'label' attached to cached data that is read after a mutation, to 
 decide whether the data should be affected by the mutation.   

- Normalization: It refers to the process of structuring your Redux state in a flat and organized manner, rather than deeply nested. This concept is borrowed from database design, where data is stored in a way that minimizes redundancy and 
  ensures consistency.
    1. Simplifies Updates: Updating deeply nested state can be complex and error-prone. Normalized state makes updates straightforward.
    2. Avoids Redundancy: By storing each entity in a single place, you avoid duplicating data and reduce the risk of inconsistencies.
    3. Improves Performance: Selectors can efficiently access and compute derived data without needing to traverse nested structures.
    4. Easier Debugging: A flat state structure is easier to inspect and understand. 
  In a normalized state, entities are stored in a flat structure, typically using an object where keys are entity IDs and values are the entity objects. Additionally, an array of IDs is maintained to keep track of the 
  order of entities. Normalized state structure is a recommended approach for storing items, and normalization means no duplication of data and it also means keeping the items stored in a lookup table by item id.
  
- Error handling: If your query or mutation happens to throw an error when using fetchBaseQuery, it will be returned in the error property of the respective hook. The component will re-render when that occurs, and you can show appropriate UI 
  based on the error data if desired. Some Error Display Examples are "Query Error" and "Mutation Error". If you need to access the error or success payload immediately after a mutation, you can chain .unwrap().  
  
- Manual Cache Updates: There are use cases when manual cache updates are necessary, such as "optimistic" or "pessimistic" updates, or modifying data as part of cache entry lifecycles. RTK Query exports thunks for these use cases, attached to 
  api.utils: updateQueryData and upsertQueryData. Since these are thunks, you can dispatch them anywhere you have access to dispatch. They're both utility functions that allow you to directly manipulate the cached data for a given query. 
    > Updating existing cache entries: For updates of existing cache entries, use updateQueryData. updateQueryData is strictly intended to perform updates to existing cache entries, not create new entries. If an updateQueryData thunk action 
      is dispatched and the endpointName + args combination that does not match any existing cache entry, the provided recipe callback will not be called, and no patches or inversePatches will be returned.
      Use cases for manual update of cache entries:
        ~ Providing immediate feedback to the user when a mutation is attempted
        ~ After a mutation, updating a single item in a large list of items that is already cached, rather than re-fetching the whole list
        ~ Debouncing a large number of mutations with immediate feedback as though they are being applied, followed by a single request sent to the server to update the debounced attempts
    > Creating new cache entries or replacing existing ones: To create or replace existing cache entries, use upsertQueryData. upsertQueryData is intended to perform replacements to existing cache entries or creation of new ones. Since 
      upsertQueryData does not have access to the previous state of the cache entry, the update may be performed only as a replacement. In comparison, updateQueryData allows patching of the existing cache entry, but cannot create a new one.
      One example use case is pessimistic updates. If the client makes an API call to create a Post, the backend could return its complete data including the id. Then we can use upsertQueryData to create a new cache entry for the 
      getPostById(id) query, preventing an extra fetch to retrieve the item later.
      
- Optimistic updates: It's used when we wish to perform an update to cache data immediately after a mutation is triggered (assuming that the server operation will succeed). If the operation fails, the changes are reverted. This can be a 
  useful pattern for when you want to give the user the impression that their changes are immediate, even while the mutation request is still in flight. We should use optimistic updates when: 
   > Enhanced User Experience: When you want the application to feel more responsive and immediate, providing feedback to the user without waiting for server confirmation.
   > Low Failure Rate: When server operations have a high success rate and errors are rare.
   > Non-Critical Data: When the data being updated is not critical or when temporary inconsistencies can be tolerated.
   > Undo Functionality: When you provide an option to undo actions, allowing users to revert changes if something goes wrong.  
  The core concepts for an optimistic update are:
   > when you start a query or mutation, onQueryStarted will be executed
   > you manually update the cached data by dispatching api.util.updateQueryData within onQueryStarted
   > then,in the case that queryFulfilled rejects: you roll it back via the .undo property of the obj you got back from the earlier dispatch, or, you invalidate the cache data via api.util.invalidateTags to trigger a full re-fetch of the data
  Where many mutations are potentially triggered in short succession causing overlapping requests, you may encounter race conditions if attempting to roll back patches using the .undo property on failures. For these scenarios, it is often 
  simplest and safest to invalidate the tags on error instead, and re-fetch truly up-to-date data from the server.
   
- Pessimistic updates: It's used when we wish to perform an update to cache data based on the response received from the server after a mutation is triggered. It waits for the server operation to complete before updating the UI. The UI is 
  only updated if the operation succeeds. The distinction between a pessimistic update and an optimistic update is that the pessimistic update will instead wait for the response from the server prior to updating the cached data. Basically, it 
  wait for the server operation to complete before updating the UI. The UI is only updated if the operation succeeds. We should use pessimistic updates when: 
   > High Failure Rate: When server operations frequently fail, and it’s crucial to ensure data consistency.
   > Critical Data: When updating critical data where consistency and accuracy are paramount.
   > Complex Error Handling: When the failure of the operation requires complex error handling or user intervention.
   > Real-Time Synchronization: When you need to ensure the client state is always synchronized with the server state.
  The core concepts for a pessimistic update are:
   > when you start a query or mutation, onQueryStarted will be executed
   > you await queryFulfilled to resolve to an object containing the transformed response from the server in the data property
   > you manually update the cached data by dispatching api.util.updateQueryData within onQueryStarted, using the data in the response from the server for your draft updates
   > you manually create a new cache entry by dispatching api.util.upsertQueryData within onQueryStarted, using the complete Post object returned by backend.
  
  
  
                                                                                               $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

- configureStore(): The standard method for creating a Redux store. It wraps createStore to provide simplified configuration options and good defaults. It can automatically combine your slice reducers, adds whatever Redux middleware you 
  supply, includes redux-thunk by default. It accepts a reducer function as a named argument and automatically sets up the store with good default settings.
    > "reducer": A callback which will receive getDefaultMiddleware as its argument, and should return a middleware array. If this option is provided, it should return all the middleware functions you want added to the store. configureStore 
      will automatically pass those to applyMiddleware. If not provided, configureStore will call getDefaultMiddleware and use the array of middleware functions it returns.
    > "middleware": A callback which will receive getDefaultMiddleware as its argument, and should return a middleware array. If this option is provided, it should return all the middleware functions you want added to the store. 
      configureStore will automatically pass those to applyMiddleware. If not provided, configureStore will call getDefaultMiddleware and use the array of middleware functions it returns.
        ~ getDefaultMiddleware: Returns an array containing the default list of middleware. By default, configureStore adds some middleware to the Redux store setup automatically If you want to customize the list of middleware, you can supply 
          an array of middleware functions to configureStore.When you supply the middleware option, you are responsible for defining all the middleware you want added to the store. configureStore will not add any extra middleware beyond what 
          you listed. It's useful if you want to add some custom middleware, but also still want to have the default middleware added as well.

- createSlice(): Accepts an object of reducer functions, a slice name, and an initial state value, and automatically generates a slice reducer with corresponding action creators and action types. This function is a more powerful and 
  convenient way to define a slice of the state, including action creators and reducers. It automatically generates action types and action creators based on the reducer functions you provide.
  
- createAsyncThunk: Accepts an action type string and a function that returns a promise, and generates a thunk that dispatches pending/fulfilled/rejected action types based on that promise. The first argument is a string that's used as the 
  prefix for the generated action type. The second argument is a creator payload callback adnd this function should return a promise that contains some data or rejected primise with an error. 
  It simplifies the process of handling asynchronous actions by abstracting much of the boilerplate code required in traditional Redux. Here's a detailed look at how createAsyncThunk works behind the scenes:
    1. Thunk Action Creator: createAsyncThunk generates an action creator that returns a thunk function when dispatched.
    2. Lifecycle Actions: It automatically generates three action types for each async operation: pending, fulfilled, and rejected.
    3. Middleware: Redux Thunk middleware intercepts these thunks and executes them, allowing side effects to be handled.
    
- createSelector: This is a function that generates memoized selectors that will only recalculate results when the inputs change. It is used to create memoized selectors that can efficiently derive computed data from the RTK, ensuring that 
  the computations are only done when the state slices involved in the selector change. If the generated output selector is called multiple times, the output will only be recalculated when the extracted values have changed.
  (Memoization ensures that a selector only recalculates its result if one of its input selectors has changed, which can significantly improve performance, especially with complex state transformations).
  It takes one or more input selectors (An array of input selectors, can also be passed as separate arguments) and an output selector, which is a function that takes the results of the input selectors as separate arguments. The output 
  selector computes the derived state. The result is cached, and the output selector is only recomputed if the inputs change. And finally, it returns a memoized selector.
  The output selectors created by createSelector have several additional properties attached to them:
    > resultFunc                       The final function passed to createSelector.
    > memoizedResultFunc               The memoized version of resultFunc.
    > lastResult                       Returns the last result calculated by memoizedResultFunc.
    > dependencies                     The array of the input selectors used by createSelector to compose resultFunc.
    > recomputations                   Counts the number of times memoizedResultFunc has been recalculated.
    > resetRecomputations              Resets the count of recomputations count to 0.
    > dependencyRecomputations         Counts the number of times the input selectors (dependencies) have been recalculated. This is distinct from recomputations, which tracks the recalculations of the result function.
    > resetDependencyRecomputations    Resets the dependencyRecomputations count to 0.
    > memoize                          Function used to memoize the resultFunc.
    > argsMemoize                      Function used to memoize the arguments passed into the output selector.  
  
  By leveraging memoization, createSelector helps optimize performance, especially for complex state transformations, and makes your codebase more maintainable and readable. Here are the key reasons for using createSelector:
    > Memoization: 
      ~ Efficiency: createSelector memoizes the results of selector functions. This means that if the inputs to a selector haven't changed, it will return the cached result instead of recalculating. This avoids unnecessary recalculations and 
        renders, improving the efficiency of your application.
      ~ Performance: In large applications with complex state, recalculating derived data can be costly. Memoization ensures that computations are only performed when necessary.
    > Compatibility: 
      ~ Modularity: createSelector allows you to compose selectors from smaller selectors. This modular approach makes your code easier to read, maintain, and test.
      ~ Reuse: You can reuse selectors across different parts of your application, promoting DRY (Don't Repeat Yourself) principles.
    > Separation of Concerns:
      ~ Logic Encapsulation: Selectors encapsulate the logic of extracting and transforming state data. This keeps your component code clean and focused on presentation logic, while selectors handle data manipulation.
      ~ Centralized Logic: By defining data derivation logic in selectors, you ensure that changes to how data is derived are centralized, reducing the risk of bugs and making the logic easier to update.
    > Improved Readability and Maintainability:
      ~ Declarative Data Selection: Selectors provide a declarative way to specify what data your components need, making the data dependencies of your components explicit and easier to understand.
      ~ Ease of Testing: Selectors can be tested independently of your components, allowing you to verify that data derivation logic is correct without involving the UI layer.
  
- createEntityAdapter: Generates a set of reusable reducers and selectors to manage normalized data in the store. In summary, the createEntityAdapter function in Redux Toolkit primarily accepts an object with two optional properties: 
  selectId and sortComparer, allowing you to customize how entities are identified and sorted in your state.
  It is a function that generates a set of prebuilt reducers and selectors for performing CRUD operations on a normalized state structure containing instances of a particular type of data object. These reducer functions may be passed as case 
  reducers to createReducer and createSlice. They may also be used as "mutating" helper functions inside of createReducer and createSlice. It may be called multiple times in an application. If you are using it with plain JavaScript, you may 
  be able to reuse a single adapter definition with multiple entity types if they're similar enough (such as all having an entity.id field).
  A "entity adapter" instance. An entity adapter is a plain JS object (not a class) containing the generated reducer functions, the original provided selectId and sortComparer callbacks, a method to generate an initial "entity state" value, 
  and functions to generate a set of globalized and non-globalized memoized selector functions for this entity type.
  
    > "getInitialState": Returns a new entity state object like {ids: [], entities: {}}. It accepts an optional object as an argument. The fields in that object will be merged into the returned initial state value. For example, perhaps you 
       want your slice to also track some loading state
    > "selectAll" is a selector that allows you to replace all the entities in the state with a new set of entities, effectively resetting the collection This can be particularly useful when you need to update the state with a new list of 
      items, such as when fetching data from an API. It returns all entities in the collection as an array. It's a convenient way to access the entire list of entities stored in the normalized state.
      To use selectAll, you need to first set up your entity adapter and include it in your Redux slice and store. It s a convenient way to retrieve all entities in your state as an array. It simplifies the process of accessing and 
      displaying a list of entities in your application. By using selectAll, you can ensure that your component remains efficient and easy to read.
   > ".getSelectors()" Can create a set of memoized selectors based on the location of this entity state.
      The entity adapter will contain a getSelectors() function that returns a set of selectors that know how to read the contents of an entity state object:
      selectIds: returns the state.ids array. selectEntities: returns the state.entities lookup table. selectAll: maps over the state.ids array, and returns an array of entities in the same order. selectTotal: returns the total number of 
      entities being stored in this state.  selectById: given the state and an entity ID, returns the entity with that ID or undefined.
      Because selector functions are dependent on knowing where in the state tree this specific entity state object is kept, getSelectors() can be called in two ways:
       ~ If called without any arguments (or with undefined as the first parameter), it returns an "unglobalized" set of selector functions that assume their state argument is the actual entity state object to read from.
       ~ It may also be called with a selector function that accepts the entire Redux state tree and returns the correct entity state object.
      
- createApi():The core of RTK Query's functionality. It allows you to define a set of endpoints and describe how to retrieve data from a series of endpoints, including configuration of how to fetch and transform that data. In most cases, you 
  should use this once per app, with "one API slice per base URL" as a rule of thumb.  
    > "baseQuery": The base query used by each endpoint if no queryFn option is specified. RTK Query exports a utility called fetchBaseQuery as a lightweight wrapper around fetch for common use-cases.
      ~ args: The return value of the query function for a given endpoint. This arguments comes from the "query" method.
      ~ api: The BaseQueryApi object contains the following parameters: signal, abort, dispatch, getState, extra, endpoint, type and forced. (It's a built-in method by redux, whilst "args" are the parameters we sent manually).
      ~ extraOptions: The value of the optional extraOptions property provided for a given endpoint
    > "transformResponse" allows you to modify or process the response data before it is stored in the Redux state, and also manipulate the data returned by a query or mutation. In some cases, you may want to manipulate the data returned 
      from a query before you put it in the cache. In this instance.
    > "providesTags" facilitates efficient caching and automatic re-fetching of data. It is part of the caching mechanism that RTK Query uses to manage and invalidate cache entries. It allows you to define a list of tags that a query 
      endpoint provides. These tags can then be used to invalidate or refetch data whenever certain mutations (like creating, updating, or deleting data) occur. By specifying tags, you enable RTK Query to automatically know which queries 
      need to be re-fetched when related data changes, thus keeping your application state up-to-date with minimal manual intervention.
    > "invalidatesTags" is used by mutation endpoints. Determines which cached data should be either re-fetched or removed from the cache. Expects the same shapes as providesTags. For example, if we add, update or eliminate a new element, 
       we'll have to find a way to display it on the screen without reloading our app. So, "invalidatesTags" takes the obsolete cache values and will invalidate them so that it can extract the new values from the server (without reloading).
    > "keepUnusedDataFor" Defaults to 60 (this value is in seconds). This is how long RTK Query will keep your data cached for after the last component unsubscribes. For example, if you query an endpoint, then unmount the component, then 
      mount another component that makes the same request within the given time frame, the most recent value will be served from the cache. It may be used either inside "endpoints" or outside (together with reducerPath).
    > ".unwrap()": If you need to access the error or success payload immediately after a mutation, you can chain this command. (Remember that this must be in an async function). 
      It's used to handle the results of asynchronous thunks more conveniently, especially when dealing with fulfilled or rejected states of those thunks. The main uses are:
        ~ Access Data Directly: It returns the actual data from a fulfilled action, making it easier to work with the results without having to extract it from the action payload.
        ~ Error Handling: It throws an error if the thunk was rejected, allowing you to use try...catch blocks for error handling in a more straightforward way.
        ~ Simplified Access to Payload: When a thunk resolves successfully, the returned action contains the result in the payload property. Without .unwrap(), you need to manually extract this data. With .unwrap(), you directly get the 
          result, avoiding the need for extra property access.
        ~ Error Handling: If a thunk is rejected, the action still resolves, but you have to check the rejected status and handle errors separately. Using .unwrap(), if the thunk rejects, it throws an error, which you can catch using 
          try...catch. This makes error handling more natural and integrates well with async/await syntax.
 
- fetchBaseQuery(): A small wrapper around fetch that aims to simplify requests. Intended as the recommended baseQuery to be used in createApi for the majority of users. It's an optimal way to replace axios or "fetch", avoiding complex logic.
  This return a base query function (which is used internally by RTK Query) that handles making network requests, which is used as the base query in an RTK Query API slice, and you can use to define how API requests are made. You can also 
  customize request behavior using options like baseUrl, credentials, and prepareHeaders. It abstracts the underlying fetch logic and allows you to customize how requests are prepared, sent, and handled. When you call fetchBaseQuery with a 
  configuration object. This base query function takes an argument that includes the endpoint details and the request parameters, and it returns a promise that resolves with the response data or an error. For example, we would get the 
  following object depending on the response:  { data:{...}, meta:{...} } or { error:{...}, meta:{...} }
   > baseUrl: Sets the base URL for the API requests. For example: 'http://localhost:3500'
   > "credentials": It instructs the browser to include credentials (such as cookies, authorization headers, authentication tokens or TLS client certificates) and if they should be should be sent in the fetch request to the specified baseUrl. 
    It's particularly important when making cross-origin requests to ensure that cookies (like session tokens) are sent to the server. It's crucial for authentication scenarios where the server relies on cookies to verify the client's session
      ~ 'omit': Never send or receive cookies.
      ~ 'same-origin': Send cookies only if the request is to the same origin as the script calling the fetch.
      ~ 'include': Always send cookies, even for cross-origin requests. It's crucial becasue our application needs to maintain a user session across multiple requests, which is common in authenticated applications. The server requires cookies 
         to authenticate requests and manage sessions, especially in cross-origin requests. And we need to ensure that cookies are always sent with the request, regardless of whether the request is to the same origin or a different origin.
   > prepareHeaders: Allows you to inject or modify headers on every request. You can specify (customize) headers of your API requests at the endpoint level. By accessing the current Redux state, you can add authentication tokens, setting 
     content types, or including any other necessary headers dynamically to ensure that your requests are properly configured before they are sent. This is essential for handling authenticated requests, setting content types, or including any 
     custom headers required by your API. This function provides a way to dynamically add or alter headers based on the current state or other conditions. The main porpose is that it's used to customize the headers for each request. This is 
     particularly useful for adding authentication tokens, setting content types, or including any other necessary headers dynamically.    
     It takes two arguments: the headers object and, as a convenience mechanism, the second argument allows you to use getState to access your redux store in the event you store information you'll need there such as an auth token. 
     Additionally, it provides access to extra, endpoint, type, and forced to unlock more granular conditional behaviors. You can mutate the headers argument directly, and returning it is optional.
       ~ getState(): function provides access to the current Redux state. This can be useful when you need to customize the behavior of your fetchBaseQuery or include dynamic data from the state in your requests. This function allows you to 
         access the Redux state, which can be useful for dynamically setting headers based on the current state, such as including an authentication token. It'll return two parameters: "api and "auth".

- createAction(): Generates an action creator function for the given action type string. It generates an action creator function. 
  
- createReducer(): That lets you supply a lookup table of action types to case reducer functions, rather than writing switch statements. In addition, it automatically uses the immer library to let you write simpler immutable updates with 
  normal mutative code, like state.todos[3].completed = true.


- updateQueryData: It updates an already existing cache entry. For updates of existing cache entries, use this. It requires the endpoint name and cache key arguments, so it knows which piece of cache state to update.
  We could use it when we have a list of posts cached, and we want to add a new post to this list.
    > Purpose: This function is used to update the existing cached data for a specific query.
    > Behavior: It modifies the current cached data based on the provided updater function. This means you need to have some existing data in the cache for the query; otherwise, updateQueryData has no effect.
    > Usage: You provide a query endpoint, query arguments, and an updater function that receives the current cached data and returns the new data.
  Some key differences are: I requires existing cached data to work. It uses an updater function to modify the existing data. And, when you need to modify existing cached data (e.g., adding a new item to a list).

- upsertQueryData: It creates or replaces cache entries. We could use it when we want to make sure that a specific list of posts is in the cache, regardless of whether it was there before.
    > Purpose: This function is used to update the cached data if it exists, or insert new data if it doesn't.
    > Behavior: It first checks if there is existing cached data for the query. If there is, it updates it; if not, it sets the provided data as the new cache.
    > Usage: You provide a query endpoint, query arguments, and the new data to be upserted into the cache.
  Some jey differeneces are: It does not require existing cached data and will insert new data if none exists. It directly sets or updates the cached data with the provided new data. And when we need to ensure the data is present in the 
  cache, either by inserting it if it's missing or updating it if it already exists.

- onQueryStarted(): It is a lifecycle hook that is used to run additional logic when a query or mutation is initiated. This can be particularly useful for handling optimistic updates, triggering side effects, or dispatching additional actions 
  when a query begins. The key Use Cases for onQueryStarted are:
    1. Optimistic Updates: Immediately update the UI based on the assumption that the server operation will succeed, providing a more responsive user experience.
    2. Side Effects: Perform additional operations, such as logging, analytics tracking, or dispatching other Redux actions.
    3. Error Handling: Manage errors in a centralized way by handling them when the query fails.
  When defining an endpoint in RTK Query, you can include the onQueryStarted option in the object of "builder" configuration. This function receives the argument of the query/mutation and an object with several utilities (dispatch, getState, 
  extra, requestId, queryFulfilled, etc.). Them, it's executed right after the query is started, but before it's resolved or fails, allowing you to handle a variety of use cases. 
  With onQueryStarted, optimistic updates make the app feel faster and more responsive, allows handling of side effects related to queries in a centralized manner, and provides a straightforward way to manage errors specific to a query.
  When using this hook, we have to keep into account that the 2nd parameter is the destructured `MutationLifecycleApi`. And we'll get the following parameters: dispatch, getState, queryFulfilled, requestId, extra, getCacheEntry.
  As for the first paramaeter, they'll be those values (variables) we created previously.
                                                                                               $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$  
  
- useSelector: Read data from the store. Allows you to extract data from the Redux store state for use in this component, using a selector function.
  The selector will be called with the entire Redux store state as its only argument. The selector may return any value as a result, including directly returning a value that was nested inside state, or deriving new values. The return value 
  of the selector will be used as the return value of the useSelector() hook.
  The selector will be run whenever the function component renders (unless its reference hasn't changed since a previous render of the component so that a cached result can be returned by the hook without re-running the selector). 
  useSelector() will also subscribe to the Redux store, and run your selector whenever an action is dispatched.
  When an action is dispatched, useSelector() will do a reference comparison of the previous selector result value and the current result value. If they are different, the component will be forced to re-render. If they are the same, the 
  component will not re-render. useSelector() uses strict === reference equality checks by default, not shallow equality (see the following section for more details).
  You may call useSelector() multiple times within a single function component. Each call to useSelector() creates an individual subscription to the Redux store. Because of the React update batching behavior used in React Redux v7, a 
  dispatched action that causes multiple useSelector()s in the same component to return new values should only result in a single re-render.

- useDispatch: This hook returns a reference to the dispatch function from the Redux store. It returns the store's dispatch method to let you dispatch actions (which are into "reducers" or "createAsyncThunk").                                                                                                                
  In react-redux, the useDispatch hook is used to obtain the dispatch function from the Redux store. This function allows you to dispatch actions to the Redux store, which then triggers the appropriate reducer functions to update the state.  

- <ApiProvider />: Can be used as a Provider if you do not already have a Redux store.
